[{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette.html","id":"事例-製品ブランドのイメージ測定","dir":"Articles","previous_headings":"","what":"1. 事例: 製品ブランドのイメージ測定","title":"rSurveyAssign: tools for simulation of assignment in web surveys","text":"このパッケージについて説明するための例として、 ある製品カテゴリの\\(K\\)個の製品ブランドについて、消費者が抱いているイメージを測定したい、 という場面について考えます。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette.html","id":"つの調査手続き","dir":"Articles","previous_headings":"1. 事例: 製品ブランドのイメージ測定","what":"1.1 4つの調査手続き","title":"rSurveyAssign: tools for simulation of assignment in web surveys","text":"この調査の手続きについて考えてみましょう。まず、次の手続きが考えられます。 対象者にあるひとつのブランドを提示し、そのブランドのイメージについての設問に対する回答を求めます。 これを、\\(K\\)個すべてのブランドについて繰り返します。 この手続きでは、対象者は同一の設問に対する回答を\\(K\\)回繰り返す事になります。 ブランドの数が多いときは、回答者への負荷が高くなってしまいます。そこで、次の手続きを考えます。 調査者は、それぞれの対象者について、その人に提示するブランドを\\(J\\)個選びます。\\(J\\)はブランド数\\(K\\)よりも小さく、 十分に小さな値とします。以下ではこれを「対象者を\\(J\\)個のブランドに割り付ける」と表現します。 対象者に、割り付けられた\\(J\\)個のブランドのうちひとつを提示し、イメージについての設問に対する回答を求めます。 これを、\\(J\\)個のブランドについて繰り返します。 この手続きでは、ブランドの数がいくつあっても、対象者は設問への回答を\\(J\\)回繰り返せば良いことになります。 上記2つの手続きでは、いずれの対象者もいずれのブランドに対して割付可能であると仮定してきました。 しかし実際には、対象者はすべてのブランドについて知っているわけではないかもしれません。 対象者が知らないブランドについてイメージを訊ねても、有益な回答は得られないでしょう。 そこで、次のような手続きを考えます。 それぞれの対象者に、\\(K\\)個のブランドのリストを提示し、知っているブランドはどれか訊ねます。 それぞれの対象者を、その人が知っているすべてのブランドに割り付けます。 いずれのブランドについても知らないと答えた人に対しては、調査を中止します。 対象者に、割り付けられたブランドのうちひとつを提示し、イメージについての設問を提示し、 回答を求めます。これを、その人が割り付けられたすべてのブランド(=その人が知っているすべてのブランド)について繰り返します。 この手続きでは、対象者にその人が知らないブランドについて回答してもらうという事態を避けることが できます。しかし、たくさんのブランドを知っている人は、調査手続きA.と同じく、 同一の設問に対する回答を何度も繰り返すことになります。 回答者への負荷は回答者によってばらつき、多くのブランドを知っている人ほど負荷が高くなってしまいます。 そこで、次のような手続きを考えます。 それぞれの対象者に、\\(K\\)個のブランドのリストを提示し、知っているブランドはどれかを訊ねます。 それぞれの対象者を、その人が知っているブランドのうち\\(1\\)個～\\(J\\)個のブランドに割り付けます。 いずれのブランドについても知らないと答えた人に対しては、調査を中止します。 割り付けられた\\(J\\)個のブランドのうちひとつを提示し、 イメージについての設問群を提示し、回答を求めまず。これを、\\(J\\)個のブランドについて繰り返します。 この手続きでは、対象者にその人が知らないブランドについて回答してもらうという事態を避けることが できますし、ブランドをいくつ知っていても、対象者は設問への回答を多くても\\(J\\)回まで繰り返せば良いことになります。 4つの調査手続きについて整理しておきましょう。 調査手続きC.やD.のように、対象者の回答(各ブランドを知っているかどうか)に応じてその後の設問を変更する手続きは、古典的な質問紙調査では困難でした。web調査ならではの調査手続きといえるでしょう。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette.html","id":"調査手続きの性質","dir":"Articles","previous_headings":"1. 事例: 製品ブランドのイメージ測定","what":"1.2 調査手続きの性質","title":"rSurveyAssign: tools for simulation of assignment in web surveys","text":"調査手続きD.は、いっけん良い手続きのようにみえます。しかしこの手続きは、次の2つの深刻な問題点を持っています。 必要な対象者数がわからない 回答の集計値がバイアスを持つ","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette.html","id":"問題点1--必要な対象者数がわからない","dir":"Articles","previous_headings":"1. 事例: 製品ブランドのイメージ測定 > 1.2 調査手続きの性質","what":"問題点1. 必要な対象者数がわからない","title":"rSurveyAssign: tools for simulation of assignment in web surveys","text":"それぞれのブランドのイメージを測定するために、それぞれのブランドについて十分な件数の回答を得たいとしましょう。 調査手続きA.では、\\(N\\)人の対象者に調査すれば、各ブランドについて\\(N\\)件の回答が得られます。 調査手続きB.では、\\(N\\)人の対象者に調査すれば、全ブランドを通じて延べ \\(N \\times J\\) 件の回答が得られます。ブランドへの割付をバランス良く行えば、各ブランドについて \\((N \\times J) / K\\) 件の回答が得られるはずです。 調査手続きC.では、対象者があるブランドについて知っている割合を\\(P\\)としたとき、そのブランドについて \\(N \\times P\\) 件の回答が得られます。事前に別の情報源から \\(P\\) を推測できれば、十分な件数の回答を得るために必要な対象者数を逆算することができるでしょう。 しかし調査手続きD.では、各ブランドについて何件の回答が得られるかを事前に推測することが困難です。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette.html","id":"問題点2--回答の集計値がバイアスを持つ","dir":"Articles","previous_headings":"1. 事例: 製品ブランドのイメージ測定 > 1.2 調査手続きの性質","what":"問題点2. 回答の集計値がバイアスを持つ","title":"rSurveyAssign: tools for simulation of assignment in web surveys","text":"調査手続きD.によって得た回答の集計値がどのような性質を持つか、簡単な例を通じて考えてみましょう。 調査対象のブランドを{,b,c}の3つとし、割付ブランド数の上限\\(J\\)を2とします。対象者を割り付けるブランドは、その対象者が知っているブランドのなかから等確率で選ぶと仮定します。aについて知っている対象者は、下表の4種類に分かれます。 bとcのどちらも知らない、ないしどちらか一方しか知らない人は、必ずaに割り付けられます。 いっぽう、,b,cのすべてを知っている人がaに割り付けられる確率は\\(2/3\\)です。 このように、この調査手続きで集めたaについての回答は、aについて知っている人々のうち、他のブランドを知らない人々の回答へと偏ることになります。この偏りを割付バイアスと呼ぶことにします。 割付バイアスの大きさは、各ブランドが知られている程度や、割り付けるブランドの選び方によって複雑に変化します。そのため、推測するのは容易ではありません。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette.html","id":"このパッケージの目的","dir":"Articles","previous_headings":"1. 事例: 製品ブランドのイメージ測定","what":"1.3 このパッケージの目的","title":"rSurveyAssign: tools for simulation of assignment in web surveys","text":"調査対象者に刺激を提示し反応を測定したい一方、個々の対象者に提示できる刺激に制約があるという場面は、調査実務において珍しくありません。回答負荷や調査コストの削減のため、調査手続きD.のように割付の最適化を図る場合も多いでしょう。その反面、このような割付の最適化を行うと、事前の標本サイズ設計は困難になり、また調査結果は割付バイアスを持ちます。 rSurveyAssignパッケージはこの問題に対処するためのパッケージです。このパッケージは、上記の調査手続きDのような割付最適化を伴う調査に対して、3つの機能を提供します。 必要な対象者数を事前に推測する 集計値における割付バイアスを事前に評価する 集計値から割付バイアスを取り除くためのウェイトを算出する","code":""},{"path":[]},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette.html","id":"カテゴリスロット割付可能性","dir":"Articles","previous_headings":"2. このパッケージが想定している状況","what":"2.1 カテゴリ・スロット・割付可能性","title":"rSurveyAssign: tools for simulation of assignment in web surveys","text":"このパッケージは、次の状況を想定して作られています。 1つ以上の「カテゴリ」がある。 あるカテゴリは、1つ以上の「スロット」からなるリストを持つ。 すべてのカテゴリのすべてのスロットについて調査したい。 それぞれの調査対象者は、それぞれのカテゴリについて「割付可能」かそうでないかのいずれかである。 それぞれの調査対象者は、それぞれのスロットについて「割付可能」かそうでないかのいずれかである。 ある対象者を割り付けることができるカテゴリ・スロットの数には上限がある。 たとえば、次のような状況がそうです。 いくつかの製品カテゴリがある。 各製品カテゴリには、いくつかのブランドが含まれている。 すべての製品カテゴリのすべてのブランドについて、消費者が抱いているイメージを調べたい。 ある対象者にあるカテゴリについて詳しく訊くためには、その対象者はそのカテゴリの 使用者でなければならない。 ある対象者にあるブランドについて詳しく訊くためには、 その対象者はそのブランドについて知っていなければならない。 ある対象者に詳しく訊くことができるカテゴリとブランドの数には上限がある。 この例では、「カテゴリ」は製品カテゴリ、「スロット」はブランドに対応しています。 下の表を参照してください。 これは一例にすぎません。このパッケージは、「カテゴリ」「スロット」「割付可能」が 具体的に何を指すのかは問いません。また、割り付けたスロットについてなにを聴取するのかも問いません。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette.html","id":"調査手続き","dir":"Articles","previous_headings":"2. このパッケージが想定している状況","what":"2.2 調査手続き","title":"rSurveyAssign: tools for simulation of assignment in web surveys","text":"このパッケージでは、Web調査を想定し、次のように仮定します。 調査対象者の調査への参加は逐次的に行われると仮定します。すなわち、全員が同時に回答をはじめるのではなく、まちまちのタイミングで回答をはじめると仮定します。また、ある対象者のカテゴリ・スロットへの割付も逐次的に行われるものとします。 それぞれのスロットについて、そのスロットに割り付けたい対象者数が定められているとします。これを「目標対象者数」と呼びます。 調査実施中のある時点において、それまでに割り付けられた対象者数が目標対象者数に達していないスロットを「オープン」、達しているスロットを「クローズド」と形容することにします。 調査実施中のある時点において、オープンなスロットが1つ以上あるカテゴリを「オープン」、すべてのスロットがクローズドであるカテゴリを「クローズド」と形容することにします。 本パッケージは以下に説明する調査手続きを想定します。 ある人が調査に参加したとき、その人について、各カテゴリについて割付可能であるかどうかを調べる。 なんらかの方法で、その対象者のすべての割付可能カテゴリのうちいくつかを選ぶ。 これを、「対象者をカテゴリに割り付ける」と呼び、 選択されたカテゴリを「割付カテゴリ」と呼ぶ。 もし割付できなかったら、その対象者に対する調査は中止する。 対象者に、それぞれの割付カテゴリについてスロットのリストを提示し、それぞれについて割付可能かどうかを調べる。 なんらかの方法で、その対象者のいずれかの割付カテゴリの割付可能スロットのなかからいくつかを選ぶ。 これを、「対象者をスロットに割り付ける」と表現し、選択されたカテゴリを「割付スロット」と呼ぶ。 もし割付できなかったら、その対象者に対する調査は中止する。 割付スロットについての詳細な設問を提示し、回答を得る。 すべてのカテゴリがクローズドになったら、調査を終了する。 この調査手続きにおいては、Step 2.でのカテゴリの割付方法と、Step 4.でのスロットの割付方法に応じて、 必要な対象者数が大きく変わり、また割付バイアスの大きさも変わります。このパッケージでは、 さまざまな割付方法について検討することができます。このパッケージがカバーしている 割付方法について、“assign subjects”を参照して下さい。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette.html","id":"このパッケージの用途","dir":"Articles","previous_headings":"","what":"3. このパッケージの用途","title":"rSurveyAssign: tools for simulation of assignment in web surveys","text":"このパッケージは、上記の手続きによる調査を実施しようと考えている調査者、ないしすでに実施した調査者のためのパッケージです。 このパッケージの用途は次の3つです。 上記の手続きによる調査を計画しているとき、 各スロットについて必要な回答件数を得るためにはどの程度の調査対象者数が必要か、 シミュレーションによって推定する。 使用方法は“forecast sample size”を参照して下さい。 上記の手続きによる調査を計画しているとき、 調査結果が持つであろうバイアスをシミュレーションによって評価する。 使用方法は“estimate bias”を参照して下さい。 上記の手続きによる調査を行ったあとで、 集計のためのウェイトをシミュレーションによって算出する。 使用方法は“compute survey weights”を参照して下さい。 なお、このパッケージはweb調査の機能を提供するものではありません。web調査の実施時に対象者をカテゴリ・スロットへと割り付ける機能は、web調査システム上で別途実装する必要があります。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_assign.html","id":"カテゴリの割付方法","dir":"Articles","previous_headings":"","what":"1. カテゴリの割付方法","title":"How to assign subjects","text":"割付カテゴリを決める方法は、次の4つの特徴によって整理することができます。 割付タイプ 絞り込み条件 順序付け条件 除外条件 順に説明します。 以下では、対象者に割り付けるカテゴリの最大数を\\(J\\)とします。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_assign.html","id":"割付タイプ","dir":"Articles","previous_headings":"1. カテゴリの割付方法","what":"割付タイプ","title":"How to assign subjects","text":"rSurveyAssignパッケージでは、割付タイプとして次の2種類を想定します。 各対象者について以下の手順でカテゴリ割付を行います。 その人の割付可能カテゴリのなかから、指定した条件 (絞り込み条件)を満たすカテゴリを選び、割付カテゴリの候補とする。 選んだ候補のなかから、指定された優先順位(順序付け条件)に従って \\(J\\)個までのカテゴリを抜き出し、割付カテゴリとする。 割付カテゴリが所定の条件(除外条件)に該当する場合は、割付を中止する。 各対象者について以下の手順で割り付けを行います。 その対象者にとっての割付可能性は無視し、すべてのカテゴリのなかから、指定された優先順位(順序付け条件)に従って\\(J\\)個までのカテゴリを抜き出し、割付カテゴリの候補とする。 抜き出されたカテゴリのなかから、指定した条件(絞り込み条件)に該当するカテゴリを選び、割付カテゴリとする。 割付カテゴリが所定の条件(除外条件)に該当する場合は、割付を中止する。 ふたつの割付タイプは、絞り込みを先に行うか、順序付けを先に行うかという点が違います。 これは非適応的方法に比べて効率の良いやり方です。 その反面、割付バイアスが生じます。割付可能なカテゴリが多い人は、ある割付可能カテゴリに 割り付けられる確率が低くなるためです。 その結果、割付カテゴリが少なくなってしまったり、 0個になってしまったりする対象者が出現し、その分だけ多くの調査対象者数を必要とします。 その反面、割付バイアスは生じにくくなります。 ある対象者がある割付可能カテゴリに割り付けられるかどうかが、その対象者の 他のカテゴリの割付可能性とは独立に決まっているためです。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_assign.html","id":"絞り込み条件","dir":"Articles","previous_headings":"1. カテゴリの割付方法","what":"絞り込み条件","title":"How to assign subjects","text":"rSurveyAssignパッケージでは、絞り込みの条件として次の2種類を想定します。 このとき、割付カテゴリはクローズドでありうる点に注意してください。つまり、すでに目標票数に達しているカテゴリについても聴取する場合が生じます。いいかえれば、「無駄な」回答収集を行うことになります。 open: その対象者の割付可能カテゴリのうちオープンなカテゴリを選ぶ。 どちらを選んでも必要な調査対象者数は変わりませんが、対象者の回答負荷はallのほうが高く、また割付バイアスはopenのほうが強くなると考えられます。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_assign.html","id":"順序付け条件","dir":"Articles","previous_headings":"1. カテゴリの割付方法","what":"順序付け条件","title":"How to assign subjects","text":"rSurveyAssignパッケージでは、順序付けの条件として以下の4種類を想定します。 random: ランダムに並べる。 openclosed: 以下の順に並べる。(1)オープンなカテゴリ、ランダム順。 (2)クローズドなカテゴリ、ランダム順。 shortnum: その時点でオープンなスロット数が多いカテゴリから順に並べる。 shortratio: その時点でオープンなスロットが占める割合が大きいカテゴリから順に並べる。 {shortratioとshortnum}, open, randomの順に、必要な調査対象者数が少なくなり、また 割付バイアスが強くなると考えられます。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_assign.html","id":"除外条件","dir":"Articles","previous_headings":"1. カテゴリの割付方法","what":"除外条件","title":"How to assign subjects","text":"rSurveyAssignパッケージでは、除外の条件として以下の2種類を想定します。 none: なし。 allclosed: 割付カテゴリとして選ばれたカテゴリがすべてクローズドであったら、割付しない。 絞り込み条件がopenであるとき、 割付カテゴリはオープンなカテゴリなので、除外条件は意味を持ちません。 絞り込み条件がallであるとき、除外条件としてallclosedを指定すれば、 「割付カテゴリのうち少なくともどれかひとつはオープンでなければならない」と指定したことになります。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_assign.html","id":"組み合わせ","dir":"Articles","previous_headings":"1. カテゴリの割付方法","what":"組み合わせ","title":"How to assign subjects","text":"rSurveyAssignパッケージは、上で述べた4つの特徴の組み合わせによって生じる すべての割付方法をサポートしています。参考として、すべての組み合わせを下表に示します。 割り付けるカテゴリの最大数を\\(J\\)とします。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_assign.html","id":"スロットの割付方法","dir":"Articles","previous_headings":"","what":"2. スロットの割付方法","title":"How to assign subjects","text":"Step 4.で割付スロットを決める方法は、割付カテゴリを決める場合と同様です。 説明を以下のように読み替えてください。 「カテゴリ」→「スロット」 「その時点でオープンなスロット数が多いカテゴリ」→「その時点で目標票数に対して不足している票数が多いスロット」 「その時点でオープンなスロットが占める割合が多いカテゴリ」→「その時点で目標票数に対して不足している票数の割合が高いスロット」","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_assign.html","id":"割付スロット決定に際してのカテゴリの決定方法","dir":"Articles","previous_headings":"","what":"3. 割付スロット決定に際してのカテゴリの決定方法","title":"How to assign subjects","text":"Step 4.で割付スロットを決める際、もしStep 2.で複数個のカテゴリへの割付が生じていたら、 割付スロットをどの割付カテゴリから選ぶかという問題が生じます。 現バージョンのrSurveyAssignパッケージは、以下に述べる方法のみを想定しています。 割付カテゴリのなかからひとつを等確率に選び、そのカテゴリにおいて、前項で説明した方法でスロットへと割り付ける。 スロット割付ができなかったら、他の割付カテゴリのなかからひとつを等確率に選び、そのカテゴリにおいてスロットへと割り付ける。これを繰り返し、どこかのカテゴリでスロット割付ができるまで続ける。 どの割付カテゴリでもスロット割付ができなかったら、その対象者に対する調査を中止する。 ある対象者の割付スロットは、必ず同一カテゴリのスロットとなります。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_assign.html","id":"割付に伴うバイアスはいつ生じるか","dir":"Articles","previous_headings":"","what":"4. 割付に伴うバイアスはいつ生じるか","title":"How to assign subjects","text":"割付バイアスはどのような場面で生じるでしょうか。 まず、すべての対象者がすべてのカテゴリとスロットに割付可能である場合には、上記に述べたどの方法で割り付けを行っても、 割付バイアスは生じませんし、そもそもrSurveyAssignパッケージを使う理由がありません。 以下では、いずれかの対象者において割付不能なカテゴリないしスロットが存在する場合について考えます。 カテゴリについての回答において割付バイアスが生じないのは、割付方法が以下の条件をすべて満たすときに限られます。他の方法ではなんらかのバイアスが生じることになります。 カテゴリ割付において非適応的方法を選んでいるか、割付カテゴリの最大数が十分に大きく、順序付けに意味がなくなっている カテゴリ割付において除外条件をnoneにしている スロットについての回答において割付バイアスが生じないのは、割付方法が以下の条件をすべて満たすときに限られます。他の方法ではなんらかのバイアスが生じることになります。 割付カテゴリの最大数を1にしている スロット割付において非適応的方法を選んでいるか、割付スロットの最大数が十分に大きく、順序付けに意味がなくなっている スロット割付において除外条件をnoneにしている","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"割付バイアスを評価するための指標","dir":"Articles","previous_headings":"","what":"1. 割付バイアスを評価するための指標","title":"How to estimate bias","text":"まず、調査結果が持つ割付バイアスを評価する方法について説明します。 rSurveyAssignパッケージは、調査結果が持つ割付バイアスを評価するために、次の3つの指標を提供しています。 割付確率の変動係数 デザイン効果 実質標本サイズ","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"割付確率の変動係数","dir":"Articles","previous_headings":"1. 割付バイアスを評価するための指標","what":"1.1 割付確率の変動係数","title":"How to estimate bias","text":"以下では、調査で測定したい変数のことを調査変数と呼ぶことにします。 調査の目的は、各カテゴリ・スロットにおける調査変数の母集団特性(たとえば母平均)を推定することです。 バイアスとは、調査変数の母集団特性と、調査に基づくその推定値との差の期待値のことです。 あるカテゴリ・スロットについての回答における割付バイアスは、調査変数と、そのカテゴリ・スロットへの割付確率との関連 (共分散)によって決まります。たとえば、あるスロットへの回答におけるある調査変数についてみたとき、その調査変数の値が高い人ほど そのスロットへの割付確率が高いとしましょう。このとき、そのスロットについての調査変数の標本平均は、 母平均と比べて高めになってしまいます。つまり、この調査変数において割付バイアスが生じます。いっぽう、調査変数と割付確率の間に全く関連がなかったら、この調査変数においては割付バイアスが生じません。このように、割付バイアスは調査変数によって異なります。割付バイアスの実際の大きさは、個々の調査変数についてしか評価できないわけです。 しかし、もし割付確率のばらつきが0に近ければ、割付バイアスはいずれの調査変数においても小さいことになります。なぜなら、たとえある調査変数と割付確率との関連が強かったとしても、割付確率そのものが回答のあいだで等しければ、バイアスは生じないからです。 そこで、調査変数が特定されない状況では、割付確率のばらつきを割付バイアスの大きさとして捉えることができます。 そこで’rSurveyAssign’パッケージでは、割付確率の変動係数(=SD/平均)を、割付バイアスの大きさの指標のひとつとして用いています。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"デザイン効果","dir":"Articles","previous_headings":"1. 割付バイアスを評価するための指標","what":"1.2 デザイン効果","title":"How to estimate bias","text":"各対象者の各カテゴリ・スロットへの割付確率を正確に推定できているならば、割付確率の逆数をウェイトとして集計することで、集計値における割付バイアスを取り除くことができます。 その反面、一般に、ウェイトを用いて集計すると集計値の分散は拡大します。集計値の分散は標本サイズが減少したときにも拡大しまから、ウェイトを用いた集計は、割付バイアスを取り除く反面、あたかも標本サイズを減らすかような効果を持つといえます。 デザイン効果とは、バイアスの大きさを、割付確率の逆数をウェイトとして集計することによって生じる仮想的な標本サイズの減少率として表現した値です。この値は、1+(割付確率の逆数の相対分散)として求められます。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"実質標本サイズ","dir":"Articles","previous_headings":"1. 割付バイアスを評価するための指標","what":"1.3 実質標本サイズ","title":"How to estimate bias","text":"実際の標本サイズにデザイン効果を掛けた値を実質標本サイズと呼びます。たとえば、実際の標本サイズが 100で、実質標本サイズが50であるとしましょう。これは、割付に伴って生じるバイアスの大きさが、それを取り除いたら標本サイズが 50に減ってしまう程度の大きさであるということを表しています。 私たちはふつう、割付確率の変動係数やデザイン効果について直観的に解釈できませんが、 標本サイズについてはなんらかの基準を持っていることが多いでしょう。いま、 いま、割付バイアスが生じないような調査を実現できるとして、その調査における標本サイズが100以下であったら「標本サイズが小さすぎる」と感じるとしましょう。このとき、割付バイアスが生じる調査において実質標本サイズが100以下であったら「割付バイアスが大きすぎる」と考えることができます。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"データの準備","dir":"Articles","previous_headings":"","what":"2. データの準備","title":"How to estimate bias","text":"では、rSurveyAssignパッケージによるバイアス評価の手順について説明しましょう。 母集団を表現するデータを用意し、popdataクラスのオブジェクトに変換します。 “forecast sample size”を参照して下さい。 割付のセッティングを指定します。","code":"library(rSurveyAssign)  # 母集団オブジェクトの作成 data(popdata, package = \"rSurveyAssign\") mbCat <- as.matrix(popdata[, paste0(\"bCat_\", 1:3)]) lSlot <- list(     as.matrix(popdata[, paste0(\"bSlot_1_\", 1:10)]),     as.matrix(popdata[, paste0(\"bSlot_2_\", 1:10)]),      as.matrix(popdata[, paste0(\"bSlot_3_\", 1:10)])   ) lPop <- makePop(mbCAT = mbCat, lSLOT = lSlot) #> [makePop] # of categories: 3  #> [makePop] # of slots: 10,10,10  #> [makePop] # of members: 10000  #> [makePop] # of member-category pairs which are assignable: 26488 (8829.3/category)  #> [makePop] # of member-slot pairs which are assignable: 58836 (1961.2/slot) # 割付のセッティング lSetting1 <- makeSetting(   lSLOT_REQUEST = lapply(lSlot, function(mbSlot) rep(100, ncol(mbSlot))),    nCAT_MAX      = 1,    sCAT_TYPE     = 'adaptive',    sCAT_FILTER   = 'open',    sCAT_ORDER    = 'shortnum',    sCAT_EXCLUDE  = 'allclosed',   nSLOT_MAX     = 2,    sSLOT_TYPE    = 'adaptive',    sSLOT_FILTER  = 'open',    sSLOT_ORDER   = 'shortnum',    sSLOT_EXCLUDE = 'allclosed' )"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"割付再割付シミュレーション","dir":"Articles","previous_headings":"","what":"3. 割付・再割付シミュレーション","title":"How to estimate bias","text":"割付によるバイアスを評価するためのシミュレーションを行います。 このシミュレーションでは、次の試行を行います。 母集団データから対象者を抽出し、カテゴリ・スロットへの割付を行う(割付試行)。 ある割付試行で得た調査データから、仮想的な調査データを再生成し、カテゴリ・スロットへの割付をやりなおす(再割付試行)。これを繰り返して、その割付試行において、ある対象者があるカテゴリないしスロットに割り付けられる確率を推定する。 あるカテゴリないしスロットに割り付けられた対象者間での、割付確率のばらつきを調べる。 以上の割付試行を複数回繰り返す。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"試行の実行","dir":"Articles","previous_headings":"3. 割付・再割付シミュレーション","what":"3.1 1試行の実行","title":"How to estimate bias","text":"まず、割付試行を1回だけ行ってみましょう。時間を節約するため、再割付試行は10回とします。 シミュレーションの結果をみてみましょう。 simBiasの返し値は3つの要素からなるリストです。 要素dfSubjectは割付試行の結果を表しています(再割付試行ではありません)。 この割付試行では、対象者1として母集団メンバー6779が抽出され、カテゴリ1,2に割り付けられ、カテゴリ1のスロット9,6に割り付けられました。 要素dfStat_Catは、再割付試行の結果のうち、 カテゴリへの再割付の結果を表しています。 10回の再割付試行を通じて、対象者1(正確には、対象者1に相当する割付可能性を持っている人)は延べ6回抽出されました。そのうちカテゴリ1への割付が生じたのは4回でした。つまり、この割付試行における対象者1のカテゴリ1への割付確率はおよそ4/6=0.67であったと推定されます。 要素dfStat_Slotは、再割付試行の結果のうち、スロットへの再割付の結果を表しています。 10回の再割付試行を通じて、対象者1(正確には、対象者1に相当する割付可能性を持っている人)は延べ6回抽出され、そのうちカテゴリ1のスロット9への割付が生じたのは9回でした。割付確率はおよそ0/6 = 0.00であったと推定されます。実際には割付確率は0ではないので(もしそうであれば割付試行において割付が起きなかったはずです)、0に近い値、ということを意味しています。","code":"set.seed(123)  # 結果を再現するために乱数のシードを設定している。通常は設定不要 lResult1 <- simBias (   lPOP        = lPop,    lSETTING    = lSetting1,    nNUMRETRIAL = 10,   sVERBOSE    = \"simple\" ) #> [simBias] nTrial: 1 ; extract: 5843 ; 3.982 sec. head(lResult1$dfSubject) #> # A tibble: 6 × 8 #>   sRowname nPerson nCat1  nCat nSlot1 nSlot2 nTrial nSubject #>   <chr>      <int> <int> <int>  <int>  <int>  <int>    <int> #> 1 1           6779     1     1      9      6      1        1 #> 2 2           5953     2    NA     NA     NA      1        2 #> 3 3           3232     3    NA     NA     NA      1        3 #> 4 4           1226     2     2      7      5      1        4 #> 5 5           5372     1     1      7     10      1        5 #> 6 6           7652     2     2      2      1      1        6 head(lResult1$dfStat_Cat) #> # A tibble: 6 × 9 #>   nSubject  nCat nCount_SubjectCat nCount_Subject nBlock nBlockSize nTrial #>      <int> <int>             <int>          <int>  <int>      <dbl>  <int> #> 1        1     1                 4              6      1         10      1 #> 2        2     2                 3             16      1         10      1 #> 3        3     3                 2              9      1         10      1 #> 4        4     2                 5              9      1         10      1 #> 5        5     1                 8              8      1         10      1 #> 6        6     2                 2             13      1         10      1 #> # ℹ 2 more variables: sRowname <chr>, nPerson <int> head(lResult1$dfStat_Slot) #> # A tibble: 6 × 10 #>   nSubject  nCat nSlot nCount_SubjectSlot nCount_Subject nBlock nBlockSize #>      <int> <int> <int>              <int>          <int>  <int>      <dbl> #> 1        1     1     9                  0              6      1         10 #> 2        1     1     6                  0              6      1         10 #> 3        4     2     7                  5              9      1         10 #> 4        4     2     5                  1              9      1         10 #> 5        5     1     7                  3              8      1         10 #> 6        5     1    10                  2              8      1         10 #> # ℹ 3 more variables: nTrial <int>, sRowname <chr>, nPerson <int>"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"多数の試行の実行と保存","dir":"Articles","previous_headings":"3. 割付・再割付シミュレーション","what":"3.2 多数の試行の実行と保存","title":"How to estimate bias","text":"上の例では、割付試行を1回、再割付試行を10回行い、 シミュレーションの結果をデータフレームのリストとして取得しました。 バイアスを評価するためには、十分な数の再割付試行を繰り返す必要があります。 そこで今度は、割付試行を10試行、再割付試行を割付試行あたり1000試行繰り返してみましょう。 シミュレーションの結果はサイズが大きいので、SQLiteデータベース上に 保存したほうがよいでしょう。 以下の例では、SQLiteデータベースファイルとして..\\tools\\rSurveyAssign_vignette_bias_1.sqliteを 作成しています。実際には、適切なフォルダとファイル名を指定してください。また、 データベースファイルは、必要がなくなったら自分で消してください。 実行時間を短くするため、並列処理を行うことにします。引数bPARALLELにTRUEを指定します。 並列処理を行う場合、各試行についてのメッセージは画面に表示されません。 そこでログファイルを作成することにします。 実行に長い時間がかかる場合は、ログファイルを監視すると、 いま何試行まで進んでいるかわかり、少しだけ心が癒されるでしょう。 下の例では、ログファイルをC:/work/simWeight.logとしています。 RStudioを使っているなら、Terminalウィンドウでtail -F C:/work/simWeight.logを 実行すると、ログファイルを監視できます。","code":"## 都合によりコメントアウトしています # set.seed(123)  # 結果を再現するために乱数のシードを設定している。通常は設定不要 # simBias ( #   lPOP        = lPop,  #   lSETTING    = lSetting1,  #   sDBPATH     = \"..\\tools\\rSurveyAssign_vignette_bias_1.sqlite\", #   nNUMTRIAL   = 10, #   nNUMRETRIAL = 1000, #   bAPPEND     = FALSE,  #   bPARALLEL   = TRUE, #   sLOGFILE    = \"c:/work/simWeight.log\" # )"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"割付バイアスの評価","dir":"Articles","previous_headings":"","what":"4. 割付バイアスの評価","title":"How to estimate bias","text":"では、割付バイアスを評価してみましょう。関数getBiasを使います。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"カテゴリごとのバイアス","dir":"Articles","previous_headings":"4. 割付バイアスの評価","what":"4.1 カテゴリごとのバイアス","title":"How to estimate bias","text":"関数getSizeの引数sTYPEをcatとすると、 各試行での各カテゴリごとの割付バイアスを評価することができます。 getBias`の返し値はデータフレームです。内容をみてみましょう。 行は各割付試行における各カテゴリを表しています。 変数 nFreq_Catは、その割付試行におけるそのカテゴリに対する回答件数(すなわち、このカテゴリに割り付けられた延べ対象者数)を表しています。試行1ではカテゴリ1が2030回割り付けられました。 変数 gCV_Prob_Catはカテゴリへの割付確率の変動係数を表しています。0のときには割付バイアスがありません。大きいほど割付バイアスが大きいと考えられます。試行1では、カテゴリ1の割付における割付確率の変動係数が約0.42となりました。 変数gDeff_Catは、カテゴリに対する回答におけるデザイン効果を表しています。1のときには割付バイアスがありません。1より大きいほど割付バイアスが大きいと考えられます。試行1では、カテゴリ1に対する回答におけるデザイン効果が約1.06となりました。 変数gESS_Catは、カテゴリに対する回答の実質標本サイズを表しています。この値が回答件数と一致するときはバイアスがありません。それより小さいほど、バイアスが大きいと考えられます。試行1では、カテゴリ1に対する回答の実質標本サイズは約1939となりました。 10回の割付試行を通じた、割付確率の変動係数のカテゴリ別平均を求めてみましょう。 割付確率の変動係数は0.19から0.44程度です。 特にカテゴリ1への回答において、かなりの割付バイアスが生じているようです。","code":"dfResult1_c <- getBias(sTYPE = \"cat\", sDBPATH = \"../tools/rSurveyAssign_vignette_bias_1.sqlite\") head(dfResult1_c) #> # A tibble: 6 × 6 #>   nTrial  nCat nFreq_Cat gCV_Prob_Cat gDeff_Cat gESS_Cat #>    <int> <int>     <int>        <dbl>     <dbl>    <dbl> #> 1      1     1      2060        0.428      1.06    1940. #> 2      1     2      1956        0.181      1.01    1927. #> 3      1     3      1542        0.170      1.01    1529. #> 4      2     1      2042        0.455      1.07    1914. #> 5      2     2      2109        0.202      1.02    2074. #> 6      2     3      1453        0.257      1.01    1435. print(tapply(dfResult1_c$gCV_Prob_Cat, dfResult1_c$nCat, mean)) #>         1         2         3  #> 0.4419806 0.1976222 0.2136080"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"スロットごとのバイアス","dir":"Articles","previous_headings":"4. 割付バイアスの評価","what":"4.2 スロットごとのバイアス","title":"How to estimate bias","text":"関数getSizeの引数sTYPEをslotとすると、 各試行での各スロットへの回答における割付バイアスを調べることができます。 行は割付試行とスロットの組み合わせです。 変数 nFreq_Slotは、その割付試行におけるそのスロットへの回答件数(そのスロットに割り付けられた延べ対象者数)を表しています。試行1ではカテゴリ1のスロット1への割付が100回生じました。 変数 gCV_Prob_Slotはスロットへの割付確率の変動係数を表しています。0のときには割付バイアスがありません。大きいほど割付バイアスが大きいと考えられます。試行1のスロット1では、割付確率の変動係数が約0.59となりました。 変数gDeff_Slotは、スロットに対する回答におけるデザイン効果を表しています。1のときには割付バイアスがありません。1より大きいほど割付バイアスが大きいと考えられます。試行1では、カテゴリ1のスロット1に対する回答におけるデザイン効果が約7.4となりました。 変数gESS_Slotは、スロットに対する回答の実質標本サイズを表しています。この値が回答件数と一致するときは割付バイアスがありません。それより小さいほど割付バイアスが大きいと考えられます。試行1では、カテゴリ1のスロット1に対する回答の実質標本サイズは約13.6となりました。 10回の割付試行を通じた、デザイン効果のスロット別平均を求めましょう。 割付確率の変動係数は平均して0.12から0.57程度です。スロットの回答における割付バイアスもかなり大きいようです。","code":"dfResult1_s <- getBias(sTYPE = \"slot\", sDBPATH = \"../tools/rSurveyAssign_vignette_bias_1.sqlite\") head(dfResult1_s) #> # A tibble: 6 × 7 #>   nTrial  nCat nSlot nFreq_Slot gCV_Prob_Slot gDeff_Slot gESS_Slot #>    <int> <int> <int>      <int>         <dbl>      <dbl>     <dbl> #> 1      1     1     1        100         0.592       7.35      13.6 #> 2      1     1     2        100         0.510       1.67      60.0 #> 3      1     1     3        100         0.485       1.49      67.2 #> 4      1     1     4        100         0.600       3.52      28.4 #> 5      1     1     5        100         0.177       1.02      98.5 #> 6      1     1     6        100         0.516       1.90      52.6 print(tapply(dfResult1_s$gCV_Prob_Slot, list(dfResult1_s$nCat, dfResult1_s$nSlot), mean)) #>           1         2         3         4         5         6         7 #> 1 0.5538861 0.4544750 0.5604406 0.5734400 0.2237889 0.5441021 0.5629954 #> 2 0.3901738 0.5521363 0.4686567 0.1155227 0.5505147 0.2076348 0.1241414 #> 3 0.4742899 0.2250081 0.5220010 0.3618042 0.4678618 0.1772645 0.5257441 #>           8         9        10 #> 1 0.5670633 0.5228311 0.3730466 #> 2 0.4672756 0.1853742 0.1907360 #> 3 0.4621659 0.5187052 0.2557844"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"評価指標の偏り","dir":"Articles","previous_headings":"","what":"5. 評価指標の偏り","title":"How to estimate bias","text":"現バージョンのrSurveyAssignパッケージが提供する割付バイアスの評価指標 (割付確率の変動係数、デザイン効果、実質標本サイズ)は、いずれも少し悲観的な方向に偏っています。 そのことを、以下の例でみてみましょう。 割付確率の変動係数を調べてみましょう。 カテゴリ別の割付確率の変動係数は0.03から0.05程度です。 スロット別の割付確率の変動係数は0.06から0.19程度です。 本項で試した割付方法は、カテゴリについてもスロットについても非適応的かつ除外条件のない割付方法を採用し、 かつ割付カテゴリの最大数は1でした。 “rSurveyAssign: run simulations assignments web surveys”で述べたように、 この割り付け方法では割付バイアスは生じないはずです。 ところが、割付確率の変動係数は0に近い値になったものの、0にはなりませんでした。これは 割付確率の推定に誤差があるためです。誤差は再割当試行数を大きくすれば小さくなりますが、0にはなりません。 そのため、割付確率の変動係数は、真の変動係数と比べ、誤差による変動のぶんだけ大きめに偏ってしまいます。 現バージョンのrSurveyAssignパッケージは、この偏りを修正する方法を実装していません。 そのため、割付バイアスの評価指標はいずれも少し大きめになっています。 これらの指標は、あくまで相対的な指標として捉え、割付方法間の比較にのみ用いることをお勧めします。","code":"# 割付のセッティング lSetting2 <- makeSetting(   lSLOT_REQUEST = lapply(lSlot, function(mbSlot) rep(100, ncol(mbSlot))),    nCAT_MAX = 1,    sCAT_TYPE = 'nonadaptive',    sCAT_FILTER = 'open',    sCAT_ORDER  = 'shortnum',    sCAT_EXCLUDE = 'none',   nSLOT_MAX = 2,    sSLOT_TYPE = 'nonadaptive',    sSLOT_FILTER = 'open',    sSLOT_ORDER  = 'shortnum',    sSLOT_EXCLUDE = 'none' ) set.seed(123)  # 結果を再現するために乱数のシードを設定している。通常は設定不要 ## 都合によりコメントアウトしています # simBias ( #   lPOP       = lPop,  #   lSETTING   = lSetting2,  #   sDBPATH    = \"../tools/rSurveyAssign_vignette_bias_2.sqlite\", #   nNUMTRIAL  = 10, #   nNUMRETRIAL = 500, #   bAPPEND    = FALSE,  #   bPARALLEL  = TRUE, #   sLOGFILE   = \"c:/work/simWeight.log\" # ) dfResult2_c <- getBias(sTYPE = \"cat\", sDBPATH = \"../tools/rSurveyAssign_vignette_bias_2.sqlite\") print(tapply(dfResult2_c$gCV_Prob_Cat, dfResult2_c$nCat, mean)) #>          1          2          3  #> 0.04938899 0.03576083 0.05080480 dfResult2_s <- getBias(sTYPE = \"slot\", sDBPATH = \"../tools/rSurveyAssign_vignette_bias_2.sqlite\") print(tapply(dfResult2_s$gCV_Prob_Slot, list(dfResult2_s$nCat, dfResult2_s$nSlot), mean)) #>           1         2         3          4          5          6          7 #> 1 0.1727264 0.1182665 0.1448768 0.14666682 0.06971197 0.14247862 0.10226042 #> 2 0.1964570 0.1651830 0.1322604 0.06435808 0.17132514 0.11955243 0.06548126 #> 3 0.1702828 0.1189525 0.1568602 0.14258432 0.15610010 0.07176902 0.16079040 #>           8          9         10 #> 1 0.1280557 0.17413341 0.19118275 #> 2 0.1615011 0.07394842 0.08432121 #> 3 0.1604569 0.17640832 0.11252825"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"まとめ-割付バイアス評価に関連する関数","dir":"Articles","previous_headings":"","what":"6. まとめ: 割付バイアス評価に関連する関数","title":"How to estimate bias","text":"rSurveyAssignパッケージが提供する関数のうち、割付バイアスの評価に関連する関数は以下の通りです。 makePop: 母集団データを作成する makeSetting: 割付のセッティングを作成する simBias: シミュレーションを実行し結果をデータベースに格納する getBias: データベースに格納されたシミュレーション結果を集計して取り出す countBias: データベースに格納されたシミュレーション結果の試行数を調べる","code":""},{"path":[]},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_size.html","id":"母集団データ","dir":"Articles","previous_headings":"1. データの準備","what":"1.1 母集団データ","title":"How to forecast sample size","text":"まず、母集団を表現するデータを用意します。 このデータは、母集団を有限集団として近似的に表現するものです。母集団メンバーそれぞれ について、カテゴリ・スロットへの割付可能性を記述します。 rSurveyAssignは、母集団データをつくる機能は提供していません。 過去の調査結果や既存の知識に基づき、なんとかして作ってください。 以下では、母集団メンバーを\\((=1,\\ldots,)\\), カテゴリを\\(j(=1,\\ldots,J)\\), カテゴリ\\(j\\)のスロットを\\(k (=1,\\ldots,K[j])\\)と表記します。 データのサイズ(\\(, J, K[1],...,K[J]\\))に制限はありません。\\(\\) はできるだけ大きくしたほうがよいでしょう。 母集団データの例として、popdataが用意されています。 popdataは、サイズ10000の有限集団のデータを持つデータフレームで、 カテゴリ数は3, スロット数は 各カテゴリについて10です(すなわち、\\(=10000, J=3, K[1]=K[2]=K[3]=10\\))。 内容をみてみましょう。 行は母集団のメンバーを表しています。 変数bCat_()は、カテゴリ\\(\\)への割付可能性を表しています。 たとえば母集団メンバー1は、カテゴリ1,2,3に割付可能です。母集団メンバー4は、どのカテゴリにも割付不能です。 変数bSlot_()_(j)は、カテゴリ\\(\\)のスロット\\(j\\)の割付可能性を表しています。 たとえば母集団メンバー1は、カテゴリ1のスロットのうち、スロット1, 4, 8, 9, 20に対して 割付可能です。","code":"library(rSurveyAssign) data(popdata, package = \"rSurveyAssign\") head(popdata) #>   nID bCat_1 bCat_2 bCat_3 bSlot_1_1 bSlot_1_2 bSlot_1_3 bSlot_1_4 bSlot_1_5 #> 1   1      1      1      1         1         0         0         1         0 #> 2   2      1      1      1         1         1         1         1         0 #> 3   3      1      1      1         0         0         0         0         0 #> 4   4      0      0      0        NA        NA        NA        NA        NA #> 5   5      1      1      1         0         0         0         0         0 #> 6   6      1      1      1         0         0         0         0         0 #>   bSlot_1_6 bSlot_1_7 bSlot_1_8 bSlot_1_9 bSlot_1_10 bSlot_2_1 bSlot_2_2 #> 1         0         0         1         1          1         1         1 #> 2         0         0         0         1          0         1         0 #> 3         0         0         0         0          0         0         0 #> 4        NA        NA        NA        NA         NA        NA        NA #> 5         1         0         0         0          0         0         0 #> 6         0         0         0         0          0         0         0 #>   bSlot_2_3 bSlot_2_4 bSlot_2_5 bSlot_2_6 bSlot_2_7 bSlot_2_8 bSlot_2_9 #> 1         0         0         0         0         0         0         0 #> 2         1         0         1         0         0         0         0 #> 3         0         0         0         0         0         0         0 #> 4        NA        NA        NA        NA        NA        NA        NA #> 5         0         0         0         0         0         0         0 #> 6         0         0         0         0         0         0         0 #>   bSlot_2_10 bSlot_3_1 bSlot_3_2 bSlot_3_3 bSlot_3_4 bSlot_3_5 bSlot_3_6 #> 1          0         1         0         0         0         1         0 #> 2          0         0         0         0         0         0         0 #> 3          0         0         0         0         0         0         0 #> 4         NA        NA        NA        NA        NA        NA        NA #> 5          0         0         0         0         0         0         0 #> 6          0         0         0         0         0         0         0 #>   bSlot_3_7 bSlot_3_8 bSlot_3_9 bSlot_3_10 #> 1         0         0         1          0 #> 2         0         0         0          0 #> 3         0         0         0          0 #> 4        NA        NA        NA         NA #> 5         0         0         0          0 #> 6         0         0         0          0"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_size.html","id":"popdataオブジェクトの生成","dir":"Articles","previous_headings":"1. データの準備","what":"1.2 popdataオブジェクトの生成","title":"How to forecast sample size","text":"次に、母集団データをrSurveyAssignパッケージが扱える形式に変換します。 rSurveyAssignパッケージは、母集団データを表すクラスpopdataを用意しています。 popdataクラスのオブジェクトは、関数makePopで作成します。 関数makePopの引数は次の2つです。 \\(\\)行\\(J\\)列の整数行列。 \\(\\)行\\(j\\)列の値は、「母集団メンバー\\(\\)にとってカテゴリ\\(j\\)は割付可能か」 を表し、\\(0\\)は割付不能, \\(1\\)は割付不能を表します。 欠損は許容されません。 \\(J\\)個の要素からなるリスト。\\(j\\)番目の要素は、\\(\\)行\\(K[j]\\)列の整数行列。 要素\\(j\\)の行列の\\(\\)行\\(k\\)列の値は、「母集団メンバー\\(\\)にとって カテゴリ\\(j\\)のスロット\\(k\\)は割付可能か」を表し、\\(0\\)は割付不能, \\(1\\)は割付不能を表します。 mbCAT[,j] == 1のとき、lSLOT[[j]][,]}の欠損は許容されません。 すなわち、割付可能カテゴリに属するスロットの割付可能性は指定する必要があります。 mbCAT[,j] == 0のとき、lSLOT[[j]][,]は無視されます。すなわち、割付不能カテゴリに属するスロットの割付可能性は無視されます。従って欠損も許容されます。 では、データ例をpopdataクラスのオブジェクトに変換しましょう。 無事に変換できました。","code":"mbCat <- as.matrix(popdata[, paste0(\"bCat_\", 1:3)]) lSlot <- list(     as.matrix(popdata[, paste0(\"bSlot_1_\", 1:10)]),     as.matrix(popdata[, paste0(\"bSlot_2_\", 1:10)]),      as.matrix(popdata[, paste0(\"bSlot_3_\", 1:10)])   ) lPop <- makePop(mbCAT = mbCat, lSLOT = lSlot) #> [makePop] # of categories: 3  #> [makePop] # of slots: 10,10,10  #> [makePop] # of members: 10000  #> [makePop] # of member-category pairs which are assignable: 26488 (8829.3/category)  #> [makePop] # of member-slot pairs which are assignable: 58836 (1961.2/slot)"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_size.html","id":"セッティング","dir":"Articles","previous_headings":"","what":"2. セッティング","title":"How to forecast sample size","text":"次に、割付のセッティングを指定します。ここでいうセッティングとは、以下を指します。 各スロットの目標対象者数 対象者に割り付けるカテゴリ数の上限 カテゴリ割付の方法 対象者に割り付けるスロット数の上限 スロット割付の方法 rSurveyAssignパッケージは、セッティングを表すクラスassignsettingを用意しています。 assignsettingクラスのオブジェクトは、関数makeSettingで作成します。 関数makeSettingの引数は次のとおりです。 \\(J\\)個の要素を持つリスト。\\(j\\)番目の要素は長さ\\(K[j]\\)の整数ベクトル。 \\(j\\)番目の要素であるベクトルの\\(k\\)番目の要素は、カテゴリ\\(j\\)のスロット\\(k\\)に割り付ける対象者数の下限を表します。欠損は許容されません。 nCAT_MAX: 割付カテゴリの最大数。 nSLOT_MAX: 割付スロットの最大数。 sCAT_TYPE: カテゴリの割付方法(割付タイプ)。 sCAT_FILTER: カテゴリの割付方法(絞り込み条件)。 sCAT_ORDER: カテゴリの割付方法(順序付け条件)。 sCAT_EXCLUDE: カテゴリの割付方法(除外条件)。 sSLOT_TYPE: スロットの割付方法(割付タイプ)。 sSLOT_FILTER: スロットの割付方法(絞り込み条件)。 sSLOT_ORDER: スロットの割付方法(順序付け条件)。 sSLOT_EXCLUDE: スロットの割付方法(除外条件)。 カテゴリ・スロットの割付方法については “assign subjects”を参照して下さい。 では、セッティングを指定しましょう。 すべてのカテゴリのすべてのスロットに、すくなくとも10人の対象者を割り付けることにします。 回答負荷の観点から、ひとりの対象者が割り付けられるカテゴリは2つまで、スロットは2つまでとします。 カテゴリの割付方法(割付タイプ、絞り込み条件、順序付け条件、除外条件)として(adaptive,open,random,none)を使用し、スロットの割付方法として(adaptive,,shortnum,allclosed)を使用します。","code":"lSetting <- makeSetting(   lSLOT_REQUEST = lapply(lSlot, function(mbSlot) rep(10, ncol(mbSlot))),    nCAT_MAX      = 2,    nSLOT_MAX     = 2,   sCAT_TYPE     = 'adaptive',   sCAT_FILTER   = 'open',   sCAT_ORDER    = 'random',   sCAT_EXCLUDE  = 'none',   sSLOT_TYPE    = 'adaptive',   sSLOT_FILTER  = 'all',   sSLOT_ORDER   = 'shortnum',   sSLOT_EXCLUDE = 'allclosed' )"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_size.html","id":"割付シミュレーション","dir":"Articles","previous_headings":"","what":"3. 割付シミュレーション","title":"How to forecast sample size","text":"では、必要な標本サイズを推定するために、シミュレーションを行ってみましょう。 このシミュレーションでは、母集団データから対象者を復元抽出し、 それぞれの対象者に、指定した方法でカテゴリ・スロットへの割付を行います。 これを割付試行と呼びます。 割付試行を十分な回数繰り返せば、指定した方法で割付を行ったときに必要な標本サイズを 推定することができます。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_size.html","id":"試行の実行","dir":"Articles","previous_headings":"3. 割付シミュレーション","what":"3.1 1試行の実行","title":"How to forecast sample size","text":"まず、割付試行を1回行ってみます。 コンソールに表示されるメッセージは、各試行の結果を表しています。この試行では、母集団から調査対象者を573人抽出したところで、 目標対象者数が満たされ、調査が終了しました。 シミュレーションの結果をみてみましょう。 このシミュレーションでは、1人目の調査対象者として母集団メンバー6779が抽出されました。カテゴリ割付の結果、カテゴリ2,3が割り付けられました。スロット割付の結果、カテゴリ3のスロット7が割り付けられました。 このシミュレーションで、各スロットには何人の対象者が割り付けられたのでしょうか？ 調べてみましょう。 上の表は、行がカテゴリ、列がスロット、値がそのスロットに割り付けられた人数を表しています。すべてのスロットに10人以上が割り付けられていることを確認できます。","code":"set.seed(123)  # 結果を再現するために乱数のシードを設定している。通常は設定不要 dfResult <- simSize (   lPOP     = lPop,           # データを指定する   lSETTING = lSetting        # セッティングを指定する ) #> [execTrials] start trials (serial) ... #> [execTrials] nTrial: 1 ; extract: 573 ; 0.051 sec. #> [execTrials] end trials. head(dfResult) #> # A tibble: 6 × 9 #>   sRowname nPerson nCat1 nCat2  nCat nSlot1 nSlot2 nTrial nSubject #>   <chr>      <int> <int> <int> <int>  <int>  <int>  <int>    <int> #> 1 1           6779     3     2     3      7     NA      1        1 #> 2 2           5953     3     1     3      9     10      1        2 #> 3 3           3232     2     1    NA     NA     NA      1        3 #> 4 4           1226     2     1     2      7      5      1        4 #> 5 5           5372     1    NA     1      7     10      1        5 #> 6 6           7652     1     2     1      2      1      1        6 mnIn <- rbind(   as.matrix(dfResult[c(\"nCat\", \"nSlot1\")]),    as.matrix(dfResult[c(\"nCat\", \"nSlot2\")]) ) table(mnIn[,1], mnIn[,2]) #>     #>      1  2  3  4  5  6  7  8  9 10 #>   1 12 11 10 11 10 11 11 11 13 12 #>   2 13 14 13 10 12 13 10 13 10 10 #>   3 11 11 11 11 12 10 11 11 12 11"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_size.html","id":"多くの試行の実行と保存","dir":"Articles","previous_headings":"3. 割付シミュレーション","what":"3.2 多くの試行の実行と保存","title":"How to forecast sample size","text":"上の例では、割付試行を1回行い、 シミュレーションの結果をデータフレームとして取得しました。 標本サイズを推定するには、十分な数の割付試行を繰り返す必要があります。 そこで今度は、割付試行を20試行繰り返してみましょう。 シミュレーションの結果はサイズが大きいので、いったんSQLiteデータベース上に 保存したほうがよいでしょう。 以下の例では、 SQLiteデータベースファイルとして、../tools/rSurveyAssign_vignette_size_1.sqliteを 作成します。実際には、適切なフォルダとファイル名を指定してください。また、 データベースファイルは必要がなくなったら自分で消してください。 実行時間を短くするため、並列処理を行うことにします。引数bPARALLELにTRUEを指定します。 並列処理を行う場合、各試行についてのメッセージは画面に表示されません。 そこでログファイルを作成することにします。 実行に長い時間がかかる場合は、ログファイルを監視すると、 いま何試行まで進んでいるかわかり、少しだけ心が癒されるでしょう。 下の例では、ログファイルをC:/work/simSize.logとしています。 RStudioを使っているなら、Terminalウィンドウでtail -F C:/work/simSize.logを 実行すると、ログファイルを監視できます。 関数getSize_rawで、 データベースに格納された結果をそのまま取り出すことができます。 なお、これまでにデータベースに格納した試行数は、格納した際に表示されますが、 関数countSizeで調べることもできます。 この例では、試行には1秒以下しかかかりませんが、 もっと長い時間がかかることもあるでしょう。そうした場合に、 試行数nNUMTRIALを大きくすると、 simSizeの実行にとても長い時間がかかることになり、不便です。 このような場合は、nNUMTRIALはあまり時間がかからない程度の大きさにとどめ、 simSizeを気が向いたときに繰り返し実行して、結果を少しずつデータベースに 蓄積していくのが良いでしょう。 その際は、初回実行時には引数bAPPENDをFALSEとし、 二回目以降の実行時にはTRUEとしてください。また、引数lPOP, lSETTINGに与える値を途中で変えないように注意して下さい(少しでも変えるとエラーとなります)。","code":"set.seed(123)  # 結果を再現するために乱数のシードを設定している。通常は設定不要 ## 都合によりコメントアウトしています # dfResult <- simSize ( #   lPOP      =  lPop,           #   lSETTING  = lSetting,  #   nNUMTRIAL = 20, #   bPARALLEL = TRUE, #   sLOGFILE  = \"c:/work/simSize.log\", #   sDBPATH   = \"../tools/rSurveyAssign_vignette_size_1.sqlite\",  #   bAPPEND   = FALSE # すでにデータベースが存在する場合は上書きする # ) head(getSize_raw(\"../tools/rSurveyAssign_vignette_size_1.sqlite\", nTRIAL = 1)) #> # A tibble: 6 × 9 #>   sRowname nPerson nCat1 nCat2  nCat nSlot1 nSlot2 nTrial nSubject #>   <chr>      <int> <int> <int> <int>  <int>  <int>  <int>    <int> #> 1 1           8470     2     1     2      1      2      1        1 #> 2 2           9210     2     3    NA     NA     NA      1        2 #> 3 3           5801     3     1     3      2     NA      1        3 #> 4 4           6816     2     3     2      3      8      1        4 #> 5 5           4868    NA    NA    NA     NA     NA      1        5 #> 6 6            688     3     2     3      6      3      1        6 countSize(\"../tools/rSurveyAssign_vignette_size_1.sqlite\") #> [1] 20"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_size.html","id":"標本サイズの推定","dir":"Articles","previous_headings":"","what":"4. 標本サイズの推定","title":"How to forecast sample size","text":"データベースに格納されている試行結果を集計して取り出すためには、 関数getSizeを使います。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_size.html","id":"調査対象者数","dir":"Articles","previous_headings":"4. 標本サイズの推定","what":"4.1 調査対象者数","title":"How to forecast sample size","text":"関数getSizeの引数sTYPEをsubjectとすると、 各試行における調査対象者数を調べることができます。 nNum_scrは調査対象者数, nNum_mainはそのうち1つ以上のスロットに割り付けられた人数を表しています。 ここでは試行回数はまだ20件しかありませんが、試しにnNum_scrの平均を求めてみましょう。 必要な調査対象者数の平均は約520人となりました。 試行回数を十分に増やした上で、 nNum_scrを平均すると、 必要な調査対象者数の期待値を推測することができます。 また、nNum_scrのヒストグラムを描くことで、必要な調査対象者数の分布を観察できます。","code":"dfResult_s <- getSize (   sTYPE   = \"subject\",   sDBPATH = \"../tools/rSurveyAssign_vignette_size_1.sqlite\" ) print(dfResult_s) #> # A tibble: 20 × 3 #>    nTrial nNum_scr nNum_main #>     <int>    <int>     <int> #>  1      1      451       189 #>  2      2      475       191 #>  3      3      496       182 #>  4      4      399       179 #>  5      5      441       188 #>  6      6      568       186 #>  7      7      643       192 #>  8      8      451       186 #>  9      9      764       190 #> 10     10      529       187 #> 11     11      454       187 #> 12     12      546       195 #> 13     13      440       182 #> 14     14      489       191 #> 15     15      597       189 #> 16     16      531       187 #> 17     17      595       194 #> 18     18      511       193 #> 19     19      483       198 #> 20     20      542       187 print(mean(dfResult_s$nNum_scr)) #> [1] 520.25"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_size.html","id":"カテゴリスロットあたり調査対象者数","dir":"Articles","previous_headings":"4. 標本サイズの推定","what":"4.2 カテゴリ・スロットあたり調査対象者数","title":"How to forecast sample size","text":"関数getSizeの引数sTYPEをcatとすると、各カテゴリの割付人数を調べることができます。 カテゴリ1, 2, 3の割付人数は、平均してそれぞれ約383人, 409人, 308人となりました。 関数getSizeの引数sTYPEをslotとすると、各スロットの割付人数を調べることができます。 たとえば、カテゴリ1のスロット1の割付人数は、平均して約11.4人となりました。","code":"dfResult_c <- getSize (   sTYPE   = \"cat\",   sDBPATH = \"../tools/rSurveyAssign_vignette_size_1.sqlite\" ) print(tapply(dfResult_c$nNum, dfResult_c$nCat, mean)) #>      1      2      3  #> 383.10 409.20 308.95 dfResult_s <- getSize (   sTYPE   = \"slot\",   sDBPATH = \"../tools/rSurveyAssign_vignette_size_1.sqlite\" ) print(tapply(dfResult_s$nNum, list(dfResult_s$nCat, dfResult_s$nSlot), mean)) #>       1     2     3     4    5     6     7     8     9    10 #> 1 11.35 11.00 11.00 11.15 10.0 11.10 10.85 11.10 12.00 12.50 #> 2 13.65 12.65 12.35 10.35 12.8 12.05 10.60 12.60 10.60 11.05 #> 3 11.20 10.65 11.10 10.80 11.1 10.05 11.00 10.95 10.95 10.55"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_size.html","id":"分析例-割付方法の比較","dir":"Articles","previous_headings":"","what":"5. 分析例: 割付方法の比較","title":"How to forecast sample size","text":"調査に必要な対象者数がカテゴリ割付・スロット割付の方法によって どのように変わるかを、シミュレーションによって推測することができます。 たとえば、スロット割付の方法を(adaptive,,shortnum,allclosed)に変更して シミュレーションしてみます。 SQLiteデータベースファイルとして、../tools/rSurveyAssign_demo2.sqliteを 作成します。 必要な調査対象者数の平均は約1244人となりました。 スロット割付方法を(adaptive,,shortnum,allclosed)としたときの調査対象者数の平均は約520人でしたから、 こちらの割付方法のほうがはるかに多くの調査対象者を必要とすることがわかります。","code":"lSetting2 <- makeSetting(   lSLOT_REQUEST = lapply(lSlot, function(mbSlot) rep(10, ncol(mbSlot))),    nCAT_MAX      = 2,    sCAT_TYPE     = 'adaptive',   sCAT_FILTER   = 'open',   sCAT_ORDER    = 'random',   sCAT_EXCLUDE  = 'none',   nSLOT_MAX     = 2,   sSLOT_TYPE    = 'adaptive',   sSLOT_FILTER  = 'all',   sSLOT_ORDER   = 'random',   sSLOT_EXCLUDE = 'allclosed' ) set.seed(1234) # 結果を再現するために乱数のシードを設定している。通常は設定不要 simSize (   lPOP           = lPop,           lSETTING       = lSetting2,    nNUMTRIAL      = 20,                 sDBPATH        = \"../tools/rSurveyAssign_vignette_size_2.sqlite\",    bAPPEND        = FALSE ) #> [execTrials] start trials (serial) ... #> [execTrials] nTrial: 1 ; extract: 1235 ; 0.073 sec. #> [execTrials] nTrial: 2 ; extract: 1303 ; 0.055 sec. #> [execTrials] nTrial: 3 ; extract: 1201 ; 0.065 sec. #> [execTrials] nTrial: 4 ; extract: 1505 ; 0.065 sec. #> [execTrials] nTrial: 5 ; extract: 1380 ; 0.069 sec. #> [execTrials] nTrial: 6 ; extract: 1234 ; 0.059 sec. #> [execTrials] nTrial: 7 ; extract: 1177 ; 0.056 sec. #> [execTrials] nTrial: 8 ; extract: 1371 ; 0.061 sec. #> [execTrials] nTrial: 9 ; extract: 1041 ; 0.055 sec. #> [execTrials] nTrial: 10 ; extract: 1385 ; 0.068 sec. #> [execTrials] nTrial: 11 ; extract: 1081 ; 0.055 sec. #> [execTrials] nTrial: 12 ; extract: 1555 ; 0.066 sec. #> [execTrials] nTrial: 13 ; extract: 979 ; 0.05 sec. #> [execTrials] nTrial: 14 ; extract: 1495 ; 0.059 sec. #> [execTrials] nTrial: 15 ; extract: 1128 ; 0.058 sec. #> [execTrials] nTrial: 16 ; extract: 1072 ; 0.052 sec. #> [execTrials] nTrial: 17 ; extract: 1437 ; 0.061 sec. #> [execTrials] nTrial: 18 ; extract: 1157 ; 0.054 sec. #> [execTrials] nTrial: 19 ; extract: 1158 ; 0.059 sec. #> [execTrials] nTrial: 20 ; extract: 991 ; 0.053 sec. #> [execTrials] end trials. #> [simSize] # Accumlated Trials: 20 #> NULL dfResult2_s <- getSize (   sTYPE   = \"subject\",   sDBPATH = \"../tools/rSurveyAssign_vignette_size_2.sqlite\" ) print(mean(dfResult2_s$nNum_scr)) #> [1] 1244.25"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_size.html","id":"まとめ-標本サイズ推定のための関数","dir":"Articles","previous_headings":"","what":"6. まとめ: 標本サイズ推定のための関数","title":"How to forecast sample size","text":"rSurveyAssignパッケージが提供する関数のうち、標本サイズ推定に関連する関数は以下の通りです。 makePop: 母集団データを作成する makeSetting: 割付のセッティングを作成する simSize: シミュレーションを実行し結果をデータベースに格納する getSize: データベースに格納されたシミュレーション結果を集計して取り出す getSize_raw: データベースに格納されたシミュレーション結果(ローデータ)を取り出す countSize: データベースに格納されたシミュレーション結果の試行数を調べる","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_weight.html","id":"割付確率とウェイト","dir":"Articles","previous_headings":"","what":"1. 割付確率とウェイト","title":"How to compute survey weights","text":"まず、割付バイアスを取り除くためのウェイトについて説明します。 このウェイトは、調査において広く用いられている標本ウェイトと似た概念です。 標本ウェイトについての詳細は、標本調査についての参考書、たとえば土屋「概説 標本調査法」(朝倉書店)を参照してください。 たとえば、ある製品カテゴリのたくさんのブランドについて、消費者が抱いているイメージを調べたとします。 消費者から無作為抽出した調査対象者を、なんらかの割付方法によって、 その人が知っているブランドのなかから\\(J\\)個までのブランドへと割り付け、 割付ブランドについてイメージを問う設問を提示し、回答を求めました。 次の場合について考えます(説明のため、人数が非現実的に少なくなっています)。 調査対象ブランドのひとつであるブランドXについて知っている人は、調査対象者のうち10人でした。 そのうち、ブランドXに対して割り付けた対象者(つまりブランドXのイメージについて回答を求めた対象者)は 5人でした。割付方法に起因し、割付確率はその対象者の他のブランドへの割付可能性に応じて変動していました。 割付確率を下表に示します。割付確率順に並べています。 たとえば対象者1は、ブランドXへの割付確率が非常に低く(他のたくさんのブランドを知っていたのでしょう)、 実際にXに割り付けられなかった人です。対象者2は、Xへの割付確率は低かったにも関わらず、 たまたまXに割り付けられた人です。 私たちが手に入れる調査データは、下表の5人の対象者の回答です。 これらの対象者は、ブランドXを知っていた10人に比べ、割付確率が高かった人(おそらく他のブランドをあまり知らなかった人)へと 偏っています。 この割付バイアスを集計値から取り除くためにはどうしたらよいでしょうか？ その方法のひとつが、集計の際に、割付確率が低かった人に大きな重み、高かった人に小さな重みを与えることです。 たとえば対象者2は、割付確率が同程度に低かった人々の代表者であると考えます。割付確率は0.1だったので、 10人分の対象者を代表しているのだと考えることができます。そこで、対象者2の回答には重み10を付与します。 同様に、対象者10は、割付確率が同程度に高かった人々の代表者であると考えます。割付確率は0.9だったので、 1/0.9=1.11人分の対象者を代表しているのだと考えることができます。そこで、回答に重み1.11を付与します。 集計の際にはこの重みを用います。たとえば調査変数\\(x\\)について平均を求める際には、 回答者\\(\\)の回答を\\(x_i\\)として、以下とします。 \\[ \\bar{x} = \\frac{1}{10+2.5+2+1.97+1.11} (10 x_2 + 2.5 x_6 + 2 x_7 + 1.67 x_8 + 1.11 x_{10}) \\] つまり、各対象者の回答を「その対象者が何人分を代表していたか」で重みづけて合計し、重みの和(代表されている人々の人数)で 割るわけです。なお、私たちはブランドXを知っていた対象者数が10であることを知っていますから、 \\(10+2.5+2+1.97+1.11\\)ではなくて\\(10\\)で割るという考え方もできますが、いくつかの理由により、上の考え方のほうが良いことが わかっています(土屋(前掲書), p.78)。 この方法で、集計値から割付バイアスを取り除くことができます。 集計の際に用いる重み、すなわち割付確率の逆数のことをウェイトと呼びます。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_weight.html","id":"データの準備","dir":"Articles","previous_headings":"","what":"2. データの準備","title":"How to compute survey weights","text":"では、rSurveyAssignパッケージによるウェイト算出の手順について説明しましょう。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_weight.html","id":"調査データ","dir":"Articles","previous_headings":"2. データの準備","what":"2.1 調査データ","title":"How to compute survey weights","text":"まず、調査データを用意します。 調査データの例として、surveydataが用意されています。 surveydataは、本パッケージが想定している割付方法で実施された調査で得た、 架空のデータを持つデータフレームです。 この調査は、 カテゴリ数は3 スロット数は各カテゴリについて10 各対象者に対する割付カテゴリ数の上限は2 各対象者に対する割付スロット数の上限は2 目標対象者数はすべてのスロットについて10 カテゴリ割付の方法は(adaptive, open, random, none) スロット割付の方法は(adaptive, , shortnum, allclosed) でした。調査の結果、調査対象者数は504となりました。 surveydataの内容をみてみましょう。 行は調査対象者を表しています。i行目は、i番目に調査に参加した対象者を表しています。 たとえば、1番目の調査対象者は、すべてのカテゴリに割付可能でした。 5番目の調査対象者は、カテゴリ1にのみ割付可能でした。 たとえば、1番目の対象者はカテゴリ2, 3に割り付けられました。 5番目の対象者は、カテゴリ1に割り付けられました。 たとえば、5番目の調査対象者は、カテゴリ1のスロット7, 10に割付可能であることがわかっています。 このデータ例では、対象者がカテゴリ に割り付けられなかったとき、 カテゴリ に属するスロットへの割付可能性はすべてNAとなっています。 たとえば、1番目の調査対象者は、カテゴリ1に対して割付可能でしたが、 カテゴリ1への割付は生じなかったため、カテゴリ1に属するスロットへの割付可能性は NAとなっています。 たとえば、1番目の対象者ではカテゴリ3のスロットへの割付が起きました。5番目の対象者ではカテゴリ1のスロットへの割付が起きました。 たとえば、1番目の対象者はカテゴリ3のスロット7へと割り付けられました。5番目の対象者はカテゴリ1のスロット7,10へと割り付けられました。","code":"library(rSurveyAssign) data(surveydata, package = \"rSurveyAssign\") head(surveydata) #>   SEQ bCat_1 bCat_2 bCat_3 nAssignedCat_1 nAssignedCat_2 bSlot_1_1 bSlot_1_2 #> 1   1      1      1      1              3              2        NA        NA #> 2   2      1      1      1              3              1         0         0 #> 3   3      1      1      1              2              1         0         0 #> 4   4      1      1      1              2              1         0         1 #> 5   5      1      0      0              1             NA         0         0 #> 6   6      1      1      1              1              2         1         1 #>   bSlot_1_3 bSlot_1_4 bSlot_1_5 bSlot_1_6 bSlot_1_7 bSlot_1_8 bSlot_1_9 #> 1        NA        NA        NA        NA        NA        NA        NA #> 2         0         0         0         0         0         0         0 #> 3         0         0         0         0         0         0         0 #> 4         1         1         0         1         0         0         1 #> 5         0         0         0         0         1         0         0 #> 6         1         1         1         1         1         0         1 #>   bSlot_1_10 bSlot_2_1 bSlot_2_2 bSlot_2_3 bSlot_2_4 bSlot_2_5 bSlot_2_6 #> 1         NA         0         0         0         0         0         0 #> 2          0        NA        NA        NA        NA        NA        NA #> 3          0         0         0         0         0         0         0 #> 4          1         0         0         1         0         1         0 #> 5          1        NA        NA        NA        NA        NA        NA #> 6          1         1         1         1         0         1         1 #>   bSlot_2_7 bSlot_2_8 bSlot_2_9 bSlot_2_10 bSlot_3_1 bSlot_3_2 bSlot_3_3 #> 1         0         0         0          0         0         0         0 #> 2        NA        NA        NA         NA         0         0         0 #> 3         0         0         0          0        NA        NA        NA #> 4         1         1         0          0        NA        NA        NA #> 5        NA        NA        NA         NA        NA        NA        NA #> 6         0         1         1          1        NA        NA        NA #>   bSlot_3_4 bSlot_3_5 bSlot_3_6 bSlot_3_7 bSlot_3_8 bSlot_3_9 bSlot_3_10 #> 1         0         0         0         1         0         0          0 #> 2         0         0         0         0         0         1          1 #> 3        NA        NA        NA        NA        NA        NA         NA #> 4        NA        NA        NA        NA        NA        NA         NA #> 5        NA        NA        NA        NA        NA        NA         NA #> 6        NA        NA        NA        NA        NA        NA         NA #>   nAssignedCat_Slots nAssignedSlot_1 nAssignedSlot_2 #> 1                  3               7              NA #> 2                  3               9              10 #> 3                 NA              NA              NA #> 4                  2               7               5 #> 5                  1               7              10 #> 6                  1               2               1"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_weight.html","id":"surveydataオブジェクトの生成","dir":"Articles","previous_headings":"2. データの準備","what":"1.2 surveydataオブジェクトの生成","title":"How to compute survey weights","text":"調査データをrSurveyAssignパッケージが扱える形式に変換します。 rSurveyAssignパッケージは、調査データを表すクラスsurveydataを用意しています。 surveydataクラスのオブジェクトは、関数makeSurveyで作成します。 makeSurveyの引数は次の8つです。 以下では、調査対象者を\\((=1,\\ldots,)\\), カテゴリを\\(j(=1,\\ldots,J)\\), カテゴリ\\(j\\)のスロットを\\(k (=1,\\ldots,K[j])\\)、 各対象者に対する割付カテゴリ数の上限を\\(C\\)、 割付スロット数の上限を\\(S\\)とします。 \\(\\)行\\(J\\)列の整数行列。 \\(\\)行\\(j\\)列の値は、「\\(\\)番目に調査に参加した対象者にとってカテゴリ\\(j\\)は割付可能であったか」を表し、\\(0\\)は割付不能, \\(1\\)は割付不能を表します。 欠損は許容されません。 \\(J\\)個の要素からなるリスト。\\(j\\)番目の要素は、\\(\\)行\\(K[j]\\)列の整数行列。 要素\\(j\\)の行列の\\(\\)行\\(k\\)列の値は、「\\(\\)番目に調査に参加した対象者にとって カテゴリ\\(j\\)のスロット\\(k\\)は割付可能であったか」を表し、\\(0\\)は割付不能, \\(1\\)は割付不能を表します。 mbCAT[,j] == 0のとき、lSLOT[[j]][,]は無視されます (すなわち、割付不能カテゴリに属するスロットの割付可能性は無視されます)。 従って欠損も許容されます。 mbCAT[,j] == 1であり、かつmnASSIGNEDCAT[,]に\\(j\\)が含まれているとき、 lSLOT[[j]][,]に欠損は許容されません (すなわち、割り付けされたカテゴリに属するスロットへの割付可能性は すべて指定する必要があります)。 mbCAT[,j] == 1であり、かつmnASSIGNEDCAT[,]に\\(j\\)が含まれていないとき、 lSLOT[[j]][,]は無視されませんが、欠損も許容されます (すなわち、割付可能カテゴリであれば、割り付けされなかったカテゴリであっても、 そのカテゴリに属するスロットへの割付可能性は、 利用できる限り、シミュレーションに利用されます)。 欠損を含んでいる行は、その行全体が欠損であるとみなされます。 \\(J\\)個の要素からなるリスト。\\(j\\)番目の要素は、長さ\\(K[j]\\)の整数ベクトル。 \\(j\\)番目の要素であるベクトルの\\(k\\)番目の値は、カテゴリ\\(j\\)のスロット\\(k\\)に割り付ける対象者数の下限を表します。欠損は許容されません。 詳細は“assign subjects”を参照して下さい。 詳細は“assign subjects”を参照して下さい。 \\(\\)行\\(C\\)列の整数行列。 \\(\\)行目は、調査対象者\\(\\)が割り付けられた0個～C個のカテゴリの番号(mbCATの列番号)を表します。 調査対象者\\(\\)にカテゴリ割付が行われなかったときは、\\(\\)行目はすべてNAとします。割り付けられたカテゴリが\\(C\\)個未満であった場合は、それらのカテゴリ番号を格納し、残りはNAとします。 ある行のなかの値の順序に意味はありません。 長さ\\(\\)の整数行列。 \\(\\)番目の要素は、調査対象者\\(\\)が割り付けられたスロットが属するカテゴリの番号(mbCATの列番号)を表します。スロット割付が行われなかった場合はNAとします。 \\(\\)行\\(S\\)列の整数行列。 \\(\\)行目は、調査対象者\\(\\)が割り付けられたスロットの番号を表します。 ここでスロットの番号とは、agPARENTCAT[1]で指定されているカテゴリをcとして、 lSLOT[[c]]の列番号のことです。 調査対象者\\(\\)にスロット割付が行われなかったときは\\(\\)行目はすべて欠損とします。割り付けられたスロットが\\(S\\)個未満であった場合は、それらのスロット番号を格納し、残りは欠損とします。 ある行のなかの値の順序に意味はありません。 関数makeSurveyは、この8つのオブジェクトの整合性をチェックしたうえで、 リストに格納して返します。 では、データ例をsurveydataクラスのオブジェクトに変換しましょう。 無事に変換されました。","code":"lSurvey <- makeSurvey(   mbCAT <- as.matrix(surveydata[, paste0(\"bCat_\", 1:3)]),    lSLOT <- list(     as.matrix(surveydata[, paste0(\"bSlot_1_\", 1:10)]),     as.matrix(surveydata[, paste0(\"bSlot_2_\", 1:10)]),      as.matrix(surveydata[, paste0(\"bSlot_3_\", 1:10)])   ),    lSLOT_REQUEST = list(rep(10, 10), rep(10, 10), rep(10, 10)),   sCAT_TYPE     = 'adaptive',    sCAT_FILTER   = \"open\",    sCAT_ORDER    = \"random\",    sCAT_EXCLUDE  = \"none\",   sSLOT_TYPE    = \"adaptive\",    sSLOT_FILTER  = \"all\",    sSLOT_ORDER   = \"shortnum\",    sSLOT_EXCLUDE = \"allclosed\",   mnASSIGNCAT   = as.matrix(surveydata[, c(\"nAssignedCat_1\", \"nAssignedCat_2\")]),   anPARENTCAT   = as.vector(surveydata$nAssignedCat_Slots),    mnASSIGNSLOT  = as.matrix(surveydata[, c(\"nAssignedSlot_1\", \"nAssignedSlot_2\")]) ) #> [makeSurvey] # of categories: 3  #> [makeSurvey] # of slots: 10,10,10  #> [makeSurvey] # subjects: 504  #> [makeSurvey] # of pairs of subject-category: #> [makeSurvey]   total: 1512  #> [makeSurvey]   assignable: 1337 (445.7/category)  #> [makeSurvey]   assigned: 1767 (589.0/category)  #> [makeSurvey]   assignable but assignabilities to slots are unknown: 447 (149.0/category)  #> [makeSurvey]     each of these subjects will be complemented by: #> [makeSurvey]     a subject who has the same pattern of assignable categories: 447  #> [makeSurvey]     a subject who has the same number of assignable categories: 0  #> [makeSurvey]     a subject who is randomly selected: 0  #> [makeSurvey] # of pairs of subject-slot: #> [makeSurvey]   in assignable categories: 13370 (445.7/slot)  #> [makeSurvey]   known to be assignable: 1829 (61.0/slot)  #> [makeSurvey]   assigned: 346 (11.5/slot)"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_weight.html","id":"割付のチェック","dir":"Articles","previous_headings":"2. データの準備","what":"1.2 割付のチェック","title":"How to compute survey weights","text":"話を進める前に、調査データにおいてカテゴリ割付・スロット割付が 期待通りに行われていたかどうかをチェックしておきましょう。 この例では、すべての対象者について、カテゴリ割付・スロット割付が期待通りに行われていました。 期待通りに行われていない対象者がいた場合、その詳細が、checkAssignが返すデータフレームに記述されます。 実際のweb調査においても、システムのトラブルや、対象者を割り付けるタイミングが複数の対象者で重なってしまうといった理由により、必ずしもすべての割付が期待通りに行われるとは限らないと思います。従って、期待に反する割付が行われた人がある程度生じるのは仕方がないと思います。 しかし、期待に反する割付が行われた人数が多すぎるときには、以下で算出するウェイトの妥当性も疑われます。実査システムをチェックする必要があるでしょう。","code":"dfCheck <- checkSurvey(lSurvey) #> [checkSurvey] 0 errors are found."},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_weight.html","id":"再割付シミュレーション","dir":"Articles","previous_headings":"","what":"3. 再割付シミュレーション","title":"How to compute survey weights","text":"ウェイトを算出するためにシミュレーションを行ってみましょう。 rSurveyAssignパッケージでは、割付確率を推定するために、調査データから調査対象者を復元抽出することによって仮想的な調査対象者を生成し、カテゴリ・スロットへの割付をやりなおします。これを再割付試行と呼びます。 再割付試行を十分な回数繰り返し、ある対象者があるカテゴリ・スロットへと割り付けられる割合を求め、これを割付確率の推定値とします。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_weight.html","id":"少数の試行の実行","dir":"Articles","previous_headings":"3. 再割付シミュレーション","what":"3.1 少数の試行の実行","title":"How to compute survey weights","text":"まずは、シミュレーションを10試行だけ実行してみます。引数nBLOCKSIZEにブロックあたり試行数10を指定し、引数nNUMBLOCKにブロック数1を指定します。 画面に表示されたメッセージをみてみましょう。上から2行目以降のメッセージは再割付試行について表示しています。最初の再割付試行では、調査対象者を690人抽出したところで、目標対象者数が満たされ、調査が終了しました。 シミュレーションの結果をみてみましょう。 simWeightの返し値は2つの要素からなるリストです。 要素dfStat_Catは、試行を通じ、ある対象者があるカテゴリに何回割り付けられたかを示しています。 最初の行は、10回のシミュレーション試行中に、対象者1が(正確には、対象者1と全く同一の割付可能性を持つ誰かが)、延べ9回にわたり調査に参加し、そのうち4回においてカテゴリ3に割り付けられた、ということを示しています。シミュレーションを繰り返せば、対象者1がカテゴリ3に割り付けられる確率を推定することができます。 要素dfStat_Slotは、試行を通じ、ある対象者があるスロットに何回割り付けられたかを示しています。 最初の行は、10回のシミュレーション試行中に、対象者1が(正確には、対象者1と全く同一の割付可能性を持つ誰かが)、延べ9回にわたり調査参加し、そのうち1回においてカテゴリ3のスロット7に割り付けられた、ということを示しています。 シミュレーション試行を繰り返せば、対象者1がカテゴリ3のスロット7に割り付けられる確率を推定することができます。","code":"set.seed(123)  # 結果を再現するために乱数のシードを設定している。通常は設定不要 lResult <- simWeight(   lSURVEY    = lSurvey,   nBLOCKSIZE = 10,   nNUMBLOCK  = 1 ) #> [makeRetrialBlock] start replication (serial) ... #> [makeRetrialBlock] retrial: 1 ; rand: 0.2875775 ; extract: 703 ; 0.043 sec. #> [makeRetrialBlock] retrial: 2 ; rand: 0.8474248 ; extract: 465 ; 0.034 sec. #> [makeRetrialBlock] retrial: 3 ; rand: 0.4102877 ; extract: 463 ; 0.03 sec. #> [makeRetrialBlock] retrial: 4 ; rand: 0.8728468 ; extract: 541 ; 0.033 sec. #> [makeRetrialBlock] retrial: 5 ; rand: 0.7231241 ; extract: 561 ; 0.033 sec. #> [makeRetrialBlock] retrial: 6 ; rand: 0.5164188 ; extract: 563 ; 0.031 sec. #> [makeRetrialBlock] retrial: 7 ; rand: 0.2947217 ; extract: 587 ; 0.038 sec. #> [makeRetrialBlock] retrial: 8 ; rand: 0.5854465 ; extract: 540 ; 0.04 sec. #> [makeRetrialBlock] retrial: 9 ; rand: 0.6935848 ; extract: 378 ; 0.024 sec. #> [makeRetrialBlock] retrial: 10 ; rand: 0.3121077 ; extract: 525 ; 0.035 sec. #> [execRetrials] block 1 :  0.423 sec. head(lResult$dfStat_Cat) #> # A tibble: 6 × 6 #>   nSubject  nCat nCount_SubjectCat nCount_Subject nBlock nBlockSize #>      <int> <int>             <int>          <int>  <int>      <dbl> #> 1        1     3                 4              9      1         10 #> 2        1     2                 8              9      1         10 #> 3        2     3                 3              6      1         10 #> 4        2     1                 4              6      1         10 #> 5        3     2                 5              7      1         10 #> 6        3     1                 5              7      1         10 head(lResult$dfStat_Slot) #> # A tibble: 6 × 7 #>   nSubject  nCat nSlot nCount_SubjectSlot nCount_Subject nBlock nBlockSize #>      <int> <int> <int>              <int>          <int>  <int>      <dbl> #> 1        1     3     7                  1              9      1         10 #> 2        2     3     9                  1              6      1         10 #> 3        2     3    10                  1              6      1         10 #> 4        4     2     7                  9             14      1         10 #> 5        4     2     5                  6             14      1         10 #> 6        5     1     7                  2              5      1         10"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_weight.html","id":"少数の試行の実行と保存","dir":"Articles","previous_headings":"3. 再割付シミュレーション","what":"3.2 少数の試行の実行と保存","title":"How to compute survey weights","text":"上の例では、シミュレーションの結果をデータフレームとして取得しました。 しかし、シミュレーションの結果はサイズが大きいので、いったんSQLiteデータベース上に 保存したほうがよいでしょう。 以下の例では、 SQLiteデータベースファイルとして、../tools/rSurveyAssign_vignette_weight_1.sqliteを 作成します。実際には、適切なフォルダとファイル名を指定してください。また、 データベースファイルは必要がなくなったら自分で消してください。","code":"### 都合によりコメントアウトしています # set.seed(123)  # 結果を再現するために乱数のシードを設定している。通常は設定不要 # lResult <- simWeight( #   lSURVEY    = lSurvey, #   nBLOCKSIZE = 10, #   nNUMBLOCK  = 1, #   sDBPATH    = \"../tools/rSurveyAssign_vignette_weight_1.sqlite\", #   bPARALLEL  = FALSE,  #   bAPPEND    = FALSE  # すでにデータベースが存在する場合は上書きする # )"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_weight.html","id":"多くの試行の実行","dir":"Articles","previous_headings":"3. 再割付シミュレーション","what":"3.3 多くの試行の実行","title":"How to compute survey weights","text":"ウェイトを求めるためには、再割付試行を十分な回数だけ繰り返す必要があります。 今度は1000試行繰り返してみましょう。 上の例では10試行からなる1ブロックを実行してきましたが、 デフォルトでは、100試行を1ブロックと呼んでいます。 ここでは、引数nBLOCKSIZEを指定せず、 引数nNUMBLOCKにブロック数10を指定します。 実行時間を短くするため、並列処理を行うことにします。引数bPARALLELにTRUEを指定します。 並列処理を行う場合、各試行についてのメッセージは画面に表示されません。 そこでログファイルを作成することにします。 実行に長い時間がかかる場合は、ログファイルを監視すると、 いま何試行まで進んでいるかわかり、少しだけ心が癒されるでしょう。 下の例では、ログファイルをC:/work/simWeight.logとしています。 RStudioを使っているなら、Terminalウィンドウでtail -F C:/work/simWeight.logを 実行すると、ログファイルを監視できます。 データベースに1000試行の結果が格納されました。 なお、これまでにデータベースに格納した試行数は、格納した際に表示されますが、 関数countWeightで調べることもできます。 上記の実行例では、シミュレーションの結果をデータベースに上書きしましたが、 引数bAPPENDをTRUEにすることで、データベースに追加することもできます。 この例では1ブロックに数秒しかかかりませんが、 場合によってはもっと長い時間がかかることがあります。ブロック数を大きくすると、 simWeightの実行にはとても長い時間がかかってしまうことになります。 大きなブロック数を一気に実行するのではなく、 ブロック数は手頃な大きさにしておき、気が向いたときに simWeightを繰り返し実行して、 結果を少しずつデータベースに蓄積していくのが良いでしょう。 その際は、初回実行時には引数bAPPENDをFALSEとし、 二回目以降の実行時にはTRUEとしてください。 また、引数lSURVEYに与える値を途中で変えないように注意して下さい(少しでも変えるとエラーになります)。","code":"### 都合によりコメントアウトしています # set.seed(123)  # 結果を再現するために乱数のシードを設定している。通常は設定不要 # lResult <- simWeight( #   lSURVEY    = lSurvey, #   nNUMBLOCK  = 10, #   sDBPATH    = \"../tools/rSurveyAssign_vignette_weight_2.sqlite\", #   bPARALLEL  = TRUE, #   sLOGFILE   = \"c:/work/simWeight.log\", #   bAPPEND    = FALSE  # すでにデータベースが存在する場合は上書きする # ) countWeight(sTYPE = \"retrial\", sDBPATH = \"../tools/rSurveyAssign_vignette_weight_2.sqlite\") #> [1] 1000"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_weight.html","id":"ウェイトの算出","dir":"Articles","previous_headings":"","what":"4. ウェイトの算出","title":"How to compute survey weights","text":"十分な回数の再割付試行を行えば、それらの結果から、ある人があるカテゴリ・スロットに割り付けられる確率を推定し、ウェイトを求めることができます。 シミュレーション試行の結果に基づきウェイトを算出するためには、関数getWeightを使います。 getWeightの返し値は2つのデータフレームを含むリストです。 データフレーム dfWeight_Catには、ある調査対象者のある割付カテゴリに対する回答に与えるウェイトが 格納されています。 対象者1の割付カテゴリ3への回答には、ウェイト1.06が付与されています。 なお、このウェイトは、すべての調査対象者のすべての割付カテゴリを通じて 平均1に規準化されています。ヒストグラムを描いてみましょう。  割付カテゴリに対するウェイトは、それほど極端な値にはなっていないようです。 データフレーム dfWeight_Slotには、ある調査対象者のある割付スロットに対する回答に与えるウェイト が格納されています。 対象者1が割り付けられたカテゴリ3のスロット7への回答には、ウェイト0.57が 付与されています。 なお、このウェイトは、すべての調査対象者のすべての割付スロットを通じて、 平均1に規準化されています。ヒストグラムを描いてみましょう。  ごくわずかですが、極端に大きいウェイトが含まれているようです。 ウェイトが極端になったときは、まずシミュレーションの試行数が不十分である ことを疑ってください。 十分な試行数の結果に基づいて算出してもなお極端なウェイトが出現する場合は、バイアスが強すぎる割付方法を選択してしまったことが疑われます。バイアスの完全な除去を断念し、ウェイトを適切な範囲に切り詰めることを検討してください。 ウェイトを切り詰めるための関数としてtrimWeightが用意されています。デフォルトでは、 ウェイトを0.2から5の範囲に切り詰めます。","code":"lWeight <- getWeight(lSurvey, \"../tools/rSurveyAssign_vignette_weight_2.sqlite\") head(lWeight$dfWeight_Cat) #> # A tibble: 6 × 7 #>   nSubject  nCat nNumRetrial nCount_SubjectCat nCount_Subject gProb gWeight #>      <int> <int>       <dbl>             <int>          <int> <dbl>   <dbl> #> 1        1     3        1000               614           1004 0.612   1.06  #> 2        1     2        1000               646           1004 0.644   1.01  #> 3        2     3        1000               591            997 0.593   1.10  #> 4        2     1        1000               583            997 0.585   1.11  #> 5        3     2        1000               679           1024 0.663   0.979 #> 6        3     1        1000               583           1024 0.570   1.14 hist(lWeight$dfWeight_Cat$gWeight, main = NULL) head(lWeight$dfWeight_Slot) #> # A tibble: 6 × 8 #>   nSubject  nCat nSlot nNumRetrial nCount_SubjectSlot nCount_Subject gProb #>      <int> <int> <int>       <dbl>              <int>          <int> <dbl> #> 1        1     3     7        1000                225           1004 0.225 #> 2        2     3     9        1000                271            997 0.273 #> 3        2     3    10        1000                271            997 0.273 #> 4        4     2     7        1000                423           1003 0.422 #> 5        4     2     5        1000                134           1003 0.134 #> 6        5     1     7        1000                533           1011 0.528 #> # ℹ 1 more variable: gWeight <dbl> hist(lWeight$dfWeight_Slot$gWeight, main = NULL) hist(trimWeight(lWeight$dfWeight_Slot$gWeight), main = NULL)"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_weight.html","id":"まとめ-ウェイト算出に関連する関数","dir":"Articles","previous_headings":"","what":"5. まとめ: ウェイト算出に関連する関数","title":"How to compute survey weights","text":"rSurveyAssignパッケージが提供する関数のうち、ウェイト算出に関連する関数は以下の通りです。 makeSurvey: 調査データを作成する checkSurvey: 調査において行われた割付が正しかったかどうかをチェックする simWeight: シミュレーションを実行し結果をデータベースに格納する getWeight: データベースに格納されたシミュレーション結果に基づき、ウェイトを算出する countWeight: データベースに格納されたシミュレーション結果の試行数を調べる trimWeight: ウェイトを切り詰める","code":""},{"path":"https://shigono.github.io/rSurveyAssign/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Shigeru ONO. Author, maintainer.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"ONO S (2024). rSurveyAssign: tools simulation assignment web surveys. R package version 0.2.9, https://shigono.github.io/rSurveyAssign/.","code":"@Manual{,   title = {rSurveyAssign: tools for simulation of assignment in web surveys},   author = {Shigeru ONO},   year = {2024},   note = {R package version 0.2.9},   url = {https://shigono.github.io/rSurveyAssign/}, }"},{"path":"https://shigono.github.io/rSurveyAssign/index.html","id":"rsurveyassign-tools-for-simulation-of-assignment-in-web-surveys","dir":"","previous_headings":"","what":"tools for simulation of assignment in web surveys","title":"tools for simulation of assignment in web surveys","text":"package contains several tools simulate different types assignment processes web surveys. package, users can estimate sample sizes future surveys, assess bias future surveys, calculate survey weights actual surveys conducted. このパッケージは、web調査における対象者割付についてのシミュレーションを行うためのパッケージです。これから行う調査について標本サイズを見積もったり、バイアスを評価したり、すでに行った調査について調査ウェイトを求めたりすることができます。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/index.html","id":"インストール","dir":"","previous_headings":"","what":"インストール","title":"tools for simulation of assignment in web surveys","text":"GitHubからインストールできます。","code":"# install.packages(\"devtools\") devtools::install_github(\"shigono/rSurveyAssign\", build_manual = TRUE, build_vignettes = TRUE)"},{"path":"https://shigono.github.io/rSurveyAssign/index.html","id":"使い方","dir":"","previous_headings":"","what":"使い方","title":"tools for simulation of assignment in web surveys","text":"vignetteをご覧ください。 vignetteは パッケージのwebサイト でも公開されています。 メニューの”Articles”の下にあるrSurveyAssign: tools simulation assignment web surveysをご覧ください。","code":"vignette(topic = \"vignette\", package = \"rSurveyAssign\")"},{"path":"https://shigono.github.io/rSurveyAssign/reference/checkDB.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal: check database — checkDB","title":"Internal: check database — checkDB","text":"Internal: データベースファイルのチェック","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/checkDB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal: check database — checkDB","text":"","code":"checkDB(sDBPATH, asTABLE, sDIGEST = NULL)"},{"path":"https://shigono.github.io/rSurveyAssign/reference/checkDB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal: check database — checkDB","text":"sDBPATH 文字列。データベースファイルへのパス asTABLE 文字列ベクトル。データベースのテーブル名。 sDIGEST 文字列。ダイジェスト。nullの場合はチェックしない","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/checkDB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal: check database — checkDB","text":"論理値。以下の条件を満たしたときにTRUE, そうでないときにFALSEを返す。 データベースファイルsDBPATHが実在する そこにasTABLEとテーブル\"digest\"が含まれる (sDIGESTが指定された場合のみ) その列の値はsDIGESTに一致する","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/checkSurvey.html","id":null,"dir":"Reference","previous_headings":"","what":"check assigned categories and slots in survey data — checkSurvey","title":"check assigned categories and slots in survey data — checkSurvey","text":"調査データを受け取り、 カテゴリ・スロット割付が正しく行われていたことを確認する。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/checkSurvey.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"check assigned categories and slots in survey data — checkSurvey","text":"","code":"checkSurvey(lSURVEY, bVERBOSE = FALSE)"},{"path":"https://shigono.github.io/rSurveyAssign/reference/checkSurvey.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"check assigned categories and slots in survey data — checkSurvey","text":"lSURVEY object `surveydata` class.。 調査データ。makeSurveyで生成する。 bVERBOSE logical. 詳細を画面表示するか。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/checkSurvey.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"check assigned categories and slots in survey data — checkSurvey","text":"data frame.    割付結果とその検証。 以下の列を持つ。  nPerson:                   対象者番号。1からの連番 bCat_(j):                  カテゴリjへの割付可能性 bCatSlot_(j)_(k):          カテゴリjのスロットkへの割付可能性 nCount_Cat_(j):            この対象者の割付終了時点でのカテゴリjへの割付人数 nCount_CatSlot_(j)_(k):    この対象者の割付終了時点でのカテゴリj, スロットkへの割付人数 nAssignCat_(c):            この対象者のc番目の割付カテゴリ(順序に意味はない) nParentCat:                この対象者の割付スロットが属するカテゴリ nAssignSlot_(s):           この対象者のs番目の割付スロット(順序に意味はない) bValid:                    チェックを通過したか: 1:通過した, 0:通過しなかった sCheckMsg:                 チェックを通過しなかった理由。通過したときは\"\"。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/countBias.html","id":null,"dir":"Reference","previous_headings":"","what":"count trials of simulations which are done so far — countBias","title":"count trials of simulations which are done so far — countBias","text":"これまでに実行されたシミュレーション試行(割付試行)の数を数える","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/countBias.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"count trials of simulations which are done so far — countBias","text":"","code":"countBias(   sDBPATH,   sDBTABLE_SUBJECT = \"subject\",   sDBTABLE_CAT = \"weight_cat\",   sDBTABLE_SLOT = \"weight_slot\" )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/countBias.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"count trials of simulations which are done so far — countBias","text":"sDBPATH 文字列。シミュレーションの結果を保存するSQLite DBのフルパス。実在しなくてもよい。 sDBTABLE_SUBJECT 文字列。割付シミュレーションの結果を保存するSQLite DBのテーブル名。 sDBTABLE_CAT 文字列。再割付シミュレーションの結果(カテゴリ)を保存するSQLite DBのテーブル名。 sDBTABLE_SLOT 文字列。再割付シミュレーションの結果(スロット)を保存するSQLite DBのテーブル名。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/countBias.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"count trials of simulations which are done so far — countBias","text":"整数。割付試行数。指定されたsDBPATHが存在しない場合は0となる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/countBias.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"count trials of simulations which are done so far — countBias","text":"sDBPATHが存在するのにsDBTABLE_SUBJECT, sDBTABLE_CAT, sDBTABLE_SLOTが存在しない場合はエラーになる。 テーブルによって試行数が異なる場合はエラーになる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/countSize.html","id":null,"dir":"Reference","previous_headings":"","what":"count trials of simulations which are done so far — countSize","title":"count trials of simulations which are done so far — countSize","text":"これまでに実行されたシミュレーション試行の数を数える","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/countSize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"count trials of simulations which are done so far — countSize","text":"","code":"countSize(sDBPATH, sDBTABLE = \"size\")"},{"path":"https://shigono.github.io/rSurveyAssign/reference/countSize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"count trials of simulations which are done so far — countSize","text":"sDBPATH 文字列。 シミュレーションの結果を保存するSQLite DBのフルパス。 実在しなくてもよい。 sDBTABLE 文字列。 シミュレーションの結果を保存するSQLite DBのテーブル名。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/countSize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"count trials of simulations which are done so far — countSize","text":"整数。    試行数。指定されたsDBPATHが存在しない場合は0。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/countSize.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"count trials of simulations which are done so far — countSize","text":"sDBPATHが存在するのにsDBTABLEが存在しない場合はエラー。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/countWeight.html","id":null,"dir":"Reference","previous_headings":"","what":"count trials of simulations which are done so far — countWeight","title":"count trials of simulations which are done so far — countWeight","text":"これまでに実行されたシミュレーション試行の数を数える","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/countWeight.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"count trials of simulations which are done so far — countWeight","text":"","code":"countWeight(   sDBPATH,   sDBTABLE_CAT = \"weight_cat\",   sDBTABLE_SLOT = \"weight_slot\",   sTYPE = c(\"retrial\", \"block\") )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/countWeight.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"count trials of simulations which are done so far — countWeight","text":"sDBPATH 文字列。 シミュレーションの結果を保存するSQLite DBのフルパス。 実在しなくてもよい。 sDBTABLE_CAT 文字列。 シミュレーションの結果(カテゴリ)を保存するSQLite DBのテーブル名。 実在しなくてもよい。 sDBTABLE_SLOT 文字列。 シミュレーションの結果(スロット)を保存するSQLite DBのテーブル名。 実在しなくてもよい。 sTYPE 文字列。返し値の種類。以下のいずれか: \"retrial\": 再割付試行数を返す \"block\": 再割付試行のブロック数を返す","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/countWeight.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"count trials of simulations which are done so far — countWeight","text":"integer.    再割付試行数ないしブロック数。    指定されたsDBPATH, sDBTABLE_CAT, sDBTABLE_SLOTが存在しない場合は0となる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/countWeight.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"count trials of simulations which are done so far — countWeight","text":"sDBPATHが存在し、sDBTABLE_CAT, sDBTABLE_SLOTのいずれかのみが存在する場合は    エラーとなる。 sDBPATHが存在し、sDBTABLE_CATとsDBTABLE_SLOTで試行数が異なる場合はエラーになる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/execAssign.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal: Assign participants into 'categories' and 'slots' — execAssign","title":"Internal: Assign participants into 'categories' and 'slots' — execAssign","text":"Internal: 対象者をカテゴリ・スロットに割り付ける。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/execAssign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal: Assign participants into 'categories' and 'slots' — execAssign","text":"","code":"execAssign(   anSEQ_PERSON,   mnSEQ_CAT_PERSON,   mbPERSON_CAT_USE,   lPERSON_SLOT_HIT,   lSLOT_REQUEST,   nCAT_MAX,   sCAT_TYPE,   sCAT_FILTER,   sCAT_ORDER,   sCAT_EXCLUDE,   nSLOT_MAX,   sSLOT_TYPE,   sSLOT_FILTER,   sSLOT_ORDER,   sSLOT_EXCLUDE,   bCHECKCOMPLETE = TRUE,   bVERBOSE = FALSE )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/execAssign.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal: Assign participants into 'categories' and 'slots' — execAssign","text":"anSEQ_PERSON integer vector. anSEQ_PERSON[]は、i番目に調査に参加する対象者の mbPERSON_CAT_USE上の行番号。欠損不可。 mnSEQ_CAT_PERSON integer matrix. mnSEQ_CAT_PERSON[,j]は、i番目に調査に参加する 対象者の、カテゴリjのスロット割付可能性を調べる際に参照すべき、 lPERSON_SLOT_HIT[[j]]の行番号。 欠損を許すが、 mbPERSON_CAT_USE[anSEQ_PERSON[],j] == 1のとき、mnSEQ_CAT_PERSON[,j]の 欠損は不可。 mbPERSON_CAT_USE binary matrix. 対象者のカテゴリ割付可能性を表す。mbPERSON_CAT_USE[,j]は以下を表す。 1: 調査対象者iはカテゴリjについて割付可能。 0: 調査対象者iはカテゴリjについて割付不能。 欠損を許すが、mbPERSON_CAT_USE[anSEQ_PERSON, ]における欠損は不可。 lPERSON_SLOT_HIT list binary matrices. 対象者のスロット割付可能性を表す。 要素jの行列の要素(,k)は以下を表す。 1: 調査対象者iはカテゴリjのスロットkについて割付可能。 0: 調査対象者iはカテゴリjのスロットkについて割付不能。 欠損を許すが、 mbPERSON_CAT_USE[,j] == 1のとき、 lPERSON_SLOT_HIT[[j]][, ]における欠損は不可。 lSLOT_REQUEST list integer vectors. 各スロットに割り付ける対象者数の下限。 要素jのベクトルの要素kは, カテゴリjのスロットkに割り付ける対象者の下限を表す。 nCAT_MAX integer. ある対象者に割り付けるカテゴリ数の上限。 sCAT_TYPE string. カテゴリ割付タイプ。詳細はvignetteを参照。 sCAT_FILTER string. カテゴリ割付の際の絞り込み条件。詳細はvignetteを参照。 sCAT_ORDER string. カテゴリ割付の際の順序付け条件。詳細はvignetteを参照。 sCAT_EXCLUDE .string カテゴリ割付の際の除外条件。詳細はvignetteを参照。 nSLOT_MAX integer. ある対象者に割り付けるスロット数の上限。 sSLOT_TYPE string. スロット割付タイプ。指定は必須。詳細はvignetteを参照。 sSLOT_FILTER string. スロット割付の際の絞り込み条件。詳細はvignetteを参照。 sSLOT_ORDER string. スロット割付の際の順序付け条件。詳細はvignetteを参照。 sSLOT_EXCLUDE string. スロット割付の際の除外条件。指定は必須。詳細はvignetteを参照。 bCHECKCOMPLETE logical. anSEQ_PERSONを使い切っても 全スロットがクローズしなかったらエラーを発生させる bVERBOSE logical. 詳細を画面表示する","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/execAssign.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal: Assign participants into 'categories' and 'slots' — execAssign","text":"integer matrix.    行は全スロットがクローズするまでの対象者。0行かもしれないことに注意。    行名はmbPERSON_CAT_USEの該当行の行名。    列は、左から順に以下の通り。ただし、    カテゴリ番号とはmbPERSON_CAT_USEにおける列番号を指し、    スロット番号とはlPERSON_SLOT_HITの当該カテゴリにおける列番号を指す。  SEQ: 調査参加順(連番) nPerson: 対象者番号 (mbPERSON_CAT_USE上の行番号) nCat_1: 割付カテゴリ1のカテゴリ番号、ないしNA ... nCat_(nCAT_MAX): 割付カテゴリnCAT_MAXのカテゴリ番号、ないしNA nCat: 割付スロットが属するカテゴリ番号、ないしNA nSlot_1: 割付スロット1のスロット番号、ないしNA ... nSlot_(nSLOT_MAX): 割付スロットnSLOT_MAXのスロット番号、ないしNA","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/execRetrials.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal: run simulations of retrials — execRetrials","title":"Internal: run simulations of retrials — execRetrials","text":"Internal: 再割付シミュレーションを行う. simWeight(), simBias()からコールされる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/execRetrials.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal: run simulations of retrials — execRetrials","text":"","code":"execRetrials(   lSURVEY,   bREDRAW,   nBLOCKSIZE,   nNUMBLOCK,   bPARALLEL,   sLOGFILE,   sVERBOSE )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/execRetrials.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal: run simulations of retrials — execRetrials","text":"lSURVEY `surveydata`-class object. 調査データ。makeSurveyで生成する。 bREDRAW boolean. 復元抽出するか。FALSEにすると、lSURVEY上での対象者順を固定する。 nBLOCKSIZE integer. ブロック内の再割付試行数。 nNUMBLOCK integer. 実行する再割付試行のブロック数。 bPARALLEL logical. 並列処理するか。 sLOGFILE string. 並列処理する場合のログファイル(フルパス)。NULLだとログを出さない。 sVERBOSE 文字列。 画面表示レベル。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/execRetrials.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal: run simulations of retrials — execRetrials","text":"データフレームのリスト。要素は次の通り:  dfStat_Cat: カテゴリ割付頻度 dfStat_Slot: スロット割付頻度 カテゴリ割付頻度: 行は調査対象者x割付カテゴリを表す。    列は以下のとおり(順不同):  nBlock:           ブロック番号 nBlockSize:       ブロックサイズ(ブロック内の再割付試行数) nSubject:         調査対象者番号 nCat:             カテゴリ番号 nCount_Subject:    ブロック内の再割付試行で調査対象者が出現した回数 nCount_SubjectCat: ブロック内の再割付試行で調査対象者が出現しカテゴリに割り付けられた回数 スロット割付頻度: 行は調査対象者x割付スロットを表す。    列は以下のとおり(順不同):  nBlock:           ブロック番号 nBlockSize:       ブロックサイズ(ブロック内の再割付試行数) nSubject:         調査対象者番号 nCat:             スロットが属するカテゴリ番号 nSlot:            スロット番号 nCount_Subject:   ブロック内の再割付試行で調査対象者が出現した回数 nCount_SubjectSlot: ブロック内の再割付試行で調査対象者が出現しスロットに割り付けられた回数","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/execTrials.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal: run simulation of assignment — execTrials","title":"Internal: run simulation of assignment — execTrials","text":"Internal: 割付シミュレーションを行う. simSize(), simBias()からコールされる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/execTrials.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal: run simulation of assignment — execTrials","text":"","code":"execTrials(   lPOP,   lSETTING,   nNUMTRIAL,   bPARALLEL,   sLOGFILE,   sVERBOSE = c(\"simple\", \"detail\", \"none\") )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/execTrials.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal: run simulation of assignment — execTrials","text":"lPOP `popdata`クラスのオブジェクト。 母集団データ。makePopで生成する。 lSETTING `assignsetting`クラスのオブジェクト。 割付のセッティング。makeSetting で生成する。 nNUMTRIAL 整数。 割付シミュレーションの試行数。 bPARALLEL logical. 並列処理するか。 sLOGFILE string. 並列処理する場合のログファイル(フルパス)。NULLだとログを出さない。 sVERBOSE 文字列。 画面表示レベル。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/execTrials.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal: run simulation of assignment — execTrials","text":"データフレーム。    行はある試行のある調査参加者を表す。    列は以下のとおり(順不同):  nSubject:         対象者番号 (調査参加順の連番) nPerson:          母集団メンバー番号 (lPOP$mbCATの行番号) sRowname:         lPOP$mbCATの行名。lPOP$mbCATに行名がない場合はas.character(SEQ)となる nCat_1:           割付カテゴリ1のカテゴリ番号(lPOP$mbCATの列番号)、ないしNA ... nCat_(nMAXCAT):   割付カテゴリnMAXCATのカテゴリ番号(lPOP$mbCATの列番号)、ないしNA nCat:             割付スロットが属するカテゴリ番号(lPOP$mbCATの列番号)、ないしNA nSlot_1:          割付スロット1のスロット番号(lPOP$mbSLOT[[nCat]]の列番号)、ないしNA ... nSlot_(nMAXSLOT): 割付スロットnMAXSLOTのスロット番号(lPOP$mbSLOT[[nCat]]の列番号)、ないしNA","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/getBias.html","id":null,"dir":"Reference","previous_headings":"","what":"get results of simulations to estimate bias — getBias","title":"get results of simulations to estimate bias — getBias","text":"バイアス評価シミュレーションの結果を取得する","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/getBias.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"get results of simulations to estimate bias — getBias","text":"","code":"getBias(   sDBPATH,   sDBTABLE_SUBJECT = \"subject\",   sDBTABLE_CAT = \"weight_cat\",   sDBTABLE_SLOT = \"weight_slot\",   sTYPE = c(\"cat\", \"slot\") )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/getBias.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"get results of simulations to estimate bias — getBias","text":"sDBPATH 文字列。 シミュレーションの結果を保存したSQLite DBのフルパス sDBTABLE_SUBJECT 文字列。 シミュレーションの結果得られたカテゴリ割付頻度を保存したSQLite DBのテーブル名 sDBTABLE_CAT 文字列。 シミュレーションの結果得られたカテゴリ割付頻度を保存したSQLite DBのテーブル名 sDBTABLE_SLOT 文字列。 シミュレーションの結果得られたスロット割付頻度を保存したSQLite DBのテーブル名 sTYPE 文字列。 取得する結果のタイプ。 \"cat\": 試行xカテゴリ別のバイアス \"slot\": 試行xスロット別のバイアス","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/getBias.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"get results of simulations to estimate bias — getBias","text":"データフレーム。  sTYPE == \"cat\"のとき、行はある試行におけるあるカテゴリを表す。    列は以下のとおり:  nTrial: 試行番号 nCat: カテゴリ番号 nFreq_Cat: 割り付けられた対象者の数 gVarWeight_Cat: 割り付けられた対象者に与えられたウェイトの分散 gDeff_Cat: 割り付けられた対象者の回答のデザイン効果 gESS_Cat: 割り付けられた対象者の回答の実質標本サイズ  sTYPE == \"slot\"のとき、行はある試行におけるあるカテゴリを表す。    列は以下のとおり:  nTrial: 試行番号 nCat: カテゴリ番号 nSlot: スロット番号 nFreq_Slot: 割り付けられた調査対象者の数 gVarWeight_Slot: 割り付けられた対象者に与えられたウェイトの分散 gDeff_Slot: 割り付けられた対象者の回答のデザイン効果 gESS_Slot: 割り付けられた対象者の回答の実質標本サイズ","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/getCandidate.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal: get nSIZE elements from anCANDIDATE in the order of anSORTKEY.\nReturn all possible combinations if anSORTKEY has tied values. — getCandidate","title":"Internal: get nSIZE elements from anCANDIDATE in the order of anSORTKEY.\nReturn all possible combinations if anSORTKEY has tied values. — getCandidate","text":"Internal: anCANDIDATEからanSORTKEYが小さい順にnSIZE個の要素を取り出す。 anSORTKEYにタイがあるときはありうる取り出し方をすべて返す。 sub_checkcat(), sub_checkslot()からコールされる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/getCandidate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal: get nSIZE elements from anCANDIDATE in the order of anSORTKEY.\nReturn all possible combinations if anSORTKEY has tied values. — getCandidate","text":"","code":"getCandidate(anCANDIDATE, agSORTKEY, nSIZE, bDEBUG = FALSE)"},{"path":"https://shigono.github.io/rSurveyAssign/reference/getCandidate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal: get nSIZE elements from anCANDIDATE in the order of anSORTKEY.\nReturn all possible combinations if anSORTKEY has tied values. — getCandidate","text":"anCANDIDATE integer vector. 候補。長さ0以上、重複なし。欠損不可。 agSORTKEY numerical vector. ソートキー。anCANDIDATEと同じ長さ。タイが許される。欠損不可。 nSIZE integer. 取り出す要素数。0以上の整数。欠損不可 DEBUG logical. デバッグモード","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/getCandidate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal: get nSIZE elements from anCANDIDATE in the order of anSORTKEY.\nReturn all possible combinations if anSORTKEY has tied values. — getCandidate","text":"list.     要素はある取り出し方による要素ベクトル。長さはnSIZE","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/getSize.html","id":null,"dir":"Reference","previous_headings":"","what":"get results of simulations for forecasting sample size — getSize","title":"get results of simulations for forecasting sample size — getSize","text":"標本サイズ予測シミュレーションの結果を取得する","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/getSize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"get results of simulations for forecasting sample size — getSize","text":"","code":"getSize(sDBPATH, sDBTABLE = \"size\", sTYPE = c(\"subject\", \"cat\", \"slot\"))"},{"path":"https://shigono.github.io/rSurveyAssign/reference/getSize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"get results of simulations for forecasting sample size — getSize","text":"sDBPATH 文字列。 シミュレーションの結果を保存するSQLite DBのフルパス sDBTABLE 文字列。 シミュレーションの結果を保存するSQLite DBのテーブル名 sTYPE 文字列。 取得する結果のタイプ。以下のいずれか: \"subject\": 標本サイズ(調査参加者数) \"cat\": カテゴリ票数 \"slot\": スロット票数","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/getSize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"get results of simulations for forecasting sample size — getSize","text":"データフレーム。  sTYPE == \"subject\"のとき、行は試行を表す。    列は以下のとおり:  nTrial: 試行番号 nNum_scr: 調査対象者 nNum_main: 調査対象者のうち、スロット割付を受けた人数  sTYPE == \"cat\"のとき、行はある試行におけるあるカテゴリを表す。    列は以下のとおり:  nTrial: 試行番号 nCat: カテゴリ番号 nNum: そのカテゴリを割り付けられた人数  sTYPE == \"slot\"のとき、行はある試行におけるあるカテゴリを表す。    列は以下のとおり:  nTrial: 試行番号 nCat:   カテゴリ番号 nSlot:  スロット番号 nNum:   そのスロットを割り付けられた人数 いずれも、抽出が行われなかった試行については出力されない。    すべての試行で抽出が行われていない場合は0行のデータフレームとなる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/getSize_raw.html","id":null,"dir":"Reference","previous_headings":"","what":"get rawdata of simulations for forecasting sample size — getSize_raw","title":"get rawdata of simulations for forecasting sample size — getSize_raw","text":"標本サイズ予測シミュレーションのローデータを取得する","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/getSize_raw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"get rawdata of simulations for forecasting sample size — getSize_raw","text":"","code":"getSize_raw(sDBPATH, sDBTABLE = \"size\", nTRIAL = NULL)"},{"path":"https://shigono.github.io/rSurveyAssign/reference/getSize_raw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"get rawdata of simulations for forecasting sample size — getSize_raw","text":"sDBPATH 文字列。 シミュレーションの結果を保存するSQLite DBのフルパス sDBTABLE 文字列。 シミュレーションの結果を保存するSQLite DBのテーブル名 nTRIAL 整数。 試行番号。存在しないときは0行のデータを返す。 指定しないときは全試行を返す","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/getSize_raw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"get rawdata of simulations for forecasting sample size — getSize_raw","text":"データフレーム。列はsimSizeを参照。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/getWeight.html","id":null,"dir":"Reference","previous_headings":"","what":"get results of simulations for computing weights — getWeight","title":"get results of simulations for computing weights — getWeight","text":"ウェイト算出シミュレーションの結果を取得する","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/getWeight.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"get results of simulations for computing weights — getWeight","text":"","code":"getWeight(   lSURVEY,   sDBPATH,   sDBTABLE_CAT = \"weight_cat\",   sDBTABLE_SLOT = \"weight_slot\",   bCHECKDB = TRUE )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/getWeight.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"get results of simulations for computing weights — getWeight","text":"lSURVEY `surveydata`クラスのオブジェクト。 調査データ。makeSurveyで生成する。 sDBPATH 文字列。 シミュレーションの結果を保存したSQLite DBのフルパス sDBTABLE_CAT 文字列。 シミュレーションの結果得られたカテゴリ割付頻度を保存したSQLite DBのテーブル名 sDBTABLE_SLOT 文字列。 シミュレーションの結果得られたスロット割付頻度を保存したSQLite DBのテーブル名 bCHECKDB 論理値。 指定されたSQLite DBをチェックするか。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/getWeight.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"get results of simulations for computing weights — getWeight","text":"list. 要素は次の通り。  dfWeight_Cat: data frame. 行はある対象者のある割付カテゴリ dfWeight_Slot: data frame. 行はある対象者のある割付スロット","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makePop.html","id":null,"dir":"Reference","previous_headings":"","what":"make population data. — makePop","title":"make population data. — makePop","text":"母集団データを作成する。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makePop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"make population data. — makePop","text":"","code":"makePop(mbCAT, lSLOT, sVERBOSE = c(\"simple\", \"none\", \"detail\"))"},{"path":"https://shigono.github.io/rSurveyAssign/reference/makePop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"make population data. — makePop","text":"mbCAT integer matrix.    母集団メンバーのカテゴリ割付可能性を表す。 mbCAT[,j]は以下を表す。欠損不可。 1: 母集団メンバーiはカテゴリjについて割付可能。 0: 母集団メンバーiはカテゴリjについて割付不能。 lSLOT list integer matrices.    母集団メンバーのスロット割付可能性を表す。 lSLOT[[j]][,k]は以下を表す。 1: 母集団メンバーiはカテゴリjのスロットkについて割付可能。 0: 母集団メンバーiはカテゴリjのスロットkについて割付不能。 mbCAT[,j] == 0のとき、    lSLOT[[j]][, ]はすべて欠損として扱われる    (すなわち、割付不能カテゴリに属するスロットへの割付可能性は    無視される)。 mbCAT[,j] == 1のとき、    lSLOT[[j]][, ]は欠損不可    (すなわち、割付不能カテゴリに属するスロットへの割付可能性は    すべて記述する必要がある)。 sVERBOSE string. 画面表示レベル。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makePop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"make population data. — makePop","text":"object `popdata` class. その実体は以下の要素を持つリスト。 mbCAT 整数行列。                    引数mbCATとして与えられた行列。 lSLOT 整数行列のリスト。                    引数lSLOTとして与えられたリスト。                    ただし、割付不能カテゴリに属するスロットへの                    割付可能性はすべて欠損に置き換えられている。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeRetrial.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal: run execAssign() once — makeRetrial","title":"Internal: run execAssign() once — makeRetrial","text":"Internal: 再割付試行を1試行実行する。 makeRetrialBlock()からコールされる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeRetrial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal: run execAssign() once — makeRetrial","text":"","code":"makeRetrial(lSURVEY, bREDRAW, nMAXSIZE, sVERBOSE)"},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeRetrial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal: run execAssign() once — makeRetrial","text":"lSURVEY `surveydata`-class object. survey data. See document `makeSurvey` details. bREDRAW boolean. 復元抽出するか。FALSEにすると、lSURVEY上での対象者順を固定する。 nMAXSIZE integer. 復元抽出する対象者の最大数。bREDRAW=FALSEの場合は無視される sVERBOSE 文字列。画面表示レベル。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeRetrial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal: run execAssign() once — makeRetrial","text":"data frame.    列は以下のとおり(順不同):  SEQ:              調査参加順(連番) nPerson:          対象者番号 (lSURVEY$mbCAT上の行番号)                                   母集団メンバーの番号ではないことに注意 nCat_1:           割付カテゴリ1のカテゴリ番号、ないしNA ... nCat_(nMAXCAT):   割付カテゴリlSURVEY$nMAXCATのカテゴリ番号、ないしNA nCat:             割付スロットが属するカテゴリ番号、ないしNA nSlot_1:          割付スロット1のスロット番号、ないしNA ... nSlot_(nMAXSLOT): 割付スロットlSURVEY$nMAXSLOTのスロット番号、ないしNA","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeRetrialBlock.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal: run execAssign() repeatedly to compute weight — makeRetrialBlock","title":"Internal: run execAssign() repeatedly to compute weight — makeRetrialBlock","text":"Internal: 再割付試行を1ブロック実行する。execRetrials()からコールされる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeRetrialBlock.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal: run execAssign() repeatedly to compute weight — makeRetrialBlock","text":"","code":"makeRetrialBlock(   lSURVEY,   nBLOCKSIZE,   bREDRAW,   nMAXSIZE,   bPARALLEL,   sLOGFILE,   sVERBOSE )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeRetrialBlock.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal: run execAssign() repeatedly to compute weight — makeRetrialBlock","text":"lSURVEY `surveydata`-class object. survey data. See document `makeSurvey` details. nBLOCKSIZE 整数。 試行ブロック内の試行数 bREDRAW boolean. 復元抽出するか。FALSEにすると、lSURVEY上での対象者順を固定する。 nMAXSIZE integer. 復元抽出する対象者の最大数。bREDRAW=FALSEの場合は無視される bPARALLEL logical 並列処理するか sLOGFILE string. 並列処理する場合のログファイルの名前. NULLだとログを出さない sVERBOSE 文字列。画面表示レベル。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeRetrialBlock.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal: run execAssign() repeatedly to compute weight — makeRetrialBlock","text":"data frame.    列は以下のとおり(順不同):  nRetrial:         再割付試行番号 nSubject:         対象者番号 (lSURVEY$mbCAT上の行番号) SEQ:              再割付試行における調査参加順(連番) nCat_1:           割付カテゴリ1のカテゴリ番号、ないしNA ... nCat_(nMAXCAT):   割付カテゴリlSURVEY$nMAXCATのカテゴリ番号、ないしNA nCat:             割付スロットが属するカテゴリ番号、ないしNA nSlot_1:          割付スロット1のスロット番号、ないしNA ... nSlot_(nMAXSLOT): 割付スロットlSURVEY$nMAXSLOTのスロット番号、ないしNA","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeSetting.html","id":null,"dir":"Reference","previous_headings":"","what":"make setting. — makeSetting","title":"make setting. — makeSetting","text":"割付のセッティングを作成する。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeSetting.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"make setting. — makeSetting","text":"","code":"makeSetting(   lSLOT_REQUEST,   nCAT_MAX,   nSLOT_MAX,   sCAT_TYPE = c(\"adaptive\", \"nonadaptive\"),   sCAT_FILTER = c(\"all\", \"open\"),   sCAT_ORDER = c(\"random\", \"openclosed\", \"shortnum\", \"shortratio\"),   sCAT_EXCLUDE = c(\"none\", \"allclosed\"),   sSLOT_TYPE = c(\"adaptive\", \"nonadaptive\"),   sSLOT_FILTER = c(\"all\", \"open\"),   sSLOT_ORDER = c(\"random\", \"openclosed\", \"shortnum\", \"shortratio\"),   sSLOT_EXCLUDE = c(\"none\", \"allclosed\"),   nSUBJECT_MAX = 0 )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeSetting.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"make setting. — makeSetting","text":"lSLOT_REQUEST list integer vectors. 各スロットに割り付ける対象者数の目標。 要素jのベクトルの要素kは, カテゴリjのスロットkに割り付ける対象者の下限を表す。 欠損なし。 nCAT_MAX integer. ある対象者に割り付けるカテゴリ数の上限。 nSLOT_MAX integer. ある対象者に割り付けるスロット数の上限。 sCAT_TYPE string. カテゴリ割付タイプ。詳細はvignetteを参照。 sCAT_FILTER string. カテゴリ割付の際の絞り込み条件。詳細はvignetteを参照。 sCAT_ORDER string. カテゴリ割付の際の順序付け条件。詳細はvignetteを参照。 sCAT_EXCLUDE string. カテゴリ割付の際の除外条件。詳細はvignetteを参照。 sSLOT_TYPE string. スロット割付タイプ。詳細はvignetteを参照。 sSLOT_FILTER string. スロット割付の際の絞り込み条件。詳細はvignetteを参照。 sSLOT_ORDER string. スロット割付の際の順序付け条件。詳細はvignetteを参照。 sSLOT_EXCLUDE string. スロット割付の際の除外条件。指定は必須。詳細はvignetteを参照。 nSUBJECT_MAX integer.    抽出する対象者数の上限。0以上の整数。 0より大きい値が指定された場合、    対象者抽出は、    対象者数がnSUBJECT_MAXに達するか、すべてのスロットの割付対象者数が    lSLOT_REQUESTに設定された目標に達したときに終了する。 0が指定された場合、    対象者抽出は、すべてのスロットの割付対象者数が目標に達したときにのみ正常終了する。    対象者数が母集団サイズの10倍を超えても    割付対象者数が目標に到達しなかったときはエラーとなる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeSetting.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"make setting. — makeSetting","text":"object `assignsetting` class.         その実体は、この関数の引数を要素として持つリスト。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeStat_Cat.html","id":null,"dir":"Reference","previous_headings":"","what":"Interal: make statistics for categories — makeStat_Cat","title":"Interal: make statistics for categories — makeStat_Cat","text":"Internal: カテゴリ割付頻度を集計する。execRetrials()からコールされる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeStat_Cat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interal: make statistics for categories — makeStat_Cat","text":"","code":"makeStat_Cat(dfReplicateBlock, lSURVEY, bVERBOSE)"},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeStat_Cat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interal: make statistics for categories — makeStat_Cat","text":"dfReplicateBlock data frame 対象者のカテゴリ・ウェイトへの割付を反復実行した結果。 以下の列を持つと期待される nSubject:          対象者番号 nCat_1:           割付カテゴリ1のカテゴリ番号、ないしNA ... nCat_(nMAXCAT):   割付カテゴリnMAXCATのカテゴリ番号、ないしNA nCat:             割付スロットが属するカテゴリ番号、ないしNA nSlot_1:          割付スロット1のスロット番号、ないしNA ... nSlot_(nMAXSLOT): 割付スロットnMAXSLOTのスロット番号、ないしNA lSURVEY `surveydata`-class object. survey data. See document `makeSurvey` details. bVERBOSE logical. 詳細を画面表示する","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeStat_Cat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interal: make statistics for categories — makeStat_Cat","text":"data frame    行は対象者x割付カテゴリ  nSubject          対象者番号 nCat             親カテゴリ番号 nCount_SubjectCat その人にそのカテゴリが割り付けられた回数 nCount_Subject    その人の出現回数","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeStat_Slot.html","id":null,"dir":"Reference","previous_headings":"","what":"Interal: make statistics for slots — makeStat_Slot","title":"Interal: make statistics for slots — makeStat_Slot","text":"Internal: スロット割付頻度を集計する。execRetrials()からコールされる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeStat_Slot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interal: make statistics for slots — makeStat_Slot","text":"","code":"makeStat_Slot(dfReplicateBlock, lSURVEY, bVERBOSE)"},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeStat_Slot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interal: make statistics for slots — makeStat_Slot","text":"dfReplicateBlock data frame 対象者のカテゴリ・ウェイトへの割付を反復実行した結果。 以下の列を持つと期待される nSubject:          対象者番号 nCat_1:           割付カテゴリ1のカテゴリ番号、ないしNA ... nCat_(nMAXCAT):   割付カテゴリnMAXCATのカテゴリ番号、ないしNA nCat:             割付スロットが属するカテゴリ番号、ないしNA nSlot_1:          割付スロット1のスロット番号、ないしNA ... nSlot_(nMAXSLOT): 割付スロットnMAXSLOTのスロット番号、ないしNA lSURVEY `surveydata`-class object. survey data. See document `makeSurvey` details. bVERBOSE logical. 詳細を画面表示する","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeStat_Slot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interal: make statistics for slots — makeStat_Slot","text":"data frame    行は対象者x割付スロット    列は以下の通り  nSubject           対象者番号 nCat              親カテゴリ番号 nSlot             スロット番号 nCount_SubjectSlot その人にそのスロットが割り付けられた回数 nCount_Subject     その人の出現回数","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeSurvey.html","id":null,"dir":"Reference","previous_headings":"","what":"make survey data. — makeSurvey","title":"make survey data. — makeSurvey","text":"調査データを作成する.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeSurvey.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"make survey data. — makeSurvey","text":"","code":"makeSurvey(   mbCAT,   lSLOT,   lSLOT_REQUEST,   mnASSIGNCAT,   anPARENTCAT,   mnASSIGNSLOT,   sCAT_TYPE = c(\"adaptive\", \"nonadaptive\"),   sCAT_FILTER = c(\"all\", \"open\"),   sCAT_ORDER = c(\"random\", \"openclosed\", \"shortnum\", \"shortratio\"),   sCAT_EXCLUDE = c(\"none\", \"allclosed\"),   sSLOT_TYPE = c(\"adaptive\", \"nonadaptive\"),   sSLOT_FILTER = c(\"all\", \"open\"),   sSLOT_ORDER = c(\"random\", \"openclosed\", \"shortnum\", \"shortratio\"),   sSLOT_EXCLUDE = c(\"none\", \"allclosed\"),   nSUBJECT_MAX = NULL,   sVERBOSE = c(\"simple\", \"none\", \"detail\") )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeSurvey.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"make survey data. — makeSurvey","text":"mbCAT 整数行列。 調査対象者のカテゴリ割付可能性。 mbCAT[,j]は以下を表す。欠損不可。 1: 調査対象者iはカテゴリjについて割付可能。 0: 調査対象者iはカテゴリjについて割付不能。 lSLOT 整数行列のリスト。 調査対象者のスロット割付可能性。 lSLOT[[j]][,k]は以下を表す。 1: 調査対象者iはカテゴリjのスロットkについて割付可能。 0: 調査対象者iはカテゴリjのスロットkについて割付不能。 欠損についてはDetailsを参照。 lSLOT_REQUEST 整数ベクトルのリスト。 各スロットに割り付ける対象者数の下限。 要素jのベクトルの要素kは, カテゴリjのスロットkに割り付ける対象者の下限を表す。 欠損なし。 mnASSIGNCAT 整数行列。 調査対象者の割付カテゴリ。列数は、割付カテゴリ数の上限。 mnASSIGNCAT[,j]は、調査対象者iのj番目の割付カテゴリ番号(mbCATの列番号)を表す。 調査対象者iの割付カテゴリ数が列数より小さい場合はNAを埋める。 列順には意味がない。 anPARENTCAT 整数ベクトル。 調査対象者の割付スロットが属するカテゴリ。 anPARENTCAT[]は、調査対象者iの割付スロットが属するカテゴリ番号(mbCATの列番号)を表す。 調査対象者iがスロットに割り付けられなかった場合はNAを埋める。 mnASSIGNSLOT 整数行列。 調査対象者の割付スロット。列数は、割付スロット数の上限。 mnASSIGNSLOT[,j]は、調査対象者iの割付スロット番号(lSLOT[[anPARENTCAT[]]]の列番号)を 表す。調査対象者iの割付スロット数が列数より小さい場合はNAを埋める。 列順には意味がない。 sCAT_TYPE 文字列。 カテゴリ割付タイプ。指定は必須。詳細はvignetteを参照。 sCAT_FILTER 文字列。 カテゴリ割付の際の絞り込み条件。指定は必須。詳細はvignetteを参照。 sCAT_ORDER 文字列。 カテゴリ割付の際の順序付け条件。指定は必須。詳細はvignetteを参照。 sCAT_EXCLUDE 文字列。 カテゴリ割付の際の除外条件。指定は必須。詳細はvignetteを参照。 sSLOT_TYPE 文字列。 スロット割付タイプ。指定は必須。詳細はvignetteを参照。 sSLOT_FILTER 文字列。 スロット割付の際の絞り込み条件。指定は必須。詳細はvignetteを参照。 sSLOT_ORDER 文字列。 スロット割付の際の順序付け条件。指定は必須。詳細はvignetteを参照。 sSLOT_EXCLUDE 文字列。 スロット割付の際の除外条件。指定は必須。詳細はvignetteを参照。 nSUBJECT_MAX 整数。    抽出する対象者数の上限。 nSUBJECT_MAXが指定された場合、    対象者抽出は、    対象者数がnSUBJECT_MAXに達するか、すべてのスロットの割付対象者数が    lSLOT_REQUESTに設定された目標に達したときに終了する。 nSUBJECT_MAXがNULLの場合、    対象者抽出は、すべてのスロットの割付対象者数が目標に達したときにのみ正常終了する。    対象者数が母集団サイズの10倍を超えても    割付対象者数が目標に到達しなかったときはエラーとなる。 sVERBOSE 文字列。 画面表示レベル。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeSurvey.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"make survey data. — makeSurvey","text":"`surveydata`クラスのオブジェクト。その実体は以下の要素を持つリスト。 mbCAT 整数行列。引数mbCATの値。 lSLOT 整数行列のリスト。引数lSLOTの値。ただし、割付不能カテゴリの スロット割付可能性はすべてNAに変更される。また、要素の行にひとつでもNAがあったら その行はみなNAに変更される。 lSLOT_REQUEST 整数ベクトルのリスト。引数lSLOT_REQUESTの値。 sCAT_TYPE     文字列。引数sCAT_TYPEの値。 sCAT_FILTER   文字列。引数sCAT_FILTERの値。 sCAT_ORDER    文字列。引数sCAT_ORDERの値。 sCAT_EXCLUDE  文字列。引数sCAT_EXCLUDEの値。 sSLOT_TYPE    文字列。引数sSLOT_TYPEの値。 sSLOT_FILTER  文字列。引数sSLOT_FILTERの値。 sSLOT_ORDER   文字列。引数sSLOT_ORDERの値。 sSLOT_EXCLUDE 文字列。引数sSLOT_EXCLUDEの値。 mnASSIGNCAT   整数行列。引数mnASSIGNCATの値。 anPARENTCAT   整数ベクトル。引数anPARENTCATの値。 mnASSIGNSLOT  整数行列。引数mnASSIGNSLOTの値。 nSUBJECT_MAX  整数。引数nSUBJECT_MAXの値。 manSubjectCat_AltSubject 整数ベクトルを要素とする行列。行は対象者(mbCATの行), 列はカテゴリ(mbCATの列), 要素はその対象者のスロット割付可能性を調べるときに 参照すべき対象者番号のベクトル。 mnSubjectCat_AltStatus 整数ベクトルの行列。行は対象者(mbCATの行), 列はカテゴリ(mbCATの列), 要素は以下のいずれか: NA: 割付不能カテゴリ 0: スロット割付可能性が既知 1: スロット割付可能性が未知であるためカテゴリ割付可能性が同じ対象者で代替 2: スロット割付可能性が未知であるため割付カテゴリ数が同じ対象者で代替 3: スロット割付可能性が未知であるためランダムに選んだ対象者で代替","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeSurvey.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"make survey data. — makeSurvey","text":"lSLOTの欠損は以下のように扱われる。 Case 1. mbCAT[,j] == 0のとき、   lSLOT[[j]][, ]は無視される。すなわち、   ある対象者があるカテゴリに対して割付不能な時、   その対象者のそのカテゴリに属するスロットへの割付可能性は未知として扱われ、   指定しても無視される。 Case 2. mbCAT[,j] == 1でありj がmnASSIGNCAT[,]に含まれているとき、   lSLOT[[j]][, ]の欠損は許されない。すなわち、   ある対象者があるカテゴリに割り付けられた場合、   その対象者のそのカテゴリに属するスロットへの割付可能性は既知であるはずなので、   指定しなければならない。 Case 3. mbCAT[,j] == 1でありj がmnASSIGNCAT[,]に含まれていないとき、   lSLOT[[j]][, ]の欠損はある程度まで許容される。すなわち、   ある対象者があるカテゴリに割付可能であったが割り付けられなかった場合、   その対象者のそのカテゴリに属するスロットへの割付可能性は、分かっている限りにおいて   指定すればよい。ある行に欠損がある場合、その行はすべて欠損とみなされる。 Case 3.に相当する調査対象者も、   再割付シミュレーションにおいてカテゴリ j に割り付けられる可能性がある。   そのため、jに属するスロットへの割付可能性が欠損である調査対象者については、   それらの欠損を補完する必要が生じる。このとき、   SurveyAssignパッケージによるシミュレーションでは、   調査対象者 の割付可能性を   他の調査対象者 ' の割付可能性によって置き換える。   ' はシミュレーション試行ごとに、次の手順で選ばれる。 Step 1. jに属するスロットへの割付可能性が既知であり、   かつJ個のカテゴリへの割付可能性が と同一である人の中からランダムに選ぶ。 Step 2. みつからなかった場合は、jに属するスロットへの割付可能性が既知であり、   かつ割付可能なカテゴリの数が同一である人の中からランダムに選ぶ。 Step 3. みつからなかった場合は、jに属するスロットへの割付可能性が既知である   人の中からランダムに選ぶ。 makeSurveyは、今後のシミュレーションの際に   上記の手順での補完が可能かどうかをチェックし、Step 1で補完できない人が   出現した場合には警告を表示する。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/popdata.html","id":null,"dir":"Reference","previous_headings":"","what":"population data — popdata","title":"population data — popdata","text":"vignetteでの説明に用いる母集団データ。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/popdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"population data — popdata","text":"","code":"data(popdata)"},{"path":"https://shigono.github.io/rSurveyAssign/reference/popdata.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"population data — popdata","text":"object class data.frame 10000 rows 34 columns.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/popdata.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"population data — popdata","text":"母集団をサイズ10000の有限集団として近似的に表現している。 カテゴリ数3, 各カテゴリは10スロットを持つ。 以下の列を持つ。 nID 母集団メンバーID nCat_1 カテゴリ1の割付可能性(0:割付不能, 1:割付可能) nCat_2 カテゴリ2の割付可能性(0:割付不能, 1:割付可能) nCat_3 カテゴリ3の割付可能性(0:割付不能, 1:割付可能) bSlot_1_1 カテゴリ1, スロット1の割付可能性(0:割付不能, 1:割付可能, NA:カテゴリ1は割付不能) bSlot_1_2 カテゴリ1, スロット2の割付可能性(0:割付不能, 1:割付可能, NA:カテゴリ1は割付不能) ... bSlot_3_10 カテゴリ3, スロット10の割付可能性(0:割付不能, 1:割付可能, NA:カテゴリ3は割付不能)","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/rSurveyAssign-package.html","id":null,"dir":"Reference","previous_headings":"","what":"rSurveyAssign: run simulation of assignment in a web survey — rSurveyAssign-package","title":"rSurveyAssign: run simulation of assignment in a web survey — rSurveyAssign-package","text":"run simulation assignment web survey","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/rSurveyAssign-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"rSurveyAssign: run simulation of assignment in a web survey — rSurveyAssign-package","text":"package contains several tools simulate different types assignment processes web surveys. package, users can estimate sample sizes future surveys, assess bias future surveys, calculate survey weights actual surveys conducted. このパッケージは、web調査における対象者割付についてのシミュレーションを 行うためのパッケージです。これから行う調査について標本サイズを見積もったり、 バイアスを評価したり、すでに行った調査について調査ウェイトを求めたりすることができます。","code":""},{"path":[]},{"path":"https://shigono.github.io/rSurveyAssign/reference/simBias.html","id":null,"dir":"Reference","previous_headings":"","what":"run simulations to evaluate bias — simBias","title":"run simulations to evaluate bias — simBias","text":"バイアス評価のためのシミュレーションを実行する","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/simBias.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"run simulations to evaluate bias — simBias","text":"","code":"simBias(   lPOP,   lSETTING,   nNUMTRIAL = 1,   nNUMRETRIAL = 1000,   bUSE_INFO_UNASSIGNED_CAT = TRUE,   bPARALLEL = FALSE,   sLOGFILE = NULL,   sDBPATH = NULL,   sDBTABLE_SUBJECT = \"subject\",   sDBTABLE_CAT = \"weight_cat\",   sDBTABLE_SLOT = \"weight_slot\",   bAPPEND = TRUE,   sVERBOSE = c(\"simple\", \"detail\", \"none\") )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/simBias.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"run simulations to evaluate bias — simBias","text":"lPOP `popdata`クラスのオブジェクト。 母集団データ。makePopで生成する。 lSETTING `assignsetting'クラスのオブジェクト。 割付のセッティング。makeSettingで生成する。 nNUMTRIAL 整数。 割付試行数。 nNUMRETRIAL 整数。 各割付試行における再割付試行数。 bUSE_INFO_UNASSIGNED_CAT 論理値。 再割付試行において、非割付カテゴリに属するスロットへの割付可能性を利用するか。 TRUEの場合、すべての割付可能カテゴリに属するスロット割付可能性を用いて 再割付試行を行う。 FALSEの場合、割付カテゴリに属するスロット割付可能性のみを用いて 再割付試行を行う。 bPARALLEL 論理値。 並列処理するか。 sLOGFILE 文字列。 並列処理する場合のログファイル(フルパス)。NULLだとログを出さない。 sDBPATH 文字列。 シミュレーションの結果を保存するSQLite DBのフルパス。 sDBTABLE_SUBJECT 文字列。 割付シミュレーションの結果を保存するSQLite DBのテーブル名。 sDBTABLE_CAT 文字列。 再割付シミュレーションの結果得られたカテゴリ割付頻度を保存するSQLite DBのテーブル名。 sDBTABLE_SLOT 文字列。 再割付シミュレーションの結果得られたスロット割付頻度を保存するSQLite DBのテーブル名。 bAPPEND 論理値。 TRUE: 結果をテーブルに追加する。FALSE: 上書きする。 sVERBOSE 文字列。 画面表示レベル。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/simBias.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"run simulations to evaluate bias — simBias","text":"sDBPATHを指定しない場合は、シミュレーションの結果をデータフレームのリストとして返す。 sDBPATHを指定した場合はNULLを返す。シミュレーションの結果は、            SQLiteデータベースにテーブルとして保存される。sDBPATH が存在する場合は、            bAPPEND==FALSEであればSDBPATHに上書きし、bAPPEND==TRUEであれば追加する。            sDBPATHが存在しない場合は新規作成する。 シミュレーションの結果は次の3つのデータフレームからなる。  dfSubject:            行はある試行のある調査参加者を表す。            列はexecTrial()の出力に試行番号 nTrialを追加したもの。 dfStat_Cat: 行はある試行のあるカテゴリを表す。            列はexecRetrial()の出力のうちdfStat_Catに試行番号 nTrialを追加したもの。 dfStat_Slot: 行はある試行のあるカテゴリのあるスロットを表す。            列はexecRetrial()の出力のうちdfStat_Slotに試行番号 nTrialを追加したもの。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/simBias.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"run simulations to evaluate bias — simBias","text":"bAPPEND==TRUEで、sDBPATHが存在し、かつ    テーブルsDBTABLE_SUBJECT, sDBTABLE_CAT, sDBTABLE_SLOTが存在しない場合はエラーとなる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/simSize.html","id":null,"dir":"Reference","previous_headings":"","what":"run simulations for forecasting sample size — simSize","title":"run simulations for forecasting sample size — simSize","text":"標本サイズ推定のためのシミュレーションを行う","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/simSize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"run simulations for forecasting sample size — simSize","text":"","code":"simSize(   lPOP,   lSETTING,   nNUMTRIAL = 1,   bPARALLEL = FALSE,   sLOGFILE = NULL,   sDBPATH = NULL,   sDBTABLE = \"size\",   bAPPEND = TRUE,   sVERBOSE = c(\"simple\", \"detail\", \"none\") )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/simSize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"run simulations for forecasting sample size — simSize","text":"lPOP `popdata`クラスのオブジェクト。 母集団データ。makePopで生成する。 lSETTING `assignsetting`クラスのオブジェクト。 割付のセッティング。makeSetting で生成する。 nNUMTRIAL 整数。 割付シミュレーションの試行数。 bPARALLEL 論理値。 並列処理するか。 sLOGFILE 文字列。 並列処理する場合のログファイル(フルパス)。NULLだとログを出さない。 sDBPATH 文字列。 シミュレーションの結果を保存するSQLite DBのフルパス。 sDBTABLE 文字列。 シミュレーションの結果を保存するSQLite DBのテーブル名。 bAPPEND 論理値。 TRUE: 結果をテーブルに追加する。FALSE: 上書きする。 sVERBOSE 文字列。 画面表示レベル。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/simSize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"run simulations for forecasting sample size — simSize","text":"sDBPATHを指定しなかった場合は、シミュレーションの結果を    データフレームとして返す。 sDBPATHを指定した場合はNULLを返す。    シミュレーションの結果は、SQLiteデータベースにテーブルとして    保存される。 bAPPEND==FALSEの場合、SQLiteデータベースファイル sDBPATH    が存在する場合は上書きし、存在しない場合は新規作成する。 bAPPEND==TRUEの場合、SQLiteデータベースファイル sDBPATH    が存在する場合にはテーブルsDBTABLEに追加する。    ファイルが存在しない場合はファイルとテーブルを新規作成する。 シミュレーションの結果は以下の形式を持つ。    行はある試行のある調査参加者を表す。0行かもしれないことに注意。    列は以下のとおり(順不同):  nSubject:         対象者番号 (調査参加順の連番) nPerson:          母集団メンバー番号 (lPOP$mbCATの行番号) sRowname:         lPOP$mbCATの行名。lPOP$mbCATに行名がない場合はas.character(SEQ)となる nCat_1:           割付カテゴリ1のカテゴリ番号(lPOP$mbCATの列番号)、ないしNA ... nCat_(nMAXCAT):   割付カテゴリnMAXCATのカテゴリ番号(lPOP$mbCATの列番号)、ないしNA nCat:             割付スロットが属するカテゴリ番号(lPOP$mbCATの列番号)、ないしNA nSlot_1:          割付スロット1のスロット番号(lPOP$mbSLOT[[nCat]]の列番号)、ないしNA ... nSlot_(nMAXSLOT): 割付スロットnMAXSLOTのスロット番号(lPOP$mbSLOT[[nCat]]の列番号)、ないしNA","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/simSize.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"run simulations for forecasting sample size — simSize","text":"bAPPEND==TRUEで、sDBPATHが存在するがテーブルsDBTABLEが存在しない場合は エラーとなる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/simWeight.html","id":null,"dir":"Reference","previous_headings":"","what":"run simulations for computing weights — simWeight","title":"run simulations for computing weights — simWeight","text":"ウェイト算出のためのシミュレーションを実行する","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/simWeight.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"run simulations for computing weights — simWeight","text":"","code":"simWeight(   lSURVEY,   bREDRAW = TRUE,   nBLOCKSIZE = 100,   nNUMBLOCK = 1,   bPARALLEL = FALSE,   sLOGFILE = NULL,   sDBPATH = NULL,   sDBTABLE_CAT = \"weight_cat\",   sDBTABLE_SLOT = \"weight_slot\",   bAPPEND = FALSE,   sVERBOSE = c(\"simple\", \"detail\", \"none\") )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/simWeight.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"run simulations for computing weights — simWeight","text":"lSURVEY `surveydata`クラスのオブジェクト。 調査データ。makeSurveyで生成する。 bREDRAW 論理値。 FALSEにすると、再割付試行においてlSURVEYの対象者順を固定する。 nBLOCKSIZE 整数。 ブロック内の再割付試行数。 nNUMBLOCK 整数。 実行する再割付試行のブロック数。 bPARALLEL 論理値。 並列処理するか。 sLOGFILE 文字列。 並列処理する場合のログファイル(フルパス)。NULLだとログを出さない。 sDBPATH 文字列。 シミュレーションの結果を保存するSQLite DBのフルパス。 存在しない場合は作成する。 sDBTABLE_CAT 文字列。 再割付シミュレーションの結果得られたカテゴリ割付頻度を保存するSQLite DBのテーブル名。 sDBTABLE_SLOT 文字列。 再割付シミュレーションの結果得られたスロット割付頻度を保存するSQLite DBのテーブル名。 bAPPEND 論理値。 結果をテーブルにTRUE: 追加する, FALSE: 上書きする。 sVERBOSE 文字列。 画面表示レベル。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/simWeight.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"run simulations for computing weights — simWeight","text":"sDBPATHを指定しない場合は、シミュレーションの結果を    データフレームのリストとして返す。要素は次の通り:  dfStat_Cat: カテゴリ割付頻度 dfStat_Slot: スロット割付頻度 sDBPATHを指定した場合はNULLを返す。    シミュレーションの結果は、SQLiteデータベースにテーブルsDBTABLE_CAT,    sDBTABLE_SLOTとして保存される。 bAPPEND==FALSEの場合、SQLiteデータベースファイル sDBPATH    が存在する場合は上書きし、存在しない場合は新規作成する。 bAPPEND==TRUEの場合、SQLiteデータベースファイル sDBPATH に    テーブルsDBTABLE_CAT, sDBTABLE_SLOT が存在する場合には    それらのテーブルに追加し、    ファイルが存在しない場合はファイルとテーブルを新規作成する。 シミュレーションの結果は以下の形式を持つ。 カテゴリ割付頻度: 行は調査対象者x割付カテゴリを表す。    列は以下のとおり(順不同):  nBlock:           ブロック番号 nBlockSize:       ブロックサイズ(ブロック内の再割付試行数) nSubject:         調査対象者番号 nCat:             カテゴリ番号 nCount_Subject:    ブロック内の再割付試行で調査対象者が出現した回数 nCount_SubjectCat: ブロック内の再割付試行で調査対象者が出現しカテゴリに割り付けられた回数 スロット割付頻度: 行は調査対象者x割付スロットを表す。    列は以下のとおり(順不同):  nBlock:           ブロック番号 nBlockSize:       ブロックサイズ(ブロック内の再割付試行数) nSubject:         調査対象者番号 nCat:             スロットが属するカテゴリ番号 nSlot:            スロット番号 nCount_Subject:   ブロック内の再割付試行で調査対象者が出現した回数 nCount_SubjectSlot: ブロック内の再割付試行で調査対象者が出現しスロットに割り付けられた回数","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/simWeight.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"run simulations for computing weights — simWeight","text":"bAPPEND==TRUEで、sDBPATHが存在するがテーブルsDBTABLE_CAT,    sDBTABLE_SLOTが存在しない場合はエラーとなる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_checkcat.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal: Check assigned categories — sub_checkcat","title":"Internal: Check assigned categories — sub_checkcat","text":"Internal. ある対象者について、ありうる割付カテゴリの組み合わせを           すべて返す。           checkSurvey()からコールされる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_checkcat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal: Check assigned categories — sub_checkcat","text":"","code":"sub_checkcat(   abCatNo_Use,   abCatNo_Open,   anCatNo_OpenCount,   anCatNo_AllCount,   nCAT_MAX,   sCAT_TYPE,   sCAT_FILTER,   sCAT_ORDER,   sCAT_EXCLUDE,   bDEBUG )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_checkcat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal: Check assigned categories — sub_checkcat","text":"abCatNo_Use binary vector. カテゴリの番号から割付可能かどうかを引くベクトル。 abCatNo_Open binary vector. カテゴリの番号からオープンかどうかを引くベクトル。 anCatNo_OpenCount integer vector. カテゴリの番号からオープンスロット数を引くベクトル。 anCatNo_AllCount integer vector. カテゴリの番号からスロット数を引くベクトル。 nCAT_MAX 整数。 ある対象者に割り付けるカテゴリ数の上限。 sCAT_TYPE 文字列。 カテゴリ割付タイプ。 sCAT_FILTER 文字列。 カテゴリ割付の際の絞り込み条件。 sCAT_ORDER 文字列。 カテゴリ割付の際の順序付け条件。 sCAT_EXCLUDE 文字列。 カテゴリ割付の際の除外条件。 DEBUG logical. デバッグモード","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_checkcat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal: Check assigned categories — sub_checkcat","text":"list integer vectors.    要素は割付カテゴリのある組み合わせ。ソート済み。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_checkslot.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal: Check assigned slots — sub_checkslot","title":"Internal: Check assigned slots — sub_checkslot","text":"Internal. ある対象者のあるカテゴリについて、           ありうる割付スロットの組み合わせをすべて返す。           checkSurvey()からコールされる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_checkslot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal: Check assigned slots — sub_checkslot","text":"","code":"sub_checkslot(   abSlotNo_Hit,   abSlotNo_Open,   anSlotNo_Count,   anSlotNo_Request,   nSLOT_MAX,   sSLOT_TYPE,   sSLOT_FILTER,   sSLOT_ORDER,   sSLOT_EXCLUDE,   bDEBUG )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_checkslot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal: Check assigned slots — sub_checkslot","text":"abSlotNo_Hit binary vector. スロット番号から割付可能かどうかを引くベクトル abSlotNo_Open binary vector. スロット番号からオープンかどうかを引くベクトル anSlotNo_Count integer vector. スロット番号から獲得票数を引くベクトル anSlotNo_Request integer vector. スロット番号から目標票数を引くベクトル nSLOT_MAX 整数。 ある対象者に割り付けるスロット数の上限。 sSLOT_TYPE 文字列。 スロット割付タイプ。指定は必須。詳細はvignetteを参照。 sSLOT_FILTER 文字列。 スロット割付の際の絞り込み条件。指定は必須。詳細はvignetteを参照。 sSLOT_ORDER 文字列。 スロット割付の際の順序付け条件。指定は必須。詳細はvignetteを参照。 sSLOT_EXCLUDE 文字列。 スロット割付の際の除外条件。指定は必須。詳細はvignetteを参照。 DEBUG logical. デバッグモード","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_checkslot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal: Check assigned slots — sub_checkslot","text":"list integer vectors.    要素は割付スロットの組み合わせ。ソート済み。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_getcat.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal: Assign a participant into categories — sub_getcat","title":"Internal: Assign a participant into categories — sub_getcat","text":"Internal. ある対象者について、割付カテゴリを決定する。          execAssign()からコールされる","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_getcat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal: Assign a participant into categories — sub_getcat","text":"","code":"sub_getcat(   abCatNo_Use,   abCatNo_Open,   anCatNo_OpenCount,   anCatNo_AllCount,   nCAT_MAX,   sCAT_TYPE,   sCAT_FILTER,   sCAT_ORDER,   sCAT_EXCLUDE,   bDEBUG )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_getcat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal: Assign a participant into categories — sub_getcat","text":"abCatNo_Use binary vector. カテゴリの番号から割付可能かどうかを引くベクトル。 abCatNo_Open binary vector. カテゴリの番号からオープンかどうかを引くベクトル。 anCatNo_OpenCount integer vector. カテゴリの番号からオープンスロット数を引くベクトル。 anCatNo_AllCount integer vector. カテゴリの番号からスロット数を引くベクトル。 nCAT_MAX 整数。 ある対象者に割り付けるカテゴリ数の上限。 sCAT_TYPE 文字列。 カテゴリ割付タイプ。 sCAT_FILTER 文字列。 カテゴリ割付の際の絞り込み条件。 sCAT_ORDER 文字列。 カテゴリ割付の際の順序付け条件。 sCAT_EXCLUDE 文字列。 カテゴリ割付の際の除外条件。 DEBUG logical. デバッグモード","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_getcat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal: Assign a participant into categories — sub_getcat","text":"integer vector.    割付カテゴリの番号。長さはnCAT_MAX, 足りない分はNAを詰める","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_getslot.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal: Assign a participant into slots — sub_getslot","title":"Internal: Assign a participant into slots — sub_getslot","text":"Internal. ある対象者について、あるカテゴリの割付スロットを決定する。           execAssign()からコールされる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_getslot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal: Assign a participant into slots — sub_getslot","text":"","code":"sub_getslot(   abSlotNo_Hit,   abSlotNo_Open,   anSlotNo_Count,   anSlotNo_Request,   nSLOT_MAX,   sSLOT_TYPE,   sSLOT_FILTER,   sSLOT_ORDER,   sSLOT_EXCLUDE,   bDEBUG )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_getslot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal: Assign a participant into slots — sub_getslot","text":"abSlotNo_Hit binary vector. スロット番号から割付可能かどうかを引くベクトル abSlotNo_Open binary vector. スロット番号からオープンかどうかを引くベクトル anSlotNo_Count integer vector. スロット番号から獲得票数を引くベクトル anSlotNo_Request integer vector. スロット番号から目標票数を引くベクトル nSLOT_MAX 整数。 ある対象者に割り付けるスロット数の上限。 sSLOT_TYPE 文字列。 スロット割付タイプ。指定は必須。詳細はvignetteを参照。 sSLOT_FILTER 文字列。 スロット割付の際の絞り込み条件。指定は必須。詳細はvignetteを参照。 sSLOT_ORDER 文字列。 スロット割付の際の順序付け条件。指定は必須。詳細はvignetteを参照。 sSLOT_EXCLUDE 文字列。 スロット割付の際の除外条件。指定は必須。詳細はvignetteを参照。 DEBUG logical. デバッグモード","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_getslot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal: Assign a participant into slots — sub_getslot","text":"integer vector.    割付スロットの番号。長さはnSLOT_MAX, 足りない分はNAを詰める","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_makeSubjectCat_Alt.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal: make a table to extract a set of alternative persons from person and category — sub_makeSubjectCat_Alt","title":"Internal: make a table to extract a set of alternative persons from person and category — sub_makeSubjectCat_Alt","text":"Internal: 対象者番号とカテゴリから, 代替する対象者番号群を引く表を作る","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_makeSubjectCat_Alt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal: make a table to extract a set of alternative persons from person and category — sub_makeSubjectCat_Alt","text":"","code":"sub_makeSubjectCat_Alt(mbCAT, lSLOT)"},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_makeSubjectCat_Alt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal: make a table to extract a set of alternative persons from person and category — sub_makeSubjectCat_Alt","text":"mbCAT 整数行列。 調査対象者のカテゴリ割付可能性。 mbCAT[,j]は以下を表す。欠損不可。 1: 調査対象者iはカテゴリjについて割付可能。 0: 調査対象者iはカテゴリjについて割付不能。 lSLOT 整数行列のリスト。 調査対象者のスロット割付可能性。 lSLOT[[j]][,k]は以下を表す。 1: 調査対象者iはカテゴリjのスロットkについて割付可能。 0: 調査対象者iはカテゴリjのスロットkについて割付不能。 欠損についてはDetailsを参照。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_makeSubjectCat_Alt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal: make a table to extract a set of alternative persons from person and category — sub_makeSubjectCat_Alt","text":"リスト。以下の要素を持つ。 manSubjectCat_AltSet       整数ベクトルの行列。行は対象者(mbCATの行),       列はカテゴリ(mbCATの列), 要素はその対象者のスロット割付可能性を調べるときに       参照すべき対象者番号のベクトル。mbCAT[,j] == 1のときは長さ1以上のベクトル、       mbCAT[,j] == 0のときはNULL. mnSubjectCat_AltStatus       整数ベクトルの行列。行は対象者(mbCATの行),       列はカテゴリ(mbCATの列), 要素は以下のいずれか: NA: 割付不能カテゴリ 0: スロット割付可能性が既知 1: スロット割付可能性が未知であるためカテゴリ割付可能性が同じ対象者で代替 2: スロット割付可能性が未知であるため割付カテゴリ数が同じ対象者で代替 3: スロット割付可能性が未知であるためランダムに選んだ対象者で代替","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_makeSurvey_from_trial.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal: make virtual survey data based on the returned value from execTrials() — sub_makeSurvey_from_trial","title":"Internal: make virtual survey data based on the returned value from execTrials() — sub_makeSurvey_from_trial","text":"Internal: 割付シミュレーションの結果に基づいて仮想的な調査データをつくる。           simBias()からコールされる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_makeSurvey_from_trial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal: make virtual survey data based on the returned value from execTrials() — sub_makeSurvey_from_trial","text":"","code":"sub_makeSurvey_from_trial(   lPOP,   lSETTING,   dfSubject,   bUSE_INFO_UNASSIGNED_CAT,   sVERBOSE = c(\"simple\", \"detail\", \"none\") )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_makeSurvey_from_trial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal: make virtual survey data based on the returned value from execTrials() — sub_makeSurvey_from_trial","text":"lPOP `popdata`クラスのオブジェクト。 母集団データ。makePopで生成する。 lSETTING `assignsetting`クラスのオブジェクト。 割付のセッティング。makeSetting で生成する。 dfSubject データフレーム。 execTrials()の返し値。 sVERBOSE 文字列。 画面表示レベル。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_makeSurvey_from_trial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal: make virtual survey data based on the returned value from execTrials() — sub_makeSurvey_from_trial","text":"makeSurvey()の返し値。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/surveydata.html","id":null,"dir":"Reference","previous_headings":"","what":"survey data — surveydata","title":"survey data — surveydata","text":"vignetteでの説明に用いる調査データ。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/surveydata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"survey data — surveydata","text":"","code":"data(surveydata)"},{"path":"https://shigono.github.io/rSurveyAssign/reference/surveydata.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"survey data — surveydata","text":"object class data.frame 504 rows 39 columns.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/surveydata.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"survey data — surveydata","text":"架空の調査データ。カテゴリ数3, 各カテゴリのスロット数は10。 割付カテゴリ数の上限は2, 割付カテゴリ数の上限は2, 目標対象者数はすべてのスロットについて10。カテゴリ割付の方法は、 (adaptive、open, random, none), スロット割付の方法は(adaptive, , shortnum, allclosed)であった。 調査の結果、調査対象者数は504となった。 以下の列を持つ。 SEQ 調査参加順序 nCat_1 カテゴリ1の割付可能性(0:割付不能, 1:割付可能) nCat_2 カテゴリ2の割付可能性(0:割付不能, 1:割付可能) nCat_3 カテゴリ3の割付可能性(0:割付不能, 1:割付可能) bSlot_1_1 カテゴリ1, スロット1の割付可能性(0:割付不能, 1:割付可能, NA:不明) bSlot_1_2 カテゴリ1, スロット2の割付可能性(0:割付不能, 1:割付可能, NA:不明) ... bSlot_3_10 カテゴリ3, スロット10の割付可能性(0:割付不能, 1:割付可能, NA:不明) nAssignedCat_1, nAssignCat_2: この対象者に割り付けられたカテゴリの番号。 割り付けられたカテゴリが0～1個の場合はNAが格納される。 ある対象者におけるnAssignedCat_1の値とnAssignedCat_2の値の順序に意味はない。 nAssignedCat_Slots: 割り付けられたスロットが属するカテゴリ番号。 スロット割付が行われなかった場合はNA。 nAssignedCat_1, nAssignedCat_2: 割り付けられたスロット番号。 割り付けられたスロットが0～1個の場合はNAが格納される。 ある対象者におけるnAssignedSlot_1の値とnAssignedSlot_2の値の順序に意味はない。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/trimWeight.html","id":null,"dir":"Reference","previous_headings":"","what":"trim Weight. — trimWeight","title":"trim Weight. — trimWeight","text":"ウェイトを切り詰める","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/trimWeight.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"trim Weight. — trimWeight","text":"","code":"trimWeight(agWEIGHT, gLIMIT = 5)"},{"path":"https://shigono.github.io/rSurveyAssign/reference/trimWeight.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"trim Weight. — trimWeight","text":"agWEIGHT 数値ベクトル。ウェイト。 gLIMIT 切り詰める限界。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/trimWeight.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"trim Weight. — trimWeight","text":"数値ベクトル。agWEIGHTが上限gLIMIT, 下限1/gLIMITの範囲に 収まっていたらそのまま返す。そうでないときは、 この範囲に切り詰め、かつ平均を1としたベクトルを返す。","code":""}]
