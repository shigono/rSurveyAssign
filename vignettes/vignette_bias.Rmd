---
title: "How to estimate bias"
author: "Shigeru ONO"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{How to estimate bias}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


ここでは、`rSurveyAssign`パッケージを使った割付バイアスの評価について
説明します。

`rSurveyAssign`パッケージの背後にある考え方については、
["rSurveyAssign: tools for simulation of assignment in web surveys"](vignette.html)を参照して下さい。

## 1. 割付バイアスを評価するための指標

まず、調査結果が持つ割付バイアスを評価する方法について説明します。

`rSurveyAssign`パッケージは、調査結果が持つ割付バイアスを評価するために、次の3つの指標を提供しています。

- **割付確率の変動係数**
- **デザイン効果 **
- **実質標本サイズ **

### 1.1 割付確率の変動係数

以下では、調査で測定したい変数のことを調査変数と呼ぶことにします。
調査の目的は、各カテゴリ・スロットにおける調査変数の母集団特性(たとえば母平均)を推定することです。
バイアスとは、調査変数の母集団特性と、調査に基づくその推定値との差の期待値のことです。

あるカテゴリ・スロットについての回答における割付バイアスは、調査変数と、そのカテゴリ・スロットへの割付確率との関連 (共分散)によって決まります。たとえば、あるスロットへの回答におけるある調査変数についてみたとき、その調査変数の値が高い人ほど
そのスロットへの割付確率が高いとしましょう。このとき、そのスロットについての調査変数の標本平均は、
母平均と比べて高めになってしまいます。つまり、この調査変数において割付バイアスが生じます。いっぽう、調査変数と割付確率の間に全く関連がなかったら、この調査変数においては割付バイアスが生じません。このように、割付バイアスは調査変数によって異なります。割付バイアスの実際の大きさは、個々の調査変数についてしか評価できないわけです。

しかし、もし割付確率のばらつきが0に近ければ、割付バイアスはいずれの調査変数においても小さいことになります。なぜなら、たとえある調査変数と割付確率との関連が強かったとしても、割付確率そのものが回答のあいだで等しければ、バイアスは生じないからです。
そこで、調査変数が特定されない状況では、割付確率のばらつきを割付バイアスの大きさとして捉えることができます。

そこで'rSurveyAssign'パッケージでは、**割付確率の変動係数**(=SD/平均)を、割付バイアスの大きさの指標のひとつとして用いています。

### 1.2 デザイン効果

各対象者の各カテゴリ・スロットへの割付確率を正確に推定できているならば、割付確率の逆数をウェイトとして集計することで、集計値における割付バイアスを取り除くことができます。

その反面、一般に、ウェイトを用いて集計すると集計値の分散は拡大します。集計値の分散は標本サイズが減少したときにも拡大しまから、ウェイトを用いた集計は、割付バイアスを取り除く反面、あたかも標本サイズを減らすかような効果を持つといえます。

**デザイン効果**とは、バイアスの大きさを、割付確率の逆数をウェイトとして集計することによって生じる仮想的な標本サイズの減少率として表現した値です。この値は、1+(割付確率の逆数の相対分散)として求められます。

### 1.3 実質標本サイズ

実際の標本サイズにデザイン効果を掛けた値を**実質標本サイズ**と呼びます。たとえば、実際の標本サイズが
100で、実質標本サイズが50であるとしましょう。これは、割付に伴って生じるバイアスの大きさが、それを取り除いたら標本サイズが
50に減ってしまう程度の大きさであるということを表しています。

私たちはふつう、割付確率の変動係数やデザイン効果について直観的に解釈できませんが、
標本サイズについてはなんらかの基準を持っていることが多いでしょう。いま、
いま、割付バイアスが生じないような調査を実現できるとして、その調査における標本サイズが100以下であったら「標本サイズが小さすぎる」と感じるとしましょう。このとき、割付バイアスが生じる調査において実質標本サイズが100以下であったら「割付バイアスが大きすぎる」と考えることができます。


## 2. データの準備

では、`rSurveyAssign`パッケージによるバイアス評価の手順について説明しましょう。

母集団を表現するデータを用意し、popdataクラスのオブジェクトに変換します。
["How to forecast sample size"](vignette_size.html)を参照して下さい。

```{r}
library(rSurveyAssign)

# 母集団オブジェクトの作成
data(popdata, package = "rSurveyAssign")
mbCat <- as.matrix(popdata[, paste0("bCat_", 1:3)])
lSlot <- list(
    as.matrix(popdata[, paste0("bSlot_1_", 1:10)]),
    as.matrix(popdata[, paste0("bSlot_2_", 1:10)]), 
    as.matrix(popdata[, paste0("bSlot_3_", 1:10)])
  )
lPop <- makePop(mbCAT = mbCat, lSLOT = lSlot)
```

割付のセッティングを指定します。

```{r}
# 割付のセッティング
lSetting1 <- makeSetting(
  lSLOT_REQUEST = lapply(lSlot, function(mbSlot) rep(100, ncol(mbSlot))), 
  nCAT_MAX      = 1, 
  sCAT_TYPE     = 'adaptive', 
  sCAT_FILTER   = 'open', 
  sCAT_ORDER    = 'shortnum', 
  sCAT_EXCLUDE  = 'allclosed',
  nSLOT_MAX     = 2, 
  sSLOT_TYPE    = 'adaptive', 
  sSLOT_FILTER  = 'open', 
  sSLOT_ORDER   = 'shortnum', 
  sSLOT_EXCLUDE = 'allclosed'
)
```


## 3. 割付・再割付シミュレーション
割付によるバイアスを評価するためのシミュレーションを行います。

このシミュレーションでは、次の試行を行います。

- 母集団データから対象者を抽出し、カテゴリ・スロットへの割付を行う(**割付試行**)。
- ある割付試行で得た調査データから、仮想的な調査データを再生成し、カテゴリ・スロットへの割付をやりなおす(**再割付試行**)。これを繰り返して、その割付試行において、ある対象者があるカテゴリないしスロットに割り付けられる確率を推定する。
- あるカテゴリないしスロットに割り付けられた対象者間での、割付確率のばらつきを調べる。
- 以上の割付試行を複数回繰り返す。

### 3.1 1試行の実行
まず、割付試行を1回だけ行ってみましょう。時間を節約するため、再割付試行は10回とします。

```{r}
set.seed(123)  # 結果を再現するために乱数のシードを設定している。通常は設定不要
lResult1 <- simBias (
  lPOP        = lPop, 
  lSETTING    = lSetting1, 
  nNUMRETRIAL = 10,
  sVERBOSE    = "simple"
)
```

シミュレーションの結果をみてみましょう。

`simBias`の返し値は3つの要素からなるリストです。
要素`dfSubject`は割付試行の結果を表しています(再割付試行ではありません)。

```{r}
head(lResult1$dfSubject)
```

この割付試行では、対象者1として母集団メンバー6779が抽出され、カテゴリ1,2に割り付けられ、カテゴリ1のスロット9,6に割り付けられました。

要素`dfStat_Cat`は、再割付試行の結果のうち、
カテゴリへの再割付の結果を表しています。

```{r}
head(lResult1$dfStat_Cat)
```

10回の再割付試行を通じて、対象者1(正確には、対象者1に相当する割付可能性を持っている人)は延べ6回抽出されました。そのうちカテゴリ1への割付が生じたのは4回でした。つまり、この割付試行における対象者1のカテゴリ1への割付確率はおよそ4/6=0.67であったと推定されます。

要素`dfStat_Slot`は、再割付試行の結果のうち、スロットへの再割付の結果を表しています。

```{r}
head(lResult1$dfStat_Slot)
```

10回の再割付試行を通じて、対象者1(正確には、対象者1に相当する割付可能性を持っている人)は延べ6回抽出され、そのうちカテゴリ1のスロット9への割付が生じたのは9回でした。割付確率はおよそ0/6 = 0.00であったと推定されます。実際には割付確率は0ではないので(もしそうであれば割付試行において割付が起きなかったはずです)、0に近い値、ということを意味しています。

### 3.2 多数の試行の実行と保存

上の例では、割付試行を1回、再割付試行を10回行い、
シミュレーションの結果をデータフレームのリストとして取得しました。

バイアスを評価するためには、十分な数の再割付試行を繰り返す必要があります。
そこで今度は、割付試行を10試行、再割付試行を割付試行あたり1000試行繰り返してみましょう。

シミュレーションの結果はサイズが大きいので、SQLiteデータベース上に
保存したほうがよいでしょう。
以下の例では、SQLiteデータベースファイルとして`..\tools\rSurveyAssign_vignette_bias_1.sqlite`を
作成しています。実際には、適切なフォルダとファイル名を指定してください。また、
データベースファイルは、必要がなくなったら自分で消してください。

実行時間を短くするため、並列処理を行うことにします。引数`bPARALLEL`にTRUEを指定します。
並列処理を行う場合、各試行についてのメッセージは画面に表示されません。
そこでログファイルを作成することにします。
実行に長い時間がかかる場合は、ログファイルを監視すると、
いま何試行まで進んでいるかわかり、少しだけ心が癒されるでしょう。

下の例では、ログファイルを`C:/work/simWeight.log`としています。
RStudioを使っているなら、Terminalウィンドウで`tail -F C:/work/simWeight.log`を
実行すると、ログファイルを監視できます。

```{r}
## 都合によりコメントアウトしています
# set.seed(123)  # 結果を再現するために乱数のシードを設定している。通常は設定不要
# simBias (
#   lPOP        = lPop, 
#   lSETTING    = lSetting1, 
#   sDBPATH     = "..\tools\rSurveyAssign_vignette_bias_1.sqlite",
#   nNUMTRIAL   = 10,
#   nNUMRETRIAL = 1000,
#   bAPPEND     = FALSE, 
#   bPARALLEL   = TRUE,
#   sLOGFILE    = "c:/work/simWeight.log"
# )
```


## 4. 割付バイアスの評価

では、割付バイアスを評価してみましょう。関数`getBias`を使います。

### 4.1 カテゴリごとのバイアス

関数`getSize`の引数`sTYPE`を`cat`とすると、
各試行での各カテゴリごとの割付バイアスを評価することができます。
getBias`の返し値はデータフレームです。内容をみてみましょう。

```{r}
dfResult1_c <- getBias(sTYPE = "cat", sDBPATH = "../tools/rSurveyAssign_vignette_bias_1.sqlite")
head(dfResult1_c)
```

行は各割付試行における各カテゴリを表しています。

- 変数 `nFreq_Cat`は、その割付試行におけるそのカテゴリに対する回答件数(すなわち、このカテゴリに割り付けられた延べ対象者数)を表しています。試行1ではカテゴリ1が2030回割り付けられました。
- 変数 `gCV_Prob_Cat`はカテゴリへの割付確率の変動係数を表しています。0のときには割付バイアスがありません。大きいほど割付バイアスが大きいと考えられます。試行1では、カテゴリ1の割付における割付確率の変動係数が約0.42となりました。
- 変数`gDeff_Cat`は、カテゴリに対する回答におけるデザイン効果を表しています。1のときには割付バイアスがありません。1より大きいほど割付バイアスが大きいと考えられます。試行1では、カテゴリ1に対する回答におけるデザイン効果が約1.06となりました。
- 変数`gESS_Cat`は、カテゴリに対する回答の実質標本サイズを表しています。この値が回答件数と一致するときはバイアスがありません。それより小さいほど、バイアスが大きいと考えられます。試行1では、カテゴリ1に対する回答の実質標本サイズは約1939となりました。

10回の割付試行を通じた、割付確率の変動係数のカテゴリ別平均を求めてみましょう。

```{r}
print(tapply(dfResult1_c$gCV_Prob_Cat, dfResult1_c$nCat, mean))
```
割付確率の変動係数は0.19から0.44程度です。
特にカテゴリ1への回答において、かなりの割付バイアスが生じているようです。

### 4.2 スロットごとのバイアス

関数`getSize`の引数`sTYPE`を`slot`とすると、
各試行での各スロットへの回答における割付バイアスを調べることができます。


```{r}
dfResult1_s <- getBias(sTYPE = "slot", sDBPATH = "../tools/rSurveyAssign_vignette_bias_1.sqlite")
head(dfResult1_s)
```

行は割付試行とスロットの組み合わせです。

- 変数 `nFreq_Slot`は、その割付試行におけるそのスロットへの回答件数(そのスロットに割り付けられた延べ対象者数)を表しています。試行1ではカテゴリ1のスロット1への割付が100回生じました。
- 変数 `gCV_Prob_Slot`はスロットへの割付確率の変動係数を表しています。0のときには割付バイアスがありません。大きいほど割付バイアスが大きいと考えられます。試行1のスロット1では、割付確率の変動係数が約0.59となりました。
- 変数`gDeff_Slot`は、スロットに対する回答におけるデザイン効果を表しています。1のときには割付バイアスがありません。1より大きいほど割付バイアスが大きいと考えられます。試行1では、カテゴリ1のスロット1に対する回答におけるデザイン効果が約7.4となりました。
- 変数`gESS_Slot`は、スロットに対する回答の実質標本サイズを表しています。この値が回答件数と一致するときは割付バイアスがありません。それより小さいほど割付バイアスが大きいと考えられます。試行1では、カテゴリ1のスロット1に対する回答の実質標本サイズは約13.6となりました。

10回の割付試行を通じた、デザイン効果のスロット別平均を求めましょう。
```{r}
print(tapply(dfResult1_s$gCV_Prob_Slot, list(dfResult1_s$nCat, dfResult1_s$nSlot), mean))
```
割付確率の変動係数は平均して0.12から0.57程度です。スロットの回答における割付バイアスもかなり大きいようです。

## 5. 評価指標の偏り

現バージョンの`rSurveyAssign`パッケージが提供する割付バイアスの評価指標
(割付確率の変動係数、デザイン効果、実質標本サイズ)は、いずれも少し悲観的な方向に偏っています。
そのことを、以下の例でみてみましょう。


```{r}
# 割付のセッティング
lSetting2 <- makeSetting(
  lSLOT_REQUEST = lapply(lSlot, function(mbSlot) rep(100, ncol(mbSlot))), 
  nCAT_MAX = 1, 
  sCAT_TYPE = 'nonadaptive', 
  sCAT_FILTER = 'open', 
  sCAT_ORDER  = 'shortnum', 
  sCAT_EXCLUDE = 'none',
  nSLOT_MAX = 2, 
  sSLOT_TYPE = 'nonadaptive', 
  sSLOT_FILTER = 'open', 
  sSLOT_ORDER  = 'shortnum', 
  sSLOT_EXCLUDE = 'none'
)
set.seed(123)  # 結果を再現するために乱数のシードを設定している。通常は設定不要
## 都合によりコメントアウトしています
# simBias (
#   lPOP       = lPop, 
#   lSETTING   = lSetting2, 
#   sDBPATH    = "../tools/rSurveyAssign_vignette_bias_2.sqlite",
#   nNUMTRIAL  = 10,
#   nNUMRETRIAL = 500,
#   bAPPEND    = FALSE, 
#   bPARALLEL  = TRUE,
#   sLOGFILE   = "c:/work/simWeight.log"
# )
```
割付確率の変動係数を調べてみましょう。

```{r}
dfResult2_c <- getBias(sTYPE = "cat", sDBPATH = "../tools/rSurveyAssign_vignette_bias_2.sqlite")
print(tapply(dfResult2_c$gCV_Prob_Cat, dfResult2_c$nCat, mean))
```
カテゴリ別の割付確率の変動係数は0.03から0.05程度です。

```{r}
dfResult2_s <- getBias(sTYPE = "slot", sDBPATH = "../tools/rSurveyAssign_vignette_bias_2.sqlite")
print(tapply(dfResult2_s$gCV_Prob_Slot, list(dfResult2_s$nCat, dfResult2_s$nSlot), mean))
```
スロット別の割付確率の変動係数は0.06から0.19程度です。

本項で試した割付方法は、カテゴリについてもスロットについても非適応的かつ除外条件のない割付方法を採用し、
かつ割付カテゴリの最大数は1でした。
["rSurveyAssign: run simulations of assignments for web surveys"](vignette.html)で述べたように、
この割り付け方法では割付バイアスは生じないはずです。

ところが、割付確率の変動係数は0に近い値になったものの、0にはなりませんでした。これは
割付確率の推定に誤差があるためです。誤差は再割当試行数を大きくすれば小さくなりますが、0にはなりません。
そのため、割付確率の変動係数は、真の変動係数と比べ、誤差による変動のぶんだけ大きめに偏ってしまいます。

現バージョンの`rSurveyAssign`パッケージは、この偏りを修正する方法を実装していません。
そのため、割付バイアスの評価指標はいずれも少し大きめになっています。
これらの指標は、あくまで相対的な指標として捉え、割付方法間の比較にのみ用いることをお勧めします。

## 6. まとめ: 割付バイアス評価に関連する関数
`rSurveyAssign`パッケージが提供する関数のうち、割付バイアスの評価に関連する関数は以下の通りです。

- `makePop`: 母集団データを作成する
- `makeSetting`: 割付のセッティングを作成する
- `simBias`: シミュレーションを実行し結果をデータベースに格納する
- `getBias`: データベースに格納されたシミュレーション結果を集計して取り出す
- `countBias`: データベースに格納されたシミュレーション結果の試行数を調べる
