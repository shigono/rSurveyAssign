[{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette.html","id":"事例-製品ブランドの購入意向測定","dir":"Articles","previous_headings":"","what":"1. 事例: 製品ブランドの購入意向測定","title":"rSurveyAssign: tools for simulation of assignment in web surveys","text":"このパッケージについて説明するための例として、 ある製品カテゴリの\\(K\\)個の製品ブランドについて、消費者の購入意向を調べたいという場面について考えます。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette.html","id":"つの調査手続き","dir":"Articles","previous_headings":"1. 事例: 製品ブランドの購入意向測定","what":"1.1 4つの調査手続き","title":"rSurveyAssign: tools for simulation of assignment in web surveys","text":"この調査の手続きについて考えてみましょう。まず、次の手続きが考えられます。 対象者にあるひとつのブランドを提示し、そのブランドの購入意向を聴取します。 これを、\\(K\\)個すべてのブランドについて繰り返します。 この手続きでは、対象者は購入意向についての回答を\\(K\\)回繰り返す事になります。 ブランドの数が多いときは回答負荷が高くなってしまいます。 そこで、次の手続きを考えます。 それぞれの対象者について、その人に提示するブランドを\\(L\\)個選びます。\\(L\\)はブランド数\\(K\\)よりも小さく、 十分に小さな値とします。 以下ではこれを「対象者を\\(L\\)個のブランドに割り付ける」と表現します。 対象者に割り付けられた\\(L\\)個のブランドのうちひとつを提示し、購入意向を聴取します。 これを\\(L\\)個のブランドについて繰り返します。 この手続きでは、ブランドの数がいくつあっても、対象者は設問への回答を\\(L\\)回繰り返せば良いことになります。 上記2つの手続きでは、いずれの対象者もいずれのブランドに対して割付可能であると仮定してきました。 しかし実際には、対象者はすべてのブランドについて知っているわけではないかもしれません。 対象者が知らないブランドについて購入意向を聴取しても、回答者は困ってしまうでしょうし、 有益な回答は得られないでしょう。そこで、次のような手続きを考えます。 それぞれの対象者に、\\(K\\)個のブランドのリストを提示し、知っているブランドはどれかを聴取します。 それぞれの対象者を、その人が知っているすべてのブランドに割り付けます。 いずれのブランドについても知らないと答えた人については聴取を終了します。 対象者に、割り付けられたブランドのうちひとつを提示し、購入意向を聴取します。 これを、その人が割り付けられたすべてのブランド(=その人が知っているすべてのブランド)について繰り返します。 この手続きでは、対象者が知らないブランドについて聴取するという事態を避けることが できます。しかし、たくさんのブランドを知っている人は、調査手続きA.と同じく、 購入意向についての回答を何度も繰り返すことになります。 回答負荷は回答者によってばらつき、多くのブランドを知っている人ほど負荷が高くなってしまいます。 そこで、次のような手続きを考えます。 それぞれの対象者に、\\(K\\)個のブランドのリストを提示し、知っているブランドはどれかを聴取します。 それぞれの対象者を、その人が知っているブランドのうち\\(1\\)個～\\(L\\)個のブランドに割り付けます。 いずれのブランドについても知らないと答えた人については聴取を終了します。 割り付けられたブランドのうちひとつを提示し、 購入意向を聴取します。これを、割り付けられたブランドについて繰り返します。 この手続きでは、対象者が知らないブランドに聴取するという事態を避けることが できますし、ブランドをいくつ知っていても、 対象者は購入意向についての回答を多くても\\(L\\)回まで繰り返せば良いことになります。 4つの調査手続きについて整理しておきましょう。 調査手続きC.やD.のように、対象者の回答(各ブランドを知っているかどうか)に応じてその後の設問を変更する手続きは、古典的な質問紙調査では困難でした。web調査ならではの調査手続きといえるでしょう。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette.html","id":"調査手続きの性質","dir":"Articles","previous_headings":"1. 事例: 製品ブランドの購入意向測定","what":"1.2 調査手続きの性質","title":"rSurveyAssign: tools for simulation of assignment in web surveys","text":"調査手続きD.は、いっけん良い手続きのようにみえます。しかしこの手続きは、次の2つの深刻な問題点を持っています。 必要な対象者数がわからない 回答の集計値がバイアスを持つ","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette.html","id":"問題点1--必要な対象者数がわからない","dir":"Articles","previous_headings":"1. 事例: 製品ブランドの購入意向測定 > 1.2 調査手続きの性質","what":"問題点1. 必要な対象者数がわからない","title":"rSurveyAssign: tools for simulation of assignment in web surveys","text":"それぞれのブランドのイメージを測定するために、それぞれのブランドについて十分な件数の回答を得たいとしましょう。 調査手続きA.では、\\(N\\)人の対象者に調査すれば、各ブランドについて\\(N\\)件の回答が得られます。 調査手続きB.では、\\(N\\)人の対象者に調査すれば、全ブランドを通じて延べ \\(N \\times L\\) 件の回答が得られます。ブランドへの割付をバランス良く行えば、各ブランドについて \\((N \\times L) / K\\) 件の回答が得られるはずです。 調査手続きC.では、対象者があるブランドについて知っている割合を\\(P\\)としたとき、そのブランドについて \\(N \\times P\\) 件の回答が得られます。事前に別の情報源から \\(P\\) を推測できれば、十分な件数の回答を得るために必要な対象者数を逆算することができるでしょう。 しかし調査手続きD.では、各ブランドについて何件の回答が得られるかを事前に推測することが困難です。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette.html","id":"問題点2--回答の集計値がバイアスを持つ","dir":"Articles","previous_headings":"1. 事例: 製品ブランドの購入意向測定 > 1.2 調査手続きの性質","what":"問題点2. 回答の集計値がバイアスを持つ","title":"rSurveyAssign: tools for simulation of assignment in web surveys","text":"調査手続きD.によって得た回答の集計値がどのような性質を持つか、簡単な例を通じて考えてみましょう。 調査対象のブランドを{,b,c}の3つとしましょう。aについて知っている対象者に注目すると、 対象者たちは下表の4種類に分かれます。 調査手続きD.による調査を想定します。 各対象者の割付ブランド数の最大値を2としたとき、aについて知っている人が aに割り付けられる確率はどうなるでしょうか。 仮に、割付ブランドをその対象者が知っているブランドのなかから等確率に選ぶとすると、 下表となります。 a以外のブランド(bとc)のうち、知っているブランドの個数が0から1の人は、 必ずaに割り付けられます。 いっぽう、個数が2の人(,b,cのすべてを知っている人)がaに割り付けられる確率は\\(2/3\\) しかありません。 従って、この調査手続きで集めたaについての回答は、aについて知っている人々のうち、 他のブランドを知らない人々の回答へと偏ることになります。 多くの場合、あるブランドについての知識や態度は、 その製品カテゴリの他のブランドについて知っている程度と関連しているでしょう。 たとえば、ブランドaに対する購入意向が、 他に多くのブランドを知っているほど低いとしましょう。 このとき、ブランドaの購入意向の回答は高めに偏ることになります。 このような、割付に起因する集計値の偏りを割付バイアスと呼ぶことにします。 割付バイアスの大きさは、各ブランドが知られている程度や 割付ブランドの選び方によって複雑に変化します。そのため、推測するのは容易ではありません。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette.html","id":"このパッケージの目的","dir":"Articles","previous_headings":"","what":"2 このパッケージの目的","title":"rSurveyAssign: tools for simulation of assignment in web surveys","text":"調査対象者に刺激を提示し反応を測定したい一方、個々の対象者に提示できる刺激に制約があるという場面は、調査実務において珍しくありません。回答負荷や調査コストの削減のため、上記の調査手続きD.のように割付の最適化を図る場合も多いでしょう。その反面、このような割付の最適化を行うと、事前の標本サイズ設計は困難になり、調査結果は割付バイアスを持ちます。 rSurveyAssignパッケージはこの問題に対処するためのパッケージです。このパッケージは、割付の最適化を伴う調査に対して、3つの機能を提供します。 必要な対象者数を事前に推測する 集計値における割付バイアスを事前に評価する 集計値から割付バイアスを取り除くためのウェイトを算出する","code":""},{"path":[]},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette.html","id":"カテゴリスロット割付可能性","dir":"Articles","previous_headings":"3. このパッケージが想定している状況","what":"3.1 カテゴリ・スロット・割付可能性","title":"rSurveyAssign: tools for simulation of assignment in web surveys","text":"このパッケージは、次の状況を想定して作られています。 1つ以上の「カテゴリ」がある。 あるカテゴリは、1つ以上の「スロット」からなる。 すべてのカテゴリのすべてのスロットについて調査したい。 それぞれの調査対象者は、それぞれのカテゴリについて「割付可能」かそうでないかのいずれかである。 それぞれの調査対象者は、それぞれのスロットについて「割付可能」かそうでないかのいずれかである。 ある対象者を割り付けることができるカテゴリ・スロットの数には上限がある。 いくつかの例を挙げましょう。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette.html","id":"例1","dir":"Articles","previous_headings":"3. このパッケージが想定している状況 > 3.1 カテゴリ・スロット・割付可能性","what":"例1","title":"rSurveyAssign: tools for simulation of assignment in web surveys","text":"消費者が耐久消費財ブランドについて抱いているイメージを調べたい。 自動車、白物家電、携帯電話、家具のブランドについて調べることにする。 自動車のブランドのうち、トヨタ、日産…などについて調べる。白物家電のうち、日立、パナソニック…などについて調べる。 このように、各製品カテゴリの複数のブランドについて調べる。 ある製品カテゴリについて聴取する対象者は、そのカテゴリの使用者に限定したい。 ある製品カテゴリのあるブランドについてイメージを聴取する対象者は、そのブランドについて知っている人に限定したい。 ある対象者に聴取できるカテゴリの数とブランドの数に上限を設けたい。 この例では、「カテゴリ」は製品カテゴリ(自動車、白物家電、携帯電話、家具)、 「スロット」はブランド (トヨタ、日産…、日立、パナソニック…)に対応しています。 下の表を参照してください。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette.html","id":"例2","dir":"Articles","previous_headings":"3. このパッケージが想定している状況 > 3.1 カテゴリ・スロット・割付可能性","what":"例2","title":"rSurveyAssign: tools for simulation of assignment in web surveys","text":"数多くの国内観光地について、そこに訪問した人の満足度を調べたい。 ある対象者にある観光地について訪問時の満足度を訊くためには、 その対象者はその観光地に訪問したことがなければならない。 ある対象者に満足度を訊くことができる観光地の数には上限がある。 この例では、「スロット」は観光地に対応しています。 「カテゴリ」にあたるものはないので、 ひとつのカテゴリが存在し、すべての対象者がそのカテゴリに たいして割付可能であると考えます。 下の表を参照してください。 これらは例にすぎません。このパッケージは、「カテゴリ」「スロット」「割付可能性」が 具体的に何を指すのかは問いません。また、割り付けたカテゴリとスロットについてなにを聴取するのかも問いません。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette.html","id":"調査手続き","dir":"Articles","previous_headings":"3. このパッケージが想定している状況","what":"3.2 調査手続き","title":"rSurveyAssign: tools for simulation of assignment in web surveys","text":"このパッケージでは、Web調査を想定し、次のように仮定します。 調査対象者の調査への参加は逐次的に行われます。すなわち、全員が同時に回答をはじめるのではなく、まちまちのタイミングで回答をはじめます。ある対象者のカテゴリ・スロットへの割付も逐次的に行われます。 調査対象者のカテゴリ・スロットへの回答、ならびに割付可能性は、調査対象者間で独立です。 調査対象者の回答と調査参加順序とのあいだには関連がありません。 それぞれのスロットについて、そのスロットに割り付けたい対象者数が定められています。これを「目標対象者数」と呼びます。 また、以下の用語を導入します。 調査実施中のある時点において、それまでに割り付けられた対象者数が目標対象者数に達していないスロットを「オープン」、達しているスロットを「クローズド」と形容することにします。 調査実施中のある時点において、オープンなスロットが1つ以上あるカテゴリを「オープン」、すべてのスロットがクローズドであるカテゴリを「クローズド」と形容することにします。 本パッケージは以下に説明する調査手続きを想定します。 ある人が調査に参加したとき、その人(対象者)について、各カテゴリについて割付可能であるかどうかを調べる。 なんらかの方法で、その対象者のすべての割付可能カテゴリのうちいくつかを選ぶ。 これを、「対象者をカテゴリに割り付ける」と呼び、 選択されたカテゴリを「割付カテゴリ」と呼ぶ。 もし割付できなかったら、その対象者に対する調査は中止する。 対象者に、それぞれの割付カテゴリについてスロットのリストを提示し、それぞれについて割付可能かどうかを調べる。 なんらかの方法で、その対象者のいずれかの割付カテゴリの割付可能スロットのなかからいくつかを選ぶ。 これを、「対象者をスロットに割り付ける」と表現し、選択されたカテゴリを「割付スロット」と呼ぶ。 もし割付できなかったら、その対象者に対する調査は中止する。 割付スロットについての詳細な設問を提示し、回答を得る。 すべてのカテゴリがクローズドになったら、調査を終了する。 この調査手続きにおいては、Step 2.でのカテゴリの割付方法と、Step 4.でのスロットの割付方法に応じて、 必要な対象者数が大きく変わり、また割付バイアスの大きさも変わります。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette.html","id":"このパッケージの用途","dir":"Articles","previous_headings":"","what":"4. このパッケージの用途","title":"rSurveyAssign: tools for simulation of assignment in web surveys","text":"このパッケージは、上記の手続きによる調査を実施しようと考えている調査者、ないしすでに実施した調査者のためのパッケージです。 このパッケージではさまざまな割付方法について検討することができます。 このパッケージがカバーしている 割付方法の範囲について、“1. assign subjects”を参照して下さい。 このパッケージの用途は次の3つです。 上記の手続きによる調査を計画しているとき、 各スロットについて必要な回答件数を得るためにはどの程度の調査対象者数が必要か、 シミュレーションによって推定する。 使用方法は“2. forecast sample size”を参照して下さい。 上記の手続きによる調査を計画しているとき、 調査結果が持つであろうバイアスをシミュレーションによって評価する。 使用方法は“3. estimate bias”を参照して下さい。 上記の手続きによる調査を行ったあとで、 集計のためのウェイトをシミュレーションによって算出する。 使用方法は“4. compute survey weights”を参照して下さい。 なお、このパッケージはweb調査の機能を提供するものではありません。web調査の実施時に対象者をカテゴリ・スロットへと割り付ける機能は、web調査システム上で別途実装する必要があります。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_assign.html","id":"カテゴリの割付方法","dir":"Articles","previous_headings":"","what":"1. カテゴリの割付方法","title":"1. How to assign subjects","text":"割付カテゴリを決める方法は多様です。rSurveyAssignパッケージは、割付方法を次の4つの特徴によって整理します。 割付タイプ 絞り込み条件 順序付け条件 除外条件 順に説明します。 対象者に割り付けるカテゴリの最大数を\\(L\\)とします。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_assign.html","id":"割付タイプ","dir":"Articles","previous_headings":"1. カテゴリの割付方法","what":"割付タイプ","title":"1. How to assign subjects","text":"rSurveyAssignパッケージでは、割付タイプとして次の2種類を想定します。 各対象者について以下の手順でカテゴリ割付を行います。 その人の割付可能カテゴリから、指定した条件(絞り込み条件)を満たすカテゴリを選ぶ。 選ばれたカテゴリのなかから、指定された優先順位(順序付け条件)に従って \\(L\\)個までのカテゴリを選ぶ。 選ばれたカテゴリが所定の条件(除外条件)に該当する場合は、割付を中止する。 各対象者について以下の手順で割り付けを行います。 その対象者にとっての割付可能性を無視し、すべてのカテゴリのなかから、指定された優先順位(順序付け条件)に従って\\(L\\)個までのカテゴリを選ぶ。 選ばれたカテゴリのなかから、指定した条件(絞り込み条件)に該当するカテゴリを選ぶ。 選ばれたカテゴリが所定の条件(除外条件)に該当する場合は、割付を中止する。 ふたつの割付タイプは、絞り込みを先に行うか、順序付けを先に行うかという点が違います。 これは非適応的方法に比べて効率の良いやり方です。 その反面、割付バイアスが生じます。割付可能なカテゴリが多い人ほど、ある割付可能カテゴリに 割り付けられる確率が低くなるためです。 その結果、割付カテゴリが少なくなってしまったり、 0個になってしまったりする対象者が出現し、その分だけ多くの調査対象者数を必要とします。 その反面、割付バイアスは生じにくくなります。 ある対象者がある割付可能カテゴリに割り付けられるかどうかが、その対象者の 他のカテゴリの割付可能性とは独立に決まっているためです。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_assign.html","id":"絞り込み条件","dir":"Articles","previous_headings":"1. カテゴリの割付方法","what":"絞り込み条件","title":"1. How to assign subjects","text":"rSurveyAssignパッケージでは、絞り込み条件として次の2種類を想定します。 このとき、割付カテゴリはクローズドでありうる点に注意してください。つまり、すでに十分な人数の対象者が割り付けられているカテゴリに割り付ける場合が生じます。いいかえれば、「無駄な」回答収集を行うことになります。 open: その対象者の割付可能カテゴリのうちオープンなカテゴリを選ぶ。 どちらを選んでも必要な調査対象者数は変わりませんが、各スロットに最終的に割り付けられる人数はallのほうが多くなり、対象者の回答負荷はallのほうが高くなり、割付バイアスはopenのほうが強くなると考えられます。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_assign.html","id":"順序付け条件","dir":"Articles","previous_headings":"1. カテゴリの割付方法","what":"順序付け条件","title":"1. How to assign subjects","text":"rSurveyAssignパッケージでは、順序付けの条件として以下の4種類を想定します。 random: ランダムに並べる。 openclosed: 以下の順に並べる。(1)オープンなカテゴリ、ランダム順。 (2)クローズドなカテゴリ、ランダム順。 shortnum: その時点でオープンなスロット数が多いカテゴリから順に並べる。 shortratio: その時点でオープンなスロットが占める割合が大きいカテゴリから順に並べる。 {shortratioとshortnum}, open, randomの順に、必要な調査対象者数が少なくなり、また 割付バイアスが強くなると考えられます。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_assign.html","id":"除外条件","dir":"Articles","previous_headings":"1. カテゴリの割付方法","what":"除外条件","title":"1. How to assign subjects","text":"rSurveyAssignパッケージでは、除外の条件として以下の2種類を想定します。 none: なし。 allclosed: 選ばれたカテゴリがすべてクローズドであったら、割付を中止する。 絞り込み条件がopenであるとき、 選ばれたカテゴリはすでにオープンなカテゴリなので、除外条件は意味を持ちません。 絞り込み条件がallであるとき、除外条件としてallclosedを指定すると、 「割付カテゴリのうち少なくともどれかひとつはオープンでなければならない」と指定したことになります。 すなわち、すでに十分な対象者が割り付けられているカテゴリへの割付は生じますが、ある対象者が 割り付けられたカテゴリがすべてそのようなカテゴリだという事態は避けられます。必要な調査対象者数は 変わりませんが、聴取を途中でやめる対象者の数を増やすことができます (場合によっては実査コストの低減につながるでしょう)。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_assign.html","id":"組み合わせ","dir":"Articles","previous_headings":"1. カテゴリの割付方法","what":"組み合わせ","title":"1. How to assign subjects","text":"rSurveyAssignパッケージは、上で述べた4つの特徴の組み合わせによって生じる すべての割付方法をサポートしています。参考として、すべての組み合わせを下表に示します。 割り付けるカテゴリの最大数を\\(L\\)とします。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_assign.html","id":"スロットの割付方法","dir":"Articles","previous_headings":"","what":"2. スロットの割付方法","title":"1. How to assign subjects","text":"Step 4.で割付スロットを決める方法は、割付カテゴリを決める場合と同様です。 説明を以下のように読み替えてください。 「カテゴリ」→「スロット」 「その時点でオープンなスロット数が多いカテゴリ」→「その時点で目標票数に対して不足している票数が多いスロット」 「その時点でオープンなスロットが占める割合が多いカテゴリ」→「その時点で目標票数に対して不足している票数の割合が高いスロット」","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_assign.html","id":"割付スロット決定に際してのカテゴリの決定方法","dir":"Articles","previous_headings":"","what":"3. 割付スロット決定に際してのカテゴリの決定方法","title":"1. How to assign subjects","text":"Step 4.で割付スロットを決める際、もしStep 2.で複数個のカテゴリへの割付が生じていたら、 割付スロットをどの割付カテゴリから選ぶかという問題が生じます。 現バージョンのrSurveyAssignパッケージは、以下に述べる方法のみを想定しています。 割付カテゴリのなかからひとつを等確率に選び、そのカテゴリにおいて、前項で説明した方法で対象者をスロットへと割り付ける。 スロット割付ができなかったら、他の割付カテゴリのなかからひとつを等確率に選び、そのカテゴリにおいてスロットへと割り付ける。これを繰り返し、どこかのカテゴリでスロット割付ができるまで続ける。 どの割付カテゴリでもスロット割付ができなかったら、その対象者に対する調査を中止する。 従って、ある対象者の割付スロットは、必ず同一カテゴリのスロットとなります。","code":""},{"path":[]},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"割付バイアスの定義","dir":"Articles","previous_headings":"1. 割付バイアスの定義と性質","what":"1.1 割付バイアスの定義","title":"3. How to estimate bias","text":"割付バイアスとは、ひとことでいえば、割付に起因するバイアスのことです。以下では議論を進めやすくするために、 割付バイアスについてもっと明確に定義しておきましょう。 あるカテゴリないしスロットAについて考えます。ある調査を行ったとき、調査対象者(調査に参加した人)のなかにAに割付可能であった対象者が\\(N\\)人いたとします。仮に、その人々すべてからAについての設問への回答を得たとしましょう。 そのとき対象者\\((=1,\\ldots, N)\\)から得られる関心ある値を\\(x_i\\)とし、その平均を\\[\\bar{x}_P = \\frac{1}{N} \\sum_{=1}^N x_i\\] とします。添字\\(P\\)は割付可能な調査対象者を表しています。 以下では、私たちの目的は\\(\\bar{x}_P\\)を推測することだと考えます。通常の調査では、推測したいのは\\(\\bar{x}_P\\)ではなく、その背後にある対象母集団における回答の平均や、回答誤差をも取り除いた真の態度・意見の平均だと考えるのが普通です。しかし、ここではある調査のなかでの割付バイアスについて議論しているので、推測の対象は\\(\\bar{x}_P\\)だと考えることにします。 さて、私たちは調査のコストや回答負荷を低減するため、Aに割付可能であった\\(N\\)人の対象者すべてからAについての回答を得るのではなく、そのなかの\\(n\\)人をAに割りつけ、この人たちのみからAについての回答を得たとします。対象者\\(\\)がAに割り付けられたとき1, 割り付けられなかったとき0になる変数を\\(I_i\\)とします。 Aに割り付けられた\\(n\\)人の対象者から得られる\\(x_i\\)の平均は、以下のように表現できます。添字\\(S\\)は割り付けられた調査対象者を表しています。 \\[ \\bar{x}_S = \\frac{1}{n} \\sum_{=1}^N I_i x_i \\] 以下では割付バイアスを、割り付けられた対象者における平均の期待値と、割付可能なすべての対象者における平均とのずれ \\(E[\\bar{x}_S] - \\bar{x}_P\\) であると定義します。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"割付バイアスの性質","dir":"Articles","previous_headings":"1. 割付バイアスの定義と性質","what":"1.2 割付バイアスの性質","title":"3. How to estimate bias","text":"割付バイアスはどのような性質を持つでしょうか。上の式を変形してみましょう。 \\[E[\\bar{x}_S] - \\bar{x}_P = E \\left[ \\frac{1}{n} \\sum_{=1}^N I_i x_i \\right]  - \\frac{1}{N} \\sum_{=1}^N x_i\\] 対象者の回答\\(x_i\\)は定数であり、Aへの割付の有無\\(I_i\\)は確率変数であると考えます。このパッケージが想定している調査手続きでは、割り付けられた調査対象者数\\(n\\)は定数です(実際にはAについての回答者が\\(n\\)人に到達する前に調査を打ち切ってしまう場合もありえますが、ここでは無視します)。また、割付可能な調査対象者数\\(N\\)は実際には確率的に決まるのですが、A以外のたくさんのカテゴリ・スロットの割付可能性によって規定されますので、ここでは所与の定数であるとみなします。 すると、 \\[ = \\frac{1}{N} \\sum_{=1}^N \\frac{N}{n} E[I_i]x_i  - \\frac{1}{N} \\sum_{=1}^N x_i\\] \\[ = \\frac{1}{N} \\sum_{=1}^N \\left( \\frac{N}{n} E[I_i] -1 \\right) x_i \\] \\[ = \\frac{1}{N} \\sum_{=1}^N \\left( \\frac{N}{n} E[I_i] -1 \\right) (x_i - \\bar{x}) + \\frac{1}{N} \\sum_{=1}^N \\left( \\frac{N}{n} E[I_i] -1 \\right)\\bar{x}\\] \\[ = \\frac{1}{N} \\sum_{=1}^N \\left( \\frac{N}{n} E[I_i] -1 \\right) (x_i - \\bar{x}) + \\frac{\\bar{x}}{N} \\left( \\frac{N}{n} \\sum_{=1}^N  E[I_i] - N \\right)\\] ここで\\(E[I_i]\\)とは対象者\\(\\)がAに割り付けられる確率のことです。以下では\\(p_i\\)と書きましょう。その全対象者における合計は\\(\\sum_{=1}^N p_i = E \\left[ \\sum_{=1}^N I_i \\right] = n\\) です。従って第2項は0です。 \\[ = \\frac{1}{N} \\sum_{=1}^N \\left( \\frac{N}{n} p_i -1 \\right) (x_i - \\bar{x}) \\] \\(q_i = \\frac{N}{n} p_i\\) としましょう。割付可能対象者を通じたその平均は\\(\\bar{q}_P = \\frac{1}{N} \\sum_{=1}^N q_i = \\frac{1}{N} \\frac{N}{n} \\sum_{=1}^N p_i = 1\\)です。従って \\[ = \\frac{1}{N} \\sum_{=1}^N (q_i - \\bar{q}_P)(x_i - \\bar{x}_P)\\] ここから次のことがわかります。割付バイアスとは、「割付確率を割付可能対象者を通じて平均が1になるようにスケーリングした値」と、関心ある変数との、割付可能対象者を通じた共分散です。 いいかえれば、割付バイアスは、関心ある変数\\(x_i\\)と割付確率\\(p_i\\)の間に関連があるときに生じるバイアスです。 たとえば、あるスロットについて関心ある変数の値を得るとき、その値\\(x_i\\)が高い人ほど そのスロットへの割付確率\\(p_i\\)が高いとしましょう。このとき、そのスロットに割り付けられた対象者における平均\\(\\bar{x}_S\\)は、割付可能なすべての対象者における平均\\(\\bar{x}_P\\)と比べて高めになってしまいます。つまり、割付バイアスが生じます。 いっぽう、たとえ割付確率\\(p_i\\)に個人差があったとしても、関心ある変数\\(x_i\\)との間に全く関連がなかったら、この変数に限っては割付バイアスは生じません。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"割付バイアスはいつ生じるか","dir":"Articles","previous_headings":"1. 割付バイアスの定義と性質","what":"1.3 割付バイアスはいつ生じるか","title":"3. How to estimate bias","text":"では、このパッケージが想定している調査手続きにおいて、カテゴリないしスロットAについての関心ある変数\\(x_i\\)と、 Aへの割付確率\\(p_i\\)との間に関連が生じるのはどんな場合でしょうか。 このパッケージが想定している調査手続きにおいて、 対象者\\(\\)のAへの割付確率\\(p_i\\)を決めているのは次の3つの要因です。 対象者\\(\\)がA以外のどのカテゴリ・スロットに対して割付可能であったか。たとえば、たくさんのカテゴリ・スロットについて割付可能である人ほど、Aに割り付けられる確率は低くなりやすいでしょう。 対象者\\(\\)以外の対象者たちが、どのカテゴリ・スロットに対して割付可能であったか。たとえば、Aに対して割付可能な対象者が他に大勢いるほど、\\(\\)がAに割り付けられる確率は低くなりやすいでしょう。 対象者を参加順に並べたときの対象者\\(\\)その位置。たとえば、参加順序が遅いほど、AがすでにクローズドとなっておりAへと割り付けられない可能性が高まるでしょう。 従って、\\(x_i\\)と\\(p_i\\)とのあいだに関連が生じる理由として、次の3つが考えられます。 この関連は大いにありえます。たとえば製品ブランドについて調査しているとき、 その人の製品カテゴリについての知識や関与によって、各ブランドに対する態度や意見が異なるでしょうし、 その対象者がどのブランドを知っているかも異なるでしょう。 従って、Aについての回答と、他のカテゴリ・スロットへの割付可能性との間には 関連があると考えるのが自然です。 ふつう、このような関連性はないでしょう。 ふつう、この関連性についても無視できるでしょう。たとえば調査開始が早朝であったため、早起きの人ほど調査に参加しやすく、 かつ早起きな人とそうでない人のあいだでAについての回答に差がある… といったケースを想像することはできますが、 現実の調査においては生じにくいと思われます。 “rSurveyAssign: tools simulation assignment web surveys”で 述べたように、このパッケージでは、対象者の回答と割付可能性は対象者間で独立であり、ある対象者の回答と調査参加順序の間には関連がないと仮定します。つまり、3つのうち後ろのふたつは無視できます。 従って、つぎのようにいえます。このパッケージが想定している調査手続きにおいて、あるカテゴリ・スロットAにおいて割付バイアスが生じるのは、 関心ある変数\\(x_i\\)と、各対象者の他のカテゴリ・スロットへの割付可能性との間に関連があり、 各対象者の他のカテゴリ・スロットへの割付可能性と、Aへの割付確率\\(p_i\\)との間に関連があるときです。 1.は常に成り立つと考えるべきでしょう。いっぽう、2.はカテゴリ・スロットの割付方法によって決まります。 仮に、他のカテゴリ・スロットへの割付可能性とAに対する割付確率\\(p_i\\)とのあいだに関連がない割付方法を用いていれば、いかなる変数においても割付バイアスは生じません。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"割付バイアスと割付方法","dir":"Articles","previous_headings":"1. 割付バイアスの定義と性質","what":"1.4 割付バイアスと割付方法","title":"3. How to estimate bias","text":"では、他のカテゴリ・スロットへの割付可能性とAに対する割付確率とのあいだの関連性は、どのような割付方法において 生じるでしょうか。 結論からいえば、 このパッケージが想定している割付方法においては、ほとんどの場合、 他のカテゴリ・スロットへの割付可能性とAに対する割付確率が関連します。いいかえると、 ほとんどの場合、なんらかの割付バイアスが生じます。 以下ではできるだけ詳しく考えてみます。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"カテゴリ割付方法と割付バイアス","dir":"Articles","previous_headings":"1. 割付バイアスの定義と性質 > 1.4 割付バイアスと割付方法","what":"カテゴリ割付方法と割付バイアス","title":"3. How to estimate bias","text":"Aがカテゴリである場合、A以外のカテゴリへの割付可能性とAへの割付確率とのあいだに関連があるときに 割付バイアスが生じます。 従って、割付方法以外の側面に目を向けると、割付バイアスが生じうるのは 以下の条件がすべて満たされているときです。 もしカテゴリ数が1ならば、そのカテゴリに割付可能な対象者のすべてが そのカテゴリに割り付けられますから、割付バイアスは起きません。 たとえば、もしすべての対象者の割付可能カテゴリ数が0か1ならば、 あるカテゴリの割付可能対象者はほかに割付可能カテゴリを 持っていませんので、割付バイアスは生じません。 また、もしすべての対象者の割付可能カテゴリ数が0か\\(J\\)ならば、 あるカテゴリの割付可能対象者はほかのすべてのカテゴリにも割付可能ですので、 割付バイアスは生じません。 対象者が2群に分かれており、一方の群の人々はカテゴリ1,2,3に割付可能であり、 他方の群の人々はカテゴリ4,5,6に割付可能であるとします。このとき、 割付バイアスは起きません。 では、これらの条件が満たされているとして、どのような割付方法の下で 割付バイアスが生じるでしょうか。 それは、割付方法が以下のいずれかにあてはまるときです。 このとき、ある割付可能カテゴリは割付可能カテゴリ数が大きい人において選ばれにくくなります。よって割付バイアスが生じます。 ただし、割付カテゴリ最大数\\(J\\)が十分に大きな値に設定されていて、順序付けによるカテゴリ選択が生じえない場合には、割付バイアスは生じません。 このとき、すべての割付カテゴリがクローズドであった人の割付が中止されます。早くクローズドになるカテゴリしか割付可能でない人には割付が生じにくくなり、割付バイアスが生じます。 ただし、除外条件がallclosedであっても絞込条件がopenである場合には除外は生じません。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"スロット割付方法と割付バイアス","dir":"Articles","previous_headings":"1. 割付バイアスの定義と性質 > 1.4 割付バイアスと割付方法","what":"スロット割付方法と割付バイアス","title":"3. How to estimate bias","text":"Aがスロットである場合、割付バイアスが生じる原因として、次の3つを考えることができます。 カテゴリにおいて割付バイアスが生じていれば、スロットにおいても割付バイアスが生じます。割付スロットは割付カテゴリから選ばれるからです。 割付カテゴリの最大数が2以上であるときには、割付バイアスが生じます。あるカテゴリにおけるスロット割付が試みられるかどうかが、他のカテゴリでスロット割付が成立するかどうかに依存するからです。 Aが属するカテゴリのA以外のスロットへの割付可能性と、Aへの割付確率とのあいだに関連があるとき、割付バイアスが生じます。 3番目の割付バイアスが生じるのは、カテゴリにおける割付バイアスと同様に、以下の条件がすべて満たされているときです。 スロット数\\(K_j\\)が2以上であること あるスロットに割付可能な対象者に注目したとき、他の割付可能スロットが対象者によって異なること 割付タイプとしてadaptiveを選び、順序付けによるスロット選択が生じている 除外条件としてallclosedを選び、除外が生じている","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"割付バイアスを生まない割付方法","dir":"Articles","previous_headings":"1. 割付バイアスの定義と性質 > 1.4 割付バイアスと割付方法","what":"割付バイアスを生まない割付方法","title":"3. How to estimate bias","text":"上記の議論は過度に煩雑なので、逆に、「カテゴリ数・スロット数や対象者の割付可能性がどうであれ、カテゴリにおいてもスロットにおいても常に割付バイアスが生じない割付方法」について考えてみましょう。それは以下の条件を満たす割付方法です。 割付カテゴリ最大数を1としている。 カテゴリとスロットの割付方法を(nonadaptive, , (任意), none), (nonadaptive, open, (任意),(任意))のなかから選んでいる。 ここで次の点に注意してください。必要な調査対象者数を減らすために割付方法を工夫すると、多くの場合割付バイアスが生じてしまうのですが、必ず生じるとはいえません。 たとえば、 割付方法(nonadaptive, , random, none)は、「すべてのもの(カテゴリないしスロット)から\\(L\\)個を等確率に抜き出し、そのなかからその人に割付可能なものをすべて選んで割り付ける」方法です。 割付方法(nonadaptive, open, shortnum, none)は、「現時点で割付人数が目標に到達していないものから、割付人数が不足している順に\\(L\\)個までを抜き出し、そのなかからその人に割付可能なものをすべて選んで割り付ける」方法です。 調査に必要な対象者数という観点からみると後者のほうがはるかに効率的でしょう。しかし、(調査参加順と回答の間に関連がないと仮定する限り)どちらの方法でも割付バイアスは生じません。 このように、「必要な対象者数が少ない割付方法ほど強い割付バイアスが生じる」とは必ずしもいえないわけです。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"シミュレーションによる割付確率の推定","dir":"Articles","previous_headings":"","what":"2. シミュレーションによる割付確率の推定","title":"3. How to estimate bias","text":"調査手続きを設計している際には、これから行う調査における割付バイアスの大きさについて、ある程度の 目安をつけたくなります。しかし、割付バイアスの強さをかんたんに知ることはできません。 そこでrSurveyAssignパッケージは、割付バイアスの強さを評価する機能を提供しています。 割付バイアスの強さを評価するには、まず、個々の対象者がカテゴリ・スロットに割り付けられる 確率\\(p_i\\)を推定する必要があります。このパッケージでは、仮想的な母集団を用いたシミュレーションを通じて 割付確率を推定します。 このシミュレーションは以下の手順に従います。 母集団データから対象者を抽出し、カテゴリ・スロットへの割付を行う(割付試行)。 ある割付試行で得た調査データから無作為復元抽出によって仮想的な調査データを再生成し、カテゴリ・スロットへの割付をやりなおす(再割付試行)。 再割付試行を繰り返し、各カテゴリ・スロットについて、それに割付可能である個々の対象者の割付確率の推定値\\(\\hat{p}_i\\)、ならびに推定量の分散の推定値\\(\\hat{V}_i\\)を得る。 以上の割付試行を複数回繰り返す。 ある割付試行において、ふたつの推定値は次のように求めます。再割付試行の繰り返しを通じてある対象者が延べ\\(s\\)回抽出され、そのうち\\(t\\)回において当該のカテゴリ・スロットへの割付が生じたとします。このとき、 \\[ \\hat{p}_i = t/s \\] \\[ \\hat{V}_i = \\frac{\\hat{p}_i(1-\\hat{p}_i)}{s}\\]","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"割付バイアスを評価するための指標","dir":"Articles","previous_headings":"","what":"3. 割付バイアスを評価するための指標","title":"3. How to estimate bias","text":"rSurveyAssignパッケージは、 推定された\\(p_i\\), \\(V_i\\)に基づいて、これから行う調査が持つであろう割付バイアスを評価します。 本項では、評価の際に用いる指標について説明します。 このパッケージは、割付バイアスを評価するための指標として次の5つを提供しています。 \\(\\mathrm{CV}(\\hat{p})\\): 割付確率の推定値の変動係数 \\(\\hat{\\mathrm{CV}}(p)\\): 割付確率の変動係数の推定値 \\(\\hat{\\mathrm{Deff}}\\): デザイン効果の推定値 \\(\\hat{\\mathrm{ESS}}\\): 実質標本サイズの推定値 \\(\\mathrm{Cov}(\\hat{q},r)\\): スケーリングした割付確率の推定値と割付可能レシオとの共分散","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"mathrmcvhatp-割付確率の推定値の変動係数","dir":"Articles","previous_headings":"3. 割付バイアスを評価するための指標","what":"3.1 \\(\\mathrm{CV}(\\hat{p})\\): 割付確率の推定値の変動係数","title":"3. How to estimate bias","text":"あるカテゴリないしスロットにおいて生じる割付バイアスとは、割付可能対象者を通じた「平均が1になるようにスケーリングした割付確率」\\(q_i = p_i / \\bar{p}_P\\)と、関心ある変数\\(x_i\\)との共分散です。関心ある変数を特定しないと、割付バイアスの大きさもわからないわけです。 しかし、\\(q_i\\)のばらつきが小さければ、いかなる変数においても割付バイアスは小さいといえます。関心ある変数を特定できない状況では、\\(q_i\\)の標準偏差を割付バイアスの大きさの目安として捉えることができます。 そこでこのパッケージでは、割付確率の推定値の変動係数\\(\\mathrm{CV}(\\hat{p})\\)を、割付バイアスの大きさの指標のひとつとして提供します。 rSurveyAssignパッケージはこの値を以下のように求めています。割付可能対象者\\((=1,...,N)\\)の割付確率の推定値を\\(\\hat{p}_i\\)とします。 \\[ \\bar{\\hat{p}}_P = \\frac{1}{N} \\sum_{=1}^N \\hat{p}_i \\] \\[ \\mathrm{CV}(\\hat{p}) = \\frac{1}{\\bar{\\hat{p}}_P} \\times \\sqrt{ \\frac{1}{N} \\sum_{=1}^N (\\hat{p}_i - \\bar{\\hat{p}}_P)^2 } \\] ところで、\\(\\hat{q}_i = \\hat{p}_i / \\bar{\\hat{p}}_P\\) とすれば、 \\[ \\mathrm{CV}(\\hat{p}) = \\sqrt{ \\frac{1}{N} \\sum_{=1}^N \\left( \\frac{\\hat{p}_i - \\bar{\\hat{p}}_P}{\\bar{\\hat{p}}_P} \\right)^2 } = \\sqrt{\\frac{1}{N} \\sum_{=1}^N \\left( \\hat{q}_i - \\bar{\\hat{q}}_P \\right)^2}\\] ですから、この指標は、割付可能対象者における「平均が1になるようにスケーリングした割付確率の推定値」\\(\\hat{q}_i\\)の標準偏差であるともいえます。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"hatmathrmcvp-割付確率の変動係数の推定値","dir":"Articles","previous_headings":"3. 割付バイアスを評価するための指標","what":"3.2 \\(\\hat{\\mathrm{CV}}(p)\\): 割付確率の変動係数の推定値","title":"3. How to estimate bias","text":"上記の指標には次のような問題点があります。 私たちはシミュレーションを通じて\\(p_i\\)を推定します。しかし、どれだけシミュレーションを繰り返しても、 \\(p_i\\)そのものを知ることはできず、その推定量\\(\\hat{p}_i\\)しか手に入りません。\\(\\hat{p}_i\\)が不偏推定量であったとしても(つまり、\\(\\hat{p}_i\\)の 期待値が\\(p_i\\)と一致したとしても)、割付確率の推定値の変動係数\\(\\mathrm{CV}(\\hat{p})\\)は、真の割付確率の変動係数 \\[ \\mathrm{CV}(p) = \\frac{1}{\\bar{p}_P} \\times \\sqrt{ \\frac{1}{N} \\sum_{=1}^N (p_i - \\bar{p}_P)^2 } \\] の不偏推定量ではなく、それより少し大きめの値となってしまいます。 では、割付確率の推定値の変動係数\\(\\mathrm{CV}(\\hat{p})\\)は、真の割付確率の変動係数\\(\\mathrm{CV}(p)\\)と比べてどの程度 大きくなっているのでしょうか。 割付確率の推定値の変動係数の二乗 \\[ (\\mathrm{CV}(\\hat{p}))^2 = \\frac{1}{\\bar{\\hat{p}}_P^2} \\times \\frac{1}{N} \\sum_{=1}^N (\\hat{p}_i - \\bar{\\hat{p}}_P)^2 \\] について考えましょう。割付確率\\(p_i\\)の推定量\\(\\hat{p}_i\\)が不偏推定量に近く、かつ \\(n\\)がある程度大きければ、\\(\\bar{\\hat{p}}_P\\)は\\(\\bar{p}_P\\)に近いと考えられますから \\[ \\approx \\frac{1}{\\bar{p}_P^2} \\times \\frac{1}{N} \\sum_{=1}^N (\\hat{p}_i - \\bar{p}_P)^2 = \\frac{1}{N \\bar{p}_P^2} \\sum_{=1}^N ( (\\hat{p}_i - p_i) + (p_i - \\bar{p}_P) )^2 \\] と近似できます。\\(\\hat{p}_i\\)の推定誤差\\(\\hat{p}_i - p_i\\)が\\(p_i\\)と独立だと仮定すれば \\[ = \\frac{1}{N \\bar{p}_P^2} \\left( \\sum_{=1}^N (\\hat{p}_i - p_i)^2 + \\sum_{=1}^N (p_i - \\bar{p}_P)^2 \\right) = \\frac{1}{N \\bar{p}_P^2} \\sum_{=1}^N (\\hat{p}_i - p_i)^2 + (\\mathrm{CV}(p))^2\\] つまり、おおまかにいえば、割付確率の推定値の変動係数の二乗\\((\\mathrm{CV}(\\hat{p}))^2\\)は、真の割付確率の変動係数の二乗\\((\\mathrm{CV}(p))^2\\)と比べて、割付確率の推定値の誤差の分散 \\(\\frac{1}{N} \\sum_{=1}^n (\\hat{p}_i - p_i)^2\\) を 真の割付確率の平均の二乗\\(\\bar{p}_P^2\\)で割った量だけ大きくなっているはずです。 そこでrSurveyAssignパッケージは、\\(\\mathrm{CV}(\\hat{p})\\)を小さめに修正した、割付確率の変動係数の推定値 \\(\\hat{\\mathrm{CV}}(p)\\)を提供します。 この指標は下式に従って求めています。\\(\\hat{V}_i\\)は\\(E[(\\hat{p}_i - p_i)^2]\\)の推定値と捉えることができるので、 \\[ \\hat{\\mathrm{CV}}(p) = \\sqrt{ (\\mathrm{CV}(\\hat{p}))^2 - \\frac{\\frac{1}{N} \\sum_{=1}^N \\hat{V}_i}{\\bar{\\hat{p}}_P^2}} \\]","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"hatmathrmdeff-デザイン効果の推定値","dir":"Articles","previous_headings":"3. 割付バイアスを評価するための指標","what":"3.3 \\(\\hat{\\mathrm{Deff}}\\): デザイン効果の推定値","title":"3. How to estimate bias","text":"各対象者の各カテゴリ・スロットへの割付確率\\(p_i\\)が既知ならば、その逆数\\(1/p_i\\)をウェイトとして集計することで、集計値における割付バイアスを取り除くことができます。そこでこのパッケージでは、すでに行った調査についてウェイトを算出する機能を提供しています。詳細は“4. compute survey weights”をご覧ください。 その反面、一般に、ウェイトを用いて集計すると集計値の分散は拡大します。その拡大の程度は、ウェイトの相対的な分散が大きいときに大きくなります。 デザイン効果とは、調査データ分析において用いられている概念で、ウェイトを用いた集計における集計値の分散の拡大を、ウェイトの相対的な分散という観点から表現したものです。 多くの場合、デザイン効果は次のように求められます。対象者\\(\\)に与えられるウェイトを\\(w_i=1/p_i\\)、対象者を通じたその平均を\\(\\bar{w} = \\frac{1}{n} \\sum_{=1}^n w_i\\)とします。 \\[ \\mathrm{Deff} = 1 + \\left( \\frac{1}{\\bar{w}^2} \\times \\frac{1}{n} \\sum_{=1}^n (w_i - \\bar{w})^2 \\right)\\] さて、このパッケージが想定する調査手続きでは、割付確率\\(p_i\\)は未知であり、その推定量\\(\\hat{p}_i\\)しか手に入りません。従ってデザイン効果もわかりません。 そこでrSurveyAssignパッケージは、デザイン効果の推定値 \\(\\hat{\\mathrm{Deff}}\\) を提供しています。 この指標は次のように求めています。 \\[ \\hat{w}_i = 1 / \\hat{p}_i\\] \\[ \\bar{\\hat{w}}_S = \\frac{1}{n} \\sum_{=1}^n \\hat{w}_i\\] \\[ \\hat{\\mathrm{Deff}} = 1 + \\left( \\frac{1}{\\bar{\\hat{w}}_S^2} \\times \\frac{1}{n} \\sum_{=1}^n (\\hat{w}_i - \\bar{\\hat{w}}_S)^2 \\right) \\] つまり、\\(\\mathrm{Deff}\\)の式におけるウェイト\\(w_i = 1/p_i\\)を、推定されたウェイト\\(\\hat{w}_i = 1/\\hat{p}_i\\)に置き換えたものです。 以下の点に注意してください。 この指標は、\\(\\mathrm{CV}(\\hat{p})\\)や\\(\\hat{\\mathrm{CV}}(p)\\)とは異なり、割付可能対象者ではなく割り付けられた対象者についての指標です。ウェイトを用いた集計において何が起きるかを表す指標だからです。 \\(\\hat{p}_i\\)の推定誤差については考慮していません。推定誤差があろうとも、集計のウェイトとしては\\(\\hat{w}_i = 1/\\hat{p}_i\\)を用いざるを得ないからです。そのため、たとえ真の\\(p_i\\)にばらつきがなくても、この指標は1より大きくなります。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"hatmathrmess-実質標本サイズの推定値","dir":"Articles","previous_headings":"3. 割付バイアスを評価するための指標","what":"3.4 \\(\\hat{\\mathrm{ESS}}\\): 実質標本サイズの推定値","title":"3. How to estimate bias","text":"一般に、標本サイズが少ないとき、集計値の分散は大きくなります。また、ウェイトを用いた集計では、ウェイトの相対的な分散が大きいとき、集計値の分散は大きくなります。つまり、ウェイトを用いた集計は、あたかも標本サイズを減らしたかのような集計になるわけです。 標本サイズをデザイン効果で割った値は実質標本サイズと呼ばれています。 たとえば、実質標本サイズが50であるとしましょう。これは、「ウェイトを用いた集計値は、あたかもウェイトを用いない標本サイズ50の集計値のような分散を持っている」ということを表しています。私たちはふつう、ウェイトの相対的な分散やデザイン効果について直観的に解釈できませんが、標本サイズについてはなんらかの直観を持っていることが多いでしょう。いま、ウェイトが不要であるような調査を実現できるとして、その調査における標本サイズが100以下であったら「標本サイズが小さすぎる、集計値の精度は低すぎるかもしれない」と感じるとしましょう。この場合、実質標本サイズが100以下であったら「ウェイトを用いた集計値の精度は低すぎるかもしれない」と考えることができるわけです。 rSurveyAssignパッケージは、下式に従って求めた実質標本サイズの推定値を提供します。 \\[ \\hat{\\mathrm{ESS}} = \\frac{n}{\\hat{\\mathrm{Deff}}}\\] デザイン効果の推定値\\(\\hat{\\mathrm{Deff}}\\)と同じく、この指標も、割付可能対象者ではなく割り付けられた対象者についての指標です。また、割付確率の推定値\\(\\hat{p}_i\\)が含む推定誤差については考慮していません。そのため、たとえ真の割付確率\\(p_i\\)にばらつきがなくても、この指標は割り付けられた対象者数\\(n\\)より小さくなります。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"mathrmcovhatqr-スケーリングした割付確率の推定値と割付可能レシオとの共分散の推定値","dir":"Articles","previous_headings":"3. 割付バイアスを評価するための指標","what":"3.5 \\(\\mathrm{Cov}(\\hat{q},r)\\): スケーリングした割付確率の推定値と割付可能レシオとの共分散の推定値","title":"3. How to estimate bias","text":"上記に述べた4つの指標は、割付確率ないしウェイトのばらつきに注目した指標でした。 しかし、1.3で述べたように、たとえ割付確率に大きなばらつきがあるとしても それが「他のカテゴリ・スロットへの割付可能性」と関連を持っていないならば、 割付バイアスは生じないはずです。 そこで、割付確率と「他のカテゴリ・スロットへの割付可能性」との関連を定量化する方法について 考えてみます。そのためにはまず、「他のカテゴリ・スロットへの割付可能性」を定量化する 必要があります。 そこで、各対象者について「割付可能レシオ」を定義します。割付可能レシオは、「他のカテゴリ・スロットへの割付可能性」の高さをおおまかに表す変数です。 全カテゴリに占める割付可能カテゴリの割合。たとえば、カテゴリ数3の調査で、対象者\\(\\)が2個のカテゴリに対して割付可能であるとき、\\(r^c_i = 2/3\\) とします。 カテゴリ\\(j\\)の全スロットに占める割付可能スロットの割合。たとえば、カテゴリ\\(j\\)のスロット数が\\(10\\)であるとして、対象者\\(\\)がそのうち3個のスロットに対して割付可能であるとき、\\(r^{(s)}_{ij} = 3/10\\) とします。 この変数と、スケーリングした割付確率の推定値 \\(\\hat{q}_i\\)との共分散\\(\\mathrm{Cov}(\\hat{q},r)\\)を求め、割付バイアスの評価指標とします。 この指標は以下の式に従って求めます。カテゴリにおいては \\[ \\bar{r}^{(c)}_P = \\frac{1}{N} \\sum_{=1}^N r^{(c)}_i\\] \\[ \\mathrm{Cov}(\\hat{q},r) = \\frac{1}{N} \\sum_{=1}^N (\\hat{q}_i - \\bar{\\hat{q}}_P) (r^{(c)}_i - \\bar{r}^{(c)}_P) \\] カテゴリ\\(j\\)のスロットにおいては \\[ \\bar{r}^{(s)}_{j,P} = \\frac{1}{N} \\sum_{=1}^N r^{(s)}_{ij}\\] \\[ \\mathrm{Cov}(\\hat{q},r) = \\frac{1}{N} \\sum_{=1}^N (\\hat{q}_i - \\bar{\\hat{q}}_P) (r^{(s)}_{ij} - \\bar{r}^{(s)}_{j,P}) \\] この指標は、「割付可能レシオ」という変数のおおまかさを脇におけば、割付バイアスを評価する5つの 指標の中でもっとも適切な指標だといえます。割付確率ではなく、割付確率と「他のカテゴリ・スロットへの割付可能性」との関連に注目しているからです。 また、次のようにとらえることもできます。 いま、あるカテゴリないしスロットに割付可能である人々の割付可能レシオそのものに関心があるとしましょう。たとえば、「このブランドを知っている人々が、市場に存在するブランド群のうち何割を知っているか」に関心がある、というような場面を想像してください。 割付可能レシオ(\\(r^{(c)}_i\\)ないし\\(r^{(s)}_{ij}\\))を\\(r_i\\)と略記します。推定したい対象は、当該カテゴリないしスロットに割付可能な人々を通じた\\(r_i\\)の平均 \\[ \\bar{r}_P = \\frac{1}{N} \\sum_{=1}^N r_i\\] です。しかし、私たちが知ることができるのは、当該カテゴリないしスロットに割り付けられた人々の\\(r_i\\)の平均 \\[ \\bar{r}_S = \\frac{1}{n} \\sum_{=1}^n r_i\\] です。多くの割付手法において、割付可能レシオが高い人ほど、当該カテゴリないしスロットへの割付確率が低くなりますから、\\(\\bar{r}_S\\)は\\(\\bar{r}_P\\)よりも低めになります。すなわち、割付バイアスのせいで\\(\\bar{r}_S\\)は低めになるわけです。 すでに述べたように、割付バイアスとは、割付可能対象者において平均1になるようにスケーリングした割付確率\\(q_i\\)と、関心ある変数との共分散でした。いっぽう\\(\\mathrm{Cov}(\\hat{q},r)\\)は、\\(q_i\\)の推定値\\(\\hat{q}_i\\)と割付可能レシオ\\(r_i\\)との共分散です。つまり\\(\\mathrm{Cov}(\\hat{q},r)\\)は、関心ある変数が割付可能レシオ\\(r_i\\) であるときの割付バイアスそのものの推定値だと捉えることもできます。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"データの準備","dir":"Articles","previous_headings":"","what":"4. データの準備","title":"3. How to estimate bias","text":"では、rSurveyAssignパッケージによるバイアス評価の手順について説明しましょう。 母集団を表現するデータを用意し、popdataクラスのオブジェクトに変換します。 “forecast sample size”を参照して下さい。 割付のセッティングを指定します。","code":"library(rSurveyAssign)  # 母集団オブジェクトの作成 data(popdata, package = \"rSurveyAssign\") mbCat <- as.matrix(popdata[, paste0(\"bCat_\", 1:3)]) lSlot <- list(     as.matrix(popdata[, paste0(\"bSlot_1_\", 1:10)]),     as.matrix(popdata[, paste0(\"bSlot_2_\", 1:10)]),      as.matrix(popdata[, paste0(\"bSlot_3_\", 1:10)])   ) lPop <- makePop(mbCAT = mbCat, lSLOT = lSlot) #> [makePop] assign colnames to lSLOT ... #> [makePop] # of categories: 3  #> [makePop] # of slots: 10,10,10  #> [makePop] # of members: 10000  #> [makePop] # of member-category pairs which are assignable: 26488 (8829.3/category)  #> [makePop] # of member-slot pairs which are assignable: 58836 (1961.2/slot) # 割付のセッティング lSetting1 <- makeSetting(   lSLOT_REQUEST = lapply(lSlot, function(mbSlot) rep(100, ncol(mbSlot))),    nCAT_MAX      = 1,    sCAT_TYPE     = 'adaptive',    sCAT_FILTER   = 'open',    sCAT_ORDER    = 'shortnum',    sCAT_EXCLUDE  = 'allclosed',   nSLOT_MAX     = 2,    sSLOT_TYPE    = 'adaptive',    sSLOT_FILTER  = 'open',    sSLOT_ORDER   = 'shortnum',    sSLOT_EXCLUDE = 'allclosed' ) #> [makeSetting] assign names to lSLOT_REQUEST ..."},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"割付再割付シミュレーション","dir":"Articles","previous_headings":"","what":"5. 割付・再割付シミュレーション","title":"3. How to estimate bias","text":"割付確率を推定するためのシミュレーションを行います。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"単一の試行","dir":"Articles","previous_headings":"5. 割付・再割付シミュレーション","what":"5.1 単一の試行","title":"3. How to estimate bias","text":"まず、割付試行を1回だけ行ってみましょう。時間を節約するため、再割付試行は10回とします。 シミュレーションの結果をみてみましょう。 simBiasの返し値は3つの要素からなるリストです。 要素dfSubjectは割付試行の結果を表しています(再割付試行ではありません)。 この割付試行では、対象者1として母集団メンバー6779が抽出され、カテゴリ1に割り付けられ、カテゴリ1のスロット9,6に割り付けられました。 要素dfStat_Catは、再割付試行の結果のうち、 カテゴリへの再割付の結果を表しています。 10回の再割付試行を通じて、対象者1(正確には、対象者1に相当する割付可能性を持っている人)は延べ6回抽出されました。そのうちカテゴリ1への割付が生じたのは4回でした。つまり、この割付試行における対象者1のカテゴリ1への割付確率はおよそ4/6=0.67であったと推定されます。 要素dfStat_Slotは、再割付試行の結果のうち、スロットへの再割付の結果を表しています。 10回の再割付試行を通じて、対象者1(正確には、対象者1に相当する割付可能性を持っている人)は延べ6回抽出され、そのうちカテゴリ1のスロット6への割付が生じたのは0回でした。割付確率はおよそ0/6 = 0.00であったと推定されます。実際には割付確率は0ではないので(もしそうであれば割付試行において割付が起きなかったはずです)、0に近い値であるということを意味しています。","code":"set.seed(123)  # 結果を再現するために乱数のシードを設定している。通常は設定不要 lResult1 <- simBias (   lPOP        = lPop,    lSETTING    = lSetting1,    nNUMRETRIAL = 10,   sVERBOSE    = \"simple\" ) #> [simBias] nTrial: 1 ; extract: 5843 ; 2.29 sec. head(lResult1$dfSubject) #> # A tibble: 6 × 8 #>   sRowname nPerson nCat1  nCat nSlot1 nSlot2 nTrial nSubject #>   <chr>      <int> <int> <int>  <int>  <int>  <int>    <int> #> 1 1           6779     1     1      9      6      1        1 #> 2 2           5953     2    NA     NA     NA      1        2 #> 3 3           3232     3    NA     NA     NA      1        3 #> 4 4           1226     2     2      7      5      1        4 #> 5 5           5372     1     1      7     10      1        5 #> 6 6           7652     2     2      2      1      1        6 head(lResult1$dfStat_Cat) #> # A tibble: 6 × 11 #>   nSubject  nCat bAssign nCount_SubjectCat nCount_Subject nBlock nBlockSize #>      <int> <int>   <dbl>             <int>          <int>  <int>      <dbl> #> 1        1     1       1                 4              6      1         10 #> 2        1     2       0                 2              6      1         10 #> 3        1     3       0                 0              6      1         10 #> 4        2     1       0                 8             16      1         10 #> 5        2     2       1                 3             16      1         10 #> 6        2     3       0                 5             16      1         10 #> # ℹ 4 more variables: nTrial <int>, sRowname <chr>, nPerson <int>, #> #   gAssignability_Cat <dbl> head(lResult1$dfStat_Slot) #> # A tibble: 6 × 12 #>   nSubject  nCat nSlot bAssign nCount_SubjectSlot nCount_Subject nBlock #>      <int> <int> <int>   <dbl>              <int>          <int>  <int> #> 1        1     1     6       1                  0              6      1 #> 2        1     1     9       1                  0              6      1 #> 3        4     1     2       0                  0              9      1 #> 4        4     1     3       0                  0              9      1 #> 5        4     1     4       0                  0              9      1 #> 6        4     1     6       0                  0              9      1 #> # ℹ 5 more variables: nBlockSize <dbl>, nTrial <int>, sRowname <chr>, #> #   nPerson <int>, gAssignability_Slot <dbl>"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"多数の試行の実行と保存","dir":"Articles","previous_headings":"5. 割付・再割付シミュレーション","what":"5.2 多数の試行の実行と保存","title":"3. How to estimate bias","text":"上の例では、割付試行を1回、再割付試行を10回行い、 シミュレーションの結果をデータフレームのリストとして取得しました。 バイアスを評価するためには、十分な数の再割付試行を繰り返す必要があります。 そこで今度は、割付試行を10試行、再割付試行を割付試行あたり1000試行繰り返してみましょう。 シミュレーションの結果はサイズが大きいので、SQLiteデータベース上に 保存したほうがよいでしょう。 以下の例では、SQLiteデータベースファイルとして..\\tools\\rSurveyAssign_vignette_bias_1.sqliteを 作成しています。実際には、適切なフォルダとファイル名を指定してください。また、 データベースファイルは、必要がなくなったら自分で消してください。 実行時間を短くするため、並列処理を行うことにします。引数bPARALLELにTRUEを指定します。 並列処理を行う場合、各試行についてのメッセージは画面に表示されません。 そこでログファイルを作成することにします。 実行に長い時間がかかる場合は、ログファイルを監視すると、 いま何試行まで進んでいるかわかり、少しだけ心が癒されるでしょう。 下の例では、ログファイルをC:/work/simBias.logとしています。 RStudioを使っているなら、Terminalウィンドウでtail -F C:/work/simBias.logを 実行すると、ログファイルを監視できます。","code":"## 都合によりコメントアウトしています # set.seed(123)  # 結果を再現するために乱数のシードを設定している。通常は設定不要 # simBias ( #   lPOP        = lPop,  #   lSETTING    = lSetting1,  #   sDBPATH     = \"..\\tools\\rSurveyAssign_vignette_bias_1.sqlite\", #   nNUMTRIAL   = 10, #   nNUMRETRIAL = 1000, #   bAPPEND     = FALSE,  #   bPARALLEL   = TRUE, #   sLOGFILE    = \"c:/work/simBias.log\" # )"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"割付バイアスの評価","dir":"Articles","previous_headings":"","what":"6. 割付バイアスの評価","title":"3. How to estimate bias","text":"では、割付バイアスを評価してみましょう。関数getBiasを使います。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"カテゴリごとのバイアス","dir":"Articles","previous_headings":"6. 割付バイアスの評価","what":"6.1 カテゴリごとのバイアス","title":"3. How to estimate bias","text":"関数getSizeの引数sTYPEをcatとすると、 各試行での各カテゴリごとの割付バイアスを評価することができます。 getBiasの返し値はデータフレームです。内容をみてみましょう。 行は各割付試行における各カテゴリを表しています。 nNumAssignable: 割付可能であった対象者数。試行1ではカテゴリ1に割付可能な対象者が5452人いました。 nNumAssign: 割り付けられた対象者数。試行1ではカテゴリ1に2060人が割り付けられました。 gCVHatP: 割付確率の推定値の変動係数\\(\\mathrm{CV}(\\hat{p})\\)。この値が大きいほど、割付バイアスが大きくなる見込みが高いと考えられます。 gHatCVP: 割付確率の変動係数の推定値\\(\\hat{\\mathrm{CV}}(p)\\)。この値が大きいほど、割付バイアスが大きくなる見込みが高いと考えられます。 gHatDeff: デザイン効果の推定値\\(\\hat{\\mathrm{Deff}}\\)。下限は1であり、割付バイアスが大きいと思われるときに大きくなります。 gHatESS: 実質標本サイズの推定値\\(\\hat{\\mathrm{ESS}}\\)。上限は割り付けられた対象者数であり、割付バイアスが大きいと思われる時に小さくなります。 gCovHatQR: スケーリングした割付確率の推定値と割付可能レシオとの共分散の推定値\\(\\mathrm{Cov}(\\hat{q}, r)\\)。通常は負の値となり、割付バイアスが大きいほど0から離れます。 gBarR_P, gBarR_S: 当該カテゴリに割付可能であった人における割付可能レシオの平均と、当該カテゴリに割り付けられた人における割付可能レシオの平均。通常は後者のほうが小さくなります。gCovHatQRはこの2つの値の差の期待値だと考えることもできます。","code":"dfResult1_c <- getBias(sTYPE = \"cat\", sDBPATH = \"../tools/rSurveyAssign_vignette_bias_1.sqlite\") head(dfResult1_c) #> # A tibble: 6 × 11 #>   nTrial  nCat nNumAssignable nNumAssign gCVHatP gHatCVP gHatDeff gHatESS #>    <int> <int>          <int>      <int>   <dbl>   <dbl>    <dbl>   <dbl> #> 1      1     1           5452       2060   0.334   0.331     1.06   1939. #> 2      1     2           5389       1956   0.149   0.144     1.02   1927. #> 3      1     3           4652       1542   0.124   0.116     1.01   1529. #> 4      2     1           5469       2042   0.354   0.351     1.07   1914. #> 5      2     2           5409       2109   0.162   0.157     1.02   2074. #> 6      2     3           4680       1453   0.164   0.158     1.01   1435. #> # ℹ 3 more variables: gCovHatQR <dbl>, gBarR_P <dbl>, gBarR_S <dbl>"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"スロットごとのバイアス","dir":"Articles","previous_headings":"6. 割付バイアスの評価","what":"6.2 スロットごとのバイアス","title":"3. How to estimate bias","text":"関数getSizeの引数sTYPEをslotとすると、 各試行での各スロットごとの割付バイアスを評価することができます。 getBiasの返し値はデータフレームです。内容をみてみましょう。 行は各割付試行における各カテゴリの各スロットを表しています。各変数の意味はカテゴリの場合と同様です。","code":"dfResult1_s <- getBias(sTYPE = \"slot\", sDBPATH = \"../tools/rSurveyAssign_vignette_bias_1.sqlite\") head(dfResult1_s) #> # A tibble: 6 × 12 #>   nTrial  nCat nSlot nNumAssignable nNumAssign gCVHatP gHatCVP gHatDeff gHatESS #>    <int> <int> <int>          <int>      <int>   <dbl>   <dbl>    <dbl>   <dbl> #> 1      1     1     1           1723        100   1.37    1.36     10.6     9.39 #> 2      1     1     2            831        100   0.572   0.566     1.71   58.4  #> 3      1     1     3           1183        100   0.820   0.814     1.51   66.1  #> 4      1     1     4           1273        100   0.874   0.867     4.33   23.1  #> 5      1     1     5            271        100   0.159   0.154     1.02   98.5  #> 6      1     1     6           1212        100   0.809   0.802     1.96   51.0  #> # ℹ 3 more variables: gCovHatQR <dbl>, gBarR_P <dbl>, gBarR_S <dbl>"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"分析例-割付方法の間の比較","dir":"Articles","previous_headings":"","what":"7. 分析例: 割付方法の間の比較","title":"3. How to estimate bias","text":"こんどは、別の割付方法を試してみます。 スロットについての割付バイアスを調べてみましょう。 どうやら、この割付方法では割付バイアスがきわめて小さいようです。先ほどの割付方法と 比べてみましょう。指標として\\(\\mathrm{Cov}(\\hat{q}, r)\\)を使います。  さきほどの割付方法と異なり、指標の値がほぼ0になっています。 なお、この割付方法をよく見ると、割付カテゴリの最大数が1であり、カテゴリ割付とスロット割付の両方で(nonadaptive, open, shortnum, none)を用いています。1.4の最後に述べたように、この割付方法は、 割付バイアスを生まない数少ない割付方法のうちのひとつです。 上の結果はそのことをシミュレーションによって裏付けています。","code":"# 割付のセッティング lSetting2 <- makeSetting(   lSLOT_REQUEST = lapply(lSlot, function(mbSlot) rep(100, ncol(mbSlot))),    nCAT_MAX      = 1,    sCAT_TYPE     = 'nonadaptive',    sCAT_FILTER   = 'open',    sCAT_ORDER    = 'shortnum',    sCAT_EXCLUDE  = 'none',   nSLOT_MAX     = 2,    sSLOT_TYPE    = 'nonadaptive',    sSLOT_FILTER  = 'open',    sSLOT_ORDER   = 'shortnum',    sSLOT_EXCLUDE = 'none' ) #> [makeSetting] assign names to lSLOT_REQUEST ... set.seed(123)  # 結果を再現するために乱数のシードを設定している。通常は設定不要 ## 都合によりコメントアウトしています # simBias ( #   lPOP       = lPop,  #   lSETTING   = lSetting2,  #   sDBPATH    = \"../tools/rSurveyAssign_vignette_bias_2.sqlite\", #   nNUMTRIAL  = 10, #   nNUMRETRIAL = 500, #   bAPPEND    = FALSE,  #   bPARALLEL  = TRUE, #   sLOGFILE   = \"c:/work/simWeight.log\" # ) dfResult2_s <- getBias(sTYPE = \"slot\", sDBPATH = \"../tools/rSurveyAssign_vignette_bias_2.sqlite\") head(dfResult2_s) #> # A tibble: 6 × 12 #>   nTrial  nCat nSlot nNumAssignable nNumAssign gCVHatP gHatCVP gHatDeff gHatESS #>    <int> <int> <int>          <int>      <int>   <dbl>   <dbl>    <dbl>   <dbl> #> 1      1     1     1           3496        100  0.258   0          1.11    90.5 #> 2      1     1     2           1654        100  0.178   0.0286     1.05    95.5 #> 3      1     1     3           2363        100  0.209   0          1.05    95.2 #> 4      1     1     4           2516        100  0.218   0          1.07    93.9 #> 5      1     1     5            565        100  0.0972  0.0129     1.01    99.0 #> 6      1     1     6           2352        100  0.216   0.0421     1.07    93.8 #> # ℹ 3 more variables: gCovHatQR <dbl>, gBarR_P <dbl>, gBarR_S <dbl> dfPlot <- dplyr::bind_rows(   dfResult1_s |> dplyr::mutate(nMethod = 1),   dfResult2_s |> dplyr::mutate(nMethod = 2) ) |>   dplyr::group_by(nMethod, nCat, nSlot) |>   dplyr::summarize(gMeanCovHatQR = mean(gCovHatQR)) |>   dplyr::ungroup() #> `summarise()` has grouped output by 'nMethod', 'nCat'. You can override using #> the `.groups` argument.  dfX <- dfPlot |>   dplyr::distinct(nCat, nSlot) |>   dplyr::arrange(nCat, nSlot) |>   dplyr::mutate(nX = dplyr::row_number()) |>   dplyr::arrange(-nX) |>   dplyr::mutate(fX = factor(nX, levels = nX, labels = paste0(\"Cat\", nCat, \"_Slot\", nSlot)))  dfPlot <- dfPlot |>   dplyr::left_join(dfX, by = c(\"nCat\", \"nSlot\")) |>   dplyr::mutate(fMethod = factor(nMethod, levels = 1:2, labels = c(\"方法1\", \"方法2\")))  g <- ggplot2::ggplot(   data = dfPlot,    ggplot2::aes(x = fX, y = gMeanCovHatQR, group = fMethod, color = fMethod) ) g <- g + ggplot2::geom_point() g <- g + ggplot2::geom_line() g <- g + ggplot2::labs(x = \"スロット\", y = \"割付バイアスの強さ (Cov(hat{q},r)の平均)\", color = \"割付方法\") g <- g + ggplot2::coord_flip() g <- g + ggplot2::theme_bw() print(g)"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_bias.html","id":"まとめ-割付バイアス評価に関連する関数","dir":"Articles","previous_headings":"","what":"8. まとめ: 割付バイアス評価に関連する関数","title":"3. How to estimate bias","text":"rSurveyAssignパッケージが提供する関数のうち、割付バイアスの評価に関連する関数は以下の通りです。 makePop: 母集団データを作成する makeSetting: 割付のセッティングを作成する simBias: シミュレーションを実行し結果をデータベースに格納する getBias: データベースに格納されたシミュレーション結果を集計して取り出す countBias: データベースに格納されたシミュレーション結果の試行数を調べる","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_size.html","id":"標本サイズ推定の方法","dir":"Articles","previous_headings":"","what":"1. 標本サイズ推定の方法","title":"2. How to forecast sample size","text":"このパッケージでは、以下の方法によって、調査に必要な対象者数を調べます。 架空の母集団データを用意します。 母集団データから対象者を復元抽出し、指定した方法でカテゴリ・スロットへの割付を行い、各スロットに割り付けられた対象者数が目標対象者数に到達したら終了します。これを割付試行と呼びます。 割付試行を十分な回数繰り返し、各試行において必要であった対象者数の分布を調べます。","code":""},{"path":[]},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_size.html","id":"母集団データ","dir":"Articles","previous_headings":"2. データの準備","what":"2.1 母集団データ","title":"2. How to forecast sample size","text":"まず、母集団を表現するデータを用意します。 このデータは、母集団を有限集団として近似的に表現するものです。母集団メンバーそれぞれ について、カテゴリ・スロットへの割付可能性を記述します。 現バージョンのrSurveyAssignパッケージは、母集団データをつくる機能は提供していません。 過去の調査結果や既存の知識に基づき、なんとかして作ってください。 以下では、母集団メンバーを\\((=1,\\ldots,)\\), カテゴリを\\(j(=1,\\ldots,J)\\), カテゴリ\\(j\\)のスロットを\\(k (=1,\\ldots,K_j)\\)と表記します。 データのサイズ(\\(, J, K_1,...,K_J\\))に制限はありません。母集団のメンバー数 \\(\\) はできるだけ大きくしたほうがよいでしょう。 母集団データの例としてpopdataが用意されています。 popdataは、サイズ10000の有限集団のデータを持つデータフレームで、 カテゴリ数は3, スロット数は 各カテゴリについて10です(すなわち、\\(=10000, J=3, K_1=K_2=K_3=10\\))。 内容をみてみましょう。 行は母集団のメンバーを表しています。 変数bCat_()は、カテゴリ\\(\\)への割付可能性を表しています。 たとえば母集団メンバー1は、カテゴリ1,2,3に割付可能です。母集団メンバー4は、どのカテゴリにも割付不能です。 変数bSlot_()_(j)は、カテゴリ\\(\\)のスロット\\(j\\)の割付可能性を表しています。 たとえば母集団メンバー1は、カテゴリ1のスロットのうち、スロット1, 4, 8, 9, 20に対して 割付可能です。","code":"library(rSurveyAssign) data(popdata, package = \"rSurveyAssign\") head(popdata) #>   nID bCat_1 bCat_2 bCat_3 bSlot_1_1 bSlot_1_2 bSlot_1_3 bSlot_1_4 bSlot_1_5 #> 1   1      1      1      1         1         0         0         1         0 #> 2   2      1      1      1         1         1         1         1         0 #> 3   3      1      1      1         0         0         0         0         0 #> 4   4      0      0      0        NA        NA        NA        NA        NA #> 5   5      1      1      1         0         0         0         0         0 #> 6   6      1      1      1         0         0         0         0         0 #>   bSlot_1_6 bSlot_1_7 bSlot_1_8 bSlot_1_9 bSlot_1_10 bSlot_2_1 bSlot_2_2 #> 1         0         0         1         1          1         1         1 #> 2         0         0         0         1          0         1         0 #> 3         0         0         0         0          0         0         0 #> 4        NA        NA        NA        NA         NA        NA        NA #> 5         1         0         0         0          0         0         0 #> 6         0         0         0         0          0         0         0 #>   bSlot_2_3 bSlot_2_4 bSlot_2_5 bSlot_2_6 bSlot_2_7 bSlot_2_8 bSlot_2_9 #> 1         0         0         0         0         0         0         0 #> 2         1         0         1         0         0         0         0 #> 3         0         0         0         0         0         0         0 #> 4        NA        NA        NA        NA        NA        NA        NA #> 5         0         0         0         0         0         0         0 #> 6         0         0         0         0         0         0         0 #>   bSlot_2_10 bSlot_3_1 bSlot_3_2 bSlot_3_3 bSlot_3_4 bSlot_3_5 bSlot_3_6 #> 1          0         1         0         0         0         1         0 #> 2          0         0         0         0         0         0         0 #> 3          0         0         0         0         0         0         0 #> 4         NA        NA        NA        NA        NA        NA        NA #> 5          0         0         0         0         0         0         0 #> 6          0         0         0         0         0         0         0 #>   bSlot_3_7 bSlot_3_8 bSlot_3_9 bSlot_3_10 #> 1         0         0         1          0 #> 2         0         0         0          0 #> 3         0         0         0          0 #> 4        NA        NA        NA         NA #> 5         0         0         0          0 #> 6         0         0         0          0"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_size.html","id":"popdataオブジェクトの生成","dir":"Articles","previous_headings":"2. データの準備","what":"2.2 popdataオブジェクトの生成","title":"2. How to forecast sample size","text":"次に、母集団データをrSurveyAssignパッケージが扱える形式に変換します。 rSurveyAssignパッケージは、母集団データを表すクラスpopdataを用意しています。 popdataクラスのオブジェクトは、関数makePopで作成します。 関数makePopの引数は次の2つです。 \\(\\)行\\(J\\)列の整数行列。 \\(\\)行\\(j\\)列の値は、「母集団メンバー\\(\\)にとってカテゴリ\\(j\\)は割付可能か」 を表し、\\(0\\)は割付不能, \\(1\\)は割付可能を表します。 欠損は許容されません。 \\(J\\)個の要素からなるリスト。\\(j\\)番目の要素は、\\(\\)行\\(K_j\\)列の整数行列。 要素\\(j\\)の行列の\\(\\)行\\(k\\)列の値は、「母集団メンバー\\(\\)にとって カテゴリ\\(j\\)のスロット\\(k\\)は割付可能か」を表し、\\(0\\)は割付不能, \\(1\\)は割付可能を表します。 mbCAT[,j] == 1のとき、lSLOT[[j]][,]}の欠損は許容されません。 すなわち、割付可能カテゴリに属するスロットの割付可能性は指定する必要があります。 mbCAT[,j] == 0のとき、lSLOT[[j]][,]は無視されます。すなわち、割付不能カテゴリに属するスロットの割付可能性は無視されます。従って欠損も許容されます。 では、データ例をpopdataクラスのオブジェクトに変換しましょう。 無事に変換できました。","code":"mbCat <- as.matrix(popdata[, paste0(\"bCat_\", 1:3)]) lSlot <- list(     as.matrix(popdata[, paste0(\"bSlot_1_\", 1:10)]),     as.matrix(popdata[, paste0(\"bSlot_2_\", 1:10)]),      as.matrix(popdata[, paste0(\"bSlot_3_\", 1:10)])   ) lPop <- makePop(mbCAT = mbCat, lSLOT = lSlot) #> [makePop] assign colnames to lSLOT ... #> [makePop] # of categories: 3  #> [makePop] # of slots: 10,10,10  #> [makePop] # of members: 10000  #> [makePop] # of member-category pairs which are assignable: 26488 (8829.3/category)  #> [makePop] # of member-slot pairs which are assignable: 58836 (1961.2/slot)"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_size.html","id":"セッティング","dir":"Articles","previous_headings":"","what":"2. セッティング","title":"2. How to forecast sample size","text":"次に、割付のセッティングを指定します。ここでいうセッティングとは、以下を指します。 各スロットの目標対象者数 対象者に割り付けるカテゴリ数の上限 カテゴリ割付の方法 対象者に割り付けるスロット数の上限 スロット割付の方法 rSurveyAssignパッケージは、セッティングを表すクラスassignsettingを用意しています。 assignsettingクラスのオブジェクトは、関数makeSettingで作成します。 関数makeSettingの引数は次のとおりです。 \\(J\\)個の要素を持つリスト。\\(j\\)番目の要素は長さ\\(K_j\\)の整数ベクトル。 \\(j\\)番目の要素であるベクトルの\\(k\\)番目の要素は、カテゴリ\\(j\\)のスロット\\(k\\)に割り付ける対象者数の下限を表します。 欠損は許容されません。 nCAT_MAX: 割付カテゴリの最大数。 nSLOT_MAX: 割付スロットの最大数。 sCAT_TYPE: カテゴリの割付方法(割付タイプ)。 sCAT_FILTER: カテゴリの割付方法(絞り込み条件)。 sCAT_ORDER: カテゴリの割付方法(順序付け条件)。 sCAT_EXCLUDE: カテゴリの割付方法(除外条件)。 sSLOT_TYPE: スロットの割付方法(割付タイプ)。 sSLOT_FILTER: スロットの割付方法(絞り込み条件)。 sSLOT_ORDER: スロットの割付方法(順序付け条件)。 sSLOT_EXCLUDE: スロットの割付方法(除外条件)。 カテゴリ・スロットの割付方法については “1. assign subjects”を参照して下さい。 では、セッティングを指定しましょう。 すべてのカテゴリのすべてのスロットに、すくなくとも10人の対象者を割り付けることにします。 回答負荷の観点から、ひとりの対象者が割り付けられるカテゴリは2つまで、スロットは2つまでとします。 カテゴリの割付方法(割付タイプ、絞り込み条件、順序付け条件、除外条件)として(adaptive,open,random,none)を使用し、スロットの割付方法として(adaptive,,shortnum,allclosed)を使用します。","code":"lSetting <- makeSetting(   lSLOT_REQUEST = lapply(lSlot, function(mbSlot) rep(10, ncol(mbSlot))),    nCAT_MAX      = 2,    nSLOT_MAX     = 2,   sCAT_TYPE     = 'adaptive',   sCAT_FILTER   = 'open',   sCAT_ORDER    = 'random',   sCAT_EXCLUDE  = 'none',   sSLOT_TYPE    = 'adaptive',   sSLOT_FILTER  = 'all',   sSLOT_ORDER   = 'shortnum',   sSLOT_EXCLUDE = 'allclosed' ) #> [makeSetting] assign names to lSLOT_REQUEST ..."},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_size.html","id":"割付シミュレーション","dir":"Articles","previous_headings":"","what":"3. 割付シミュレーション","title":"2. How to forecast sample size","text":"では、必要な標本サイズを推定するために、シミュレーションを行ってみましょう。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_size.html","id":"単一の試行の実行","dir":"Articles","previous_headings":"3. 割付シミュレーション","what":"3.1 単一の試行の実行","title":"2. How to forecast sample size","text":"まず、割付試行を1回行ってみます。 コンソールに表示されるメッセージは、各試行の結果を表しています。この試行では、母集団から調査対象者を573人抽出したところで、 すべてのスロットにおいて目標対象者数が満たされ、調査が終了しました。 シミュレーションの結果をみてみましょう。 このシミュレーションでは、1人目の調査対象者として母集団メンバー6779が抽出されました。カテゴリ割付の結果、カテゴリ2,3が割り付けられました。スロット割付の結果、カテゴリ3のスロット7が割り付けられました。 このシミュレーションで、各スロットには何人の対象者が割り付けられたのでしょうか？ 調べてみましょう。 上の表は、行がカテゴリ、列がスロット、値がそのスロットに割り付けられた人数を表しています。すべてのスロットに10人以上が割り付けられていることを確認できます。","code":"set.seed(123)  # 結果を再現するために乱数のシードを設定している。通常は設定不要 dfResult <- simSize (   lPOP     = lPop,           # データを指定する   lSETTING = lSetting        # セッティングを指定する ) #> [execTrials] start trials (serial) ... #> [execTrials] nTrial: 1 ; extract: 573 ; 0.04 sec. #> [execTrials] end trials. head(dfResult) #> # A tibble: 6 × 9 #>   sRowname nPerson nCat1 nCat2  nCat nSlot1 nSlot2 nTrial nSubject #>   <chr>      <int> <int> <int> <int>  <int>  <int>  <int>    <int> #> 1 1           6779     3     2     3      7     NA      1        1 #> 2 2           5953     3     1     3      9     10      1        2 #> 3 3           3232     2     1    NA     NA     NA      1        3 #> 4 4           1226     2     1     2      7      5      1        4 #> 5 5           5372     1    NA     1      7     10      1        5 #> 6 6           7652     1     2     1      2      1      1        6 mnIn <- rbind(   as.matrix(dfResult[c(\"nCat\", \"nSlot1\")]),    as.matrix(dfResult[c(\"nCat\", \"nSlot2\")]) ) table(mnIn[,1], mnIn[,2]) #>     #>      1  2  3  4  5  6  7  8  9 10 #>   1 12 11 10 11 10 11 11 11 13 12 #>   2 13 14 13 10 12 13 10 13 10 10 #>   3 11 11 11 11 12 10 11 11 12 11"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_size.html","id":"多くの試行の実行と保存","dir":"Articles","previous_headings":"3. 割付シミュレーション","what":"3.2 多くの試行の実行と保存","title":"2. How to forecast sample size","text":"上の例では、割付試行を1回行い、 シミュレーションの結果をデータフレームとして取得しました。 標本サイズを推定するには、十分な数の割付試行を繰り返す必要があります。 そこで今度は、割付試行を500試行繰り返してみましょう。 シミュレーションの結果はサイズが大きいので、いったんSQLiteデータベース上に 保存したほうがよいでしょう。 以下の例では、 SQLiteデータベースファイルとして、../tools/rSurveyAssign_vignette_size_1.sqliteを 作成します。実際には、適切なフォルダとファイル名を指定してください。また、 データベースファイルは必要がなくなったら自分で消してください。 実行時間を短くするため、並列処理を行うことにします。引数bPARALLELにTRUEを指定します。 並列処理を行う場合、各試行についてのメッセージは画面に表示されません。 そこでログファイルを作成することにします。 実行に長い時間がかかる場合は、ログファイルを監視すると、 いま何試行まで進んでいるかわかり、少しだけ心が癒されるでしょう。 下の例では、ログファイルをC:/work/simSize.logとしています。 RStudioを使っているなら、Terminalウィンドウでtail -F C:/work/simSize.logを 実行すると、ログファイルを監視できます。 関数getSize_rawで、 データベースに格納された結果をそのまま取り出すことができます。 なお、これまでにデータベースに格納した試行数は、格納した際に表示されますが、 関数countSizeで調べることもできます。 この例では、500試行の実行に数秒しかかかりませんが、 もっと長い時間がかかることもあるでしょう。そうした場合に、 試行数nNUMTRIALを大きくすると、 simSizeの実行にとても長い時間がかかることになり、不便です。 このような場合は、nNUMTRIALはあまり時間がかからない程度の大きさにとどめ、 simSizeを気が向いたときに繰り返し実行して、結果を少しずつデータベースに 蓄積していくのが良いでしょう。 その際は、初回実行時には引数bAPPENDをFALSEとし、 二回目以降の実行時にはTRUEとしてください。また、引数lPOP, lSETTINGに与える値を途中で変えないように注意して下さい(少しでも変えるとエラーとなります)。","code":"set.seed(123)  # 結果を再現するために乱数のシードを設定している。通常は設定不要 ## 都合によりコメントアウトしています # dfResult <- simSize ( #   lPOP      =  lPop,           #   lSETTING  = lSetting,  #   nNUMTRIAL = 500, #   bPARALLEL = TRUE, #   sLOGFILE  = \"c:/work/simSize.log\", #   sDBPATH   = \"../tools/rSurveyAssign_vignette_size_1.sqlite\",  #   bAPPEND   = FALSE # すでにデータベースが存在する場合は上書きする # ) head(getSize_raw(\"../tools/rSurveyAssign_vignette_size_1.sqlite\", nTRIAL = 1)) #> # A tibble: 6 × 9 #>   sRowname nPerson nCat1 nCat2  nCat nSlot1 nSlot2 nTrial nSubject #>   <chr>      <int> <int> <int> <int>  <int>  <int>  <int>    <int> #> 1 1           8470     2     1     2      1      2      1        1 #> 2 2           9210     2     3    NA     NA     NA      1        2 #> 3 3           5801     3     1     3      2     NA      1        3 #> 4 4           6816     2     3     2      3      8      1        4 #> 5 5           4868    NA    NA    NA     NA     NA      1        5 #> 6 6            688     3     2     3      6      3      1        6 countSize(\"../tools/rSurveyAssign_vignette_size_1.sqlite\") #> [1] 500"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_size.html","id":"標本サイズの推定","dir":"Articles","previous_headings":"","what":"4. 標本サイズの推定","title":"2. How to forecast sample size","text":"データベースに格納されている試行結果を集計して取り出すためには、 関数getSizeを使います。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_size.html","id":"調査対象者数","dir":"Articles","previous_headings":"4. 標本サイズの推定","what":"4.1 調査対象者数","title":"2. How to forecast sample size","text":"関数getSizeの引数sTYPEをsubjectとすると、 各試行における調査対象者数を調べることができます。 nNum_scrは調査対象者数, nNum_mainはそのうち1つ以上のスロットに割り付けられた人数を表しています。 調査対象者数の平均を求めてみましょう。 必要な調査対象者数の平均は約525人となりました。 実務的には、必要な調査対象者数の平均だけではなく、その分散にも関心が持たれます。 仮に分散が大きい場合、実際に調査を行った際の調査対象者数は運悪く大きな値となり、 予算をオーバーしてしまいかねません。 そこで、500回の試行を通じた調査対象者数の分布を調べてみましょう。  たいていの場合は600人程度で終了しますが、たまにはそれを超えてしまうこともあるようです。","code":"dfResult_s <- getSize (   sTYPE   = \"subject\",   sDBPATH = \"../tools/rSurveyAssign_vignette_size_1.sqlite\" ) print(dfResult_s) #> # A tibble: 500 × 3 #>    nTrial nNum_scr nNum_main #>     <int>    <int>     <int> #>  1      1      451       189 #>  2      2      475       191 #>  3      3      496       182 #>  4      4      399       179 #>  5      5      441       188 #>  6      6      568       186 #>  7      7      643       192 #>  8      8      451       186 #>  9      9      764       190 #> 10     10      529       187 #> # ℹ 490 more rows print(mean(dfResult_s$nNum_scr)) #> [1] 525.892 g <- ggplot2::ggplot(data = dfResult_s, ggplot2::aes(x = nNum_scr)) g <- g + ggplot2::geom_histogram() g <- g + ggplot2::theme_bw() print(g) #> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`."},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_size.html","id":"カテゴリスロットあたり調査対象者数","dir":"Articles","previous_headings":"4. 標本サイズの推定","what":"4.2 カテゴリ・スロットあたり調査対象者数","title":"2. How to forecast sample size","text":"関数getSizeの引数sTYPEをcatとすると、各カテゴリの割付人数を調べることができます。 カテゴリ1, 2, 3の割付人数は、平均してそれぞれ約383人, 420人, 310人となりました。 関数getSizeの引数sTYPEをslotとすると、各スロットの割付人数を調べることができます。 たとえば、カテゴリ1のスロット1の割付人数は、平均して約11.5人となりました。 割付人数が目標である10人を超えるのは、スロット割付の絞り込み条件をallにしたため、 すでに目標に到達しているスロットへの割付が発生する場合があるからです。","code":"dfResult_c <- getSize (   sTYPE   = \"cat\",   sDBPATH = \"../tools/rSurveyAssign_vignette_size_1.sqlite\" ) print(tapply(dfResult_c$nNum, dfResult_c$nCat, mean)) #>       1       2       3  #> 383.292 420.420 310.092 dfResult_s <- getSize (   sTYPE   = \"slot\",   sDBPATH = \"../tools/rSurveyAssign_vignette_size_1.sqlite\" ) print(tapply(dfResult_s$nNum, list(dfResult_s$nCat, dfResult_s$nSlot), mean)) #>        1      2      3      4      5      6      7      8      9     10 #> 1 11.570 11.048 11.274 11.318 10.002 11.226 10.946 11.214 11.748 12.546 #> 2 13.534 12.932 12.592 10.286 12.912 12.226 10.412 12.998 10.538 11.174 #> 3 11.320 10.898 11.092 10.964 11.106 10.004 11.174 11.094 11.342 10.840"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_size.html","id":"分析例-割付方法の比較","dir":"Articles","previous_headings":"","what":"5. 分析例: 割付方法の比較","title":"2. How to forecast sample size","text":"調査に必要な対象者数がカテゴリ割付・スロット割付の方法によって どのように変わるかを、シミュレーションによって推測することができます。 たとえば、スロット割付の方法を(adaptive,,random,allclosed)に変更して シミュレーションしてみます。 SQLiteデータベースファイルとして、../tools/rSurveyAssign_demo2.sqliteを 作成します。20試行実行します。 必要な調査対象者数の平均は約1244人となりました。 スロット割付方法を(adaptive,,shortnum,allclosed)としたときの調査対象者数の平均は約525人でしたから、 こちらの割付方法のほうがはるかに多くの調査対象者を必要とすることがわかります。","code":"lSetting2 <- makeSetting(   lSLOT_REQUEST = lapply(lSlot, function(mbSlot) rep(10, ncol(mbSlot))),    nCAT_MAX      = 2,    sCAT_TYPE     = 'adaptive',   sCAT_FILTER   = 'open',   sCAT_ORDER    = 'random',   sCAT_EXCLUDE  = 'none',   nSLOT_MAX     = 2,   sSLOT_TYPE    = 'adaptive',   sSLOT_FILTER  = 'all',   sSLOT_ORDER   = 'random',   sSLOT_EXCLUDE = 'allclosed' ) #> [makeSetting] assign names to lSLOT_REQUEST ... set.seed(1234) # 結果を再現するために乱数のシードを設定している。通常は設定不要 simSize (   lPOP           = lPop,           lSETTING       = lSetting2,    nNUMTRIAL      = 20,                 sDBPATH        = \"../tools/rSurveyAssign_vignette_size_2.sqlite\",    bAPPEND        = FALSE ) #> [execTrials] start trials (serial) ... #> [execTrials] nTrial: 1 ; extract: 1235 ; 0.03 sec. #> [execTrials] nTrial: 2 ; extract: 1303 ; 0.03 sec. #> [execTrials] nTrial: 3 ; extract: 1201 ; 0.05 sec. #> [execTrials] nTrial: 4 ; extract: 1505 ; 0.05 sec. #> [execTrials] nTrial: 5 ; extract: 1380 ; 0.03 sec. #> [execTrials] nTrial: 6 ; extract: 1234 ; 0.03 sec. #> [execTrials] nTrial: 7 ; extract: 1177 ; 0.05 sec. #> [execTrials] nTrial: 8 ; extract: 1371 ; 0.03 sec. #> [execTrials] nTrial: 9 ; extract: 1041 ; 0.03 sec. #> [execTrials] nTrial: 10 ; extract: 1385 ; 0.03 sec. #> [execTrials] nTrial: 11 ; extract: 1081 ; 0.11 sec. #> [execTrials] nTrial: 12 ; extract: 1555 ; 0.05 sec. #> [execTrials] nTrial: 13 ; extract: 979 ; 0.01 sec. #> [execTrials] nTrial: 14 ; extract: 1495 ; 0.05 sec. #> [execTrials] nTrial: 15 ; extract: 1128 ; 0.03 sec. #> [execTrials] nTrial: 16 ; extract: 1072 ; 0.03 sec. #> [execTrials] nTrial: 17 ; extract: 1437 ; 0.03 sec. #> [execTrials] nTrial: 18 ; extract: 1157 ; 0.03 sec. #> [execTrials] nTrial: 19 ; extract: 1158 ; 0.05 sec. #> [execTrials] nTrial: 20 ; extract: 991 ; 0.03 sec. #> [execTrials] end trials. #> [simSize] # Accumlated Trials: 20 #> NULL dfResult2_s <- getSize (   sTYPE   = \"subject\",   sDBPATH = \"../tools/rSurveyAssign_vignette_size_2.sqlite\" ) print(mean(dfResult2_s$nNum_scr)) #> [1] 1244.25"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_size.html","id":"まとめ-標本サイズ推定のための関数","dir":"Articles","previous_headings":"","what":"6. まとめ: 標本サイズ推定のための関数","title":"2. How to forecast sample size","text":"rSurveyAssignパッケージが提供する関数のうち、標本サイズ推定に関連する関数は以下の通りです。 makePop: 母集団データを作成する makeSetting: 割付のセッティングを作成する simSize: シミュレーションを実行し結果をデータベースに格納する getSize: データベースに格納されたシミュレーション結果を集計して取り出す getSize_raw: データベースに格納されたシミュレーション結果(ローデータ)を取り出す countSize: データベースに格納されたシミュレーション結果の試行数を調べる","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_weight.html","id":"割付確率とウェイト","dir":"Articles","previous_headings":"","what":"1. 割付確率とウェイト","title":"4. How to compute survey weights","text":"まず、割付バイアスを取り除くためのウェイトについて説明します。 このウェイトは、調査において広く用いられている標本ウェイトと似た概念です。 標本ウェイトについての詳細は、標本調査についての参考書、たとえば土屋「概説 標本調査法」(朝倉書店)を参照してください。 たとえば、ある製品カテゴリのたくさんのブランドについて購入意向を調べたとします。 消費者から無作為抽出した調査対象者を、なんらかの割付方法によって、 その人が知っているブランドのなかから\\(J\\)個までのブランドへと割り付け、 割付ブランドについて購入意向を聴取しました。 次の場合について考えます(説明のため、人数が非現実的に少なくなっています)。 調査対象ブランドのひとつであるブランドAについて知っている人は、調査対象者のうち10人でした。 そのうち、ブランドAに割り付けた対象者(つまりブランドAの購入意向を聴取した対象者)は5人でした。 10人の対象者それぞれにAを割り付ける確率は、その対象者の他のブランドへの割付可能性に応じて変動していました。 割付確率を下表に示します。割付確率順に並べています。 たとえば対象者1は、ブランドAへの割付確率が非常に低く(他のたくさんのブランドを知っていたのでしょう)、 実際にAに割り付けられなかった人です。対象者2は、Aへの割付確率は低かったにも関わらず、 たまたまAに割り付けられた人です。 私たちが手に入れる調査データは、下表のA人の対象者の回答です。 これらの対象者は、ブランドAを知っていた10人に比べ、割付確率が高かった人(おそらく他のブランドをあまり知らなかった人)へと 偏っています。 この割付バイアスを集計値から取り除くためにはどうしたらよいでしょうか？ その方法のひとつが、集計の際に、割付確率が低かった人に大きな重み、高かった人に小さな重みを与えることです。 たとえば対象者2は、割付確率が同程度に低かった人々の代表者であると考えます。割付確率は0.1だったので、 10人分の対象者を代表しているのだと考えることができます。そこで、対象者2の回答には重み10を付与します。 同様に、対象者10は、割付確率が同程度に高かった人々の代表者であると考えます。割付確率は0.9だったので、 1/0.9=1.11人分の対象者を代表しているのだと考えることができます。そこで、回答に重み1.11を付与します。 集計の際にはこの重みを用います。たとえば調査変数\\(x\\)について平均を求める際には、 回答者\\(\\)の回答を\\(x_i\\)として、以下とします。 \\[ \\bar{x} = \\frac{1}{10+2.5+2+1.97+1.11} (10 x_2 + 2.5 x_6 + 2 x_7 + 1.67 x_8 + 1.11 x_{10}) \\] つまり、各対象者の回答を「その対象者が何人分を代表していたか」で重みづけて合計し、重みの和(代表されている人々の人数)で 割るわけです。なお、私たちはブランドXを知っていた対象者数が10であることを知っていますから、 \\(10+2.5+2+1.97+1.11\\)ではなくて\\(10\\)で割るという考え方もできます。しかし、いくつかの理由により、上の考え方のほうが良いことが わかっています(土屋(前掲書), p.78)。 この方法で、集計値から割付バイアスを取り除くことができます。 集計の際に用いる重み、すなわち割付確率の逆数のことをウェイトと呼びます。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_weight.html","id":"データの準備","dir":"Articles","previous_headings":"","what":"2. データの準備","title":"4. How to compute survey weights","text":"では、rSurveyAssignパッケージによるウェイト算出の手順について説明しましょう。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_weight.html","id":"調査データ","dir":"Articles","previous_headings":"2. データの準備","what":"2.1 調査データ","title":"4. How to compute survey weights","text":"まず、調査データを用意します。 調査データの例として、surveydataが用意されています。 surveydataは、本パッケージが想定している割付方法で実施された調査で得た、 架空のデータを持つデータフレームです。 この調査は、 カテゴリ数は3 スロット数は各カテゴリについて10 各対象者に対する割付カテゴリ数の上限は2 各対象者に対する割付スロット数の上限は2 目標対象者数はすべてのスロットについて10 カテゴリ割付の方法は(adaptive, open, random, none) スロット割付の方法は(adaptive, , shortnum, allclosed) でした。調査の結果、調査対象者数は504となりました。 surveydataの内容をみてみましょう。 行は調査対象者を表しています。i行目は、i番目に調査に参加した対象者を表しています。 たとえば、1番目の調査対象者は、すべてのカテゴリに割付可能でした。 5番目の調査対象者は、カテゴリ1にのみ割付可能でした。 たとえば、1番目の対象者はカテゴリ2, 3に割り付けられました。 5番目の対象者は、カテゴリ1に割り付けられました。 たとえば、5番目の調査対象者は、カテゴリ1のスロット7, 10に割付可能であることがわかっています。 このデータ例では、対象者がカテゴリ に割り付けられなかったとき、 カテゴリ に属するスロットへの割付可能性はすべてNAとなっています。 たとえば、1番目の調査対象者は、カテゴリ1に対して割付可能でしたが、 カテゴリ1への割付は生じなかったため、カテゴリ1に属するスロットへの割付可能性は NAとなっています。 たとえば、1番目の対象者ではカテゴリ3のスロットへの割付が起きました。5番目の対象者ではカテゴリ1のスロットへの割付が起きました。 たとえば、1番目の対象者はカテゴリ3のスロット7へと割り付けられました。5番目の対象者はカテゴリ1のスロット7,10へと割り付けられました。","code":"library(rSurveyAssign) data(surveydata, package = \"rSurveyAssign\") head(surveydata) #>   SEQ bCat_1 bCat_2 bCat_3 nAssignedCat_1 nAssignedCat_2 bSlot_1_1 bSlot_1_2 #> 1   1      1      1      1              3              2        NA        NA #> 2   2      1      1      1              3              1         0         0 #> 3   3      1      1      1              2              1         0         0 #> 4   4      1      1      1              2              1         0         1 #> 5   5      1      0      0              1             NA         0         0 #> 6   6      1      1      1              1              2         1         1 #>   bSlot_1_3 bSlot_1_4 bSlot_1_5 bSlot_1_6 bSlot_1_7 bSlot_1_8 bSlot_1_9 #> 1        NA        NA        NA        NA        NA        NA        NA #> 2         0         0         0         0         0         0         0 #> 3         0         0         0         0         0         0         0 #> 4         1         1         0         1         0         0         1 #> 5         0         0         0         0         1         0         0 #> 6         1         1         1         1         1         0         1 #>   bSlot_1_10 bSlot_2_1 bSlot_2_2 bSlot_2_3 bSlot_2_4 bSlot_2_5 bSlot_2_6 #> 1         NA         0         0         0         0         0         0 #> 2          0        NA        NA        NA        NA        NA        NA #> 3          0         0         0         0         0         0         0 #> 4          1         0         0         1         0         1         0 #> 5          1        NA        NA        NA        NA        NA        NA #> 6          1         1         1         1         0         1         1 #>   bSlot_2_7 bSlot_2_8 bSlot_2_9 bSlot_2_10 bSlot_3_1 bSlot_3_2 bSlot_3_3 #> 1         0         0         0          0         0         0         0 #> 2        NA        NA        NA         NA         0         0         0 #> 3         0         0         0          0        NA        NA        NA #> 4         1         1         0          0        NA        NA        NA #> 5        NA        NA        NA         NA        NA        NA        NA #> 6         0         1         1          1        NA        NA        NA #>   bSlot_3_4 bSlot_3_5 bSlot_3_6 bSlot_3_7 bSlot_3_8 bSlot_3_9 bSlot_3_10 #> 1         0         0         0         1         0         0          0 #> 2         0         0         0         0         0         1          1 #> 3        NA        NA        NA        NA        NA        NA         NA #> 4        NA        NA        NA        NA        NA        NA         NA #> 5        NA        NA        NA        NA        NA        NA         NA #> 6        NA        NA        NA        NA        NA        NA         NA #>   nAssignedCat_Slots nAssignedSlot_1 nAssignedSlot_2 #> 1                  3               7              NA #> 2                  3               9              10 #> 3                 NA              NA              NA #> 4                  2               7               5 #> 5                  1               7              10 #> 6                  1               2               1"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_weight.html","id":"surveydataオブジェクトの生成","dir":"Articles","previous_headings":"2. データの準備","what":"1.2 surveydataオブジェクトの生成","title":"4. How to compute survey weights","text":"調査データをrSurveyAssignパッケージが扱える形式に変換します。 rSurveyAssignパッケージは、調査データを表すクラスsurveydataを用意しています。 surveydataクラスのオブジェクトは、関数makeSurveyで作成します。 makeSurveyの引数は次の8つです。 以下では、調査対象者を\\((=1,\\ldots,)\\), カテゴリを\\(j(=1,\\ldots,J)\\), カテゴリ\\(j\\)のスロットを\\(k (=1,\\ldots,K[j])\\)、 各対象者に対する割付カテゴリ数の上限を\\(C\\)、 割付スロット数の上限を\\(S\\)とします。 \\(\\)行\\(J\\)列の整数行列。 \\(\\)行\\(j\\)列の値は、「\\(\\)番目に調査に参加した対象者にとってカテゴリ\\(j\\)は割付可能であったか」を表し、\\(0\\)は割付不能, \\(1\\)は割付不能を表します。 欠損は許容されません。 \\(J\\)個の要素からなるリスト。\\(j\\)番目の要素は、\\(\\)行\\(K[j]\\)列の整数行列。 要素\\(j\\)の行列の\\(\\)行\\(k\\)列の値は、「\\(\\)番目に調査に参加した対象者にとって カテゴリ\\(j\\)のスロット\\(k\\)は割付可能であったか」を表し、\\(0\\)は割付不能, \\(1\\)は割付不能を表します。 mbCAT[,j] == 0のとき、lSLOT[[j]][,]は無視されます (すなわち、割付不能カテゴリに属するスロットの割付可能性は無視されます)。 従って欠損も許容されます。 mbCAT[,j] == 1であり、かつmnASSIGNEDCAT[,]に\\(j\\)が含まれているとき、 lSLOT[[j]][,]に欠損は許容されません (すなわち、割り付けされたカテゴリに属するスロットへの割付可能性は すべて指定する必要があります)。 mbCAT[,j] == 1であり、かつmnASSIGNEDCAT[,]に\\(j\\)が含まれていないとき、 lSLOT[[j]][,]は無視されませんが、欠損も許容されます (すなわち、割付可能カテゴリであれば、割り付けされなかったカテゴリであっても、 そのカテゴリに属するスロットへの割付可能性は、 利用できる限り、シミュレーションに利用されます)。 欠損を含んでいる行は、その行全体が欠損であるとみなされます。 \\(J\\)個の要素からなるリスト。\\(j\\)番目の要素は、長さ\\(K[j]\\)の整数ベクトル。 \\(j\\)番目の要素であるベクトルの\\(k\\)番目の値は、カテゴリ\\(j\\)のスロット\\(k\\)に割り付ける対象者数の下限を表します。欠損は許容されません。 詳細は“1. assign subjects”を参照して下さい。 詳細は“1. assign subjects”を参照して下さい。 \\(\\)行\\(C\\)列の整数行列。 \\(\\)行目は、調査対象者\\(\\)が割り付けられた0個～C個のカテゴリの番号(mbCATの列番号)を表します。 調査対象者\\(\\)にカテゴリ割付が行われなかったときは、\\(\\)行目はすべてNAとします。割り付けられたカテゴリが\\(C\\)個未満であった場合は、それらのカテゴリ番号を格納し、残りはNAとします。 ある行のなかの値の順序に意味はありません。 長さ\\(\\)の整数行列。 \\(\\)番目の要素は、調査対象者\\(\\)が割り付けられたスロットが属するカテゴリの番号(mbCATの列番号)を表します。スロット割付が行われなかった場合はNAとします。 \\(\\)行\\(S\\)列の整数行列。 \\(\\)行目は、調査対象者\\(\\)が割り付けられたスロットの番号を表します。 ここでスロットの番号とは、agPARENTCAT[1]で指定されているカテゴリをcとして、 lSLOT[[c]]の列番号のことです。 調査対象者\\(\\)にスロット割付が行われなかったときは\\(\\)行目はすべて欠損とします。割り付けられたスロットが\\(S\\)個未満であった場合は、それらのスロット番号を格納し、残りは欠損とします。 ある行のなかの値の順序に意味はありません。 関数makeSurveyは、この8つのオブジェクトの整合性をチェックしたうえで、 リストに格納して返します。 では、データ例をsurveydataクラスのオブジェクトに変換しましょう。 無事に変換されました。","code":"lSurvey <- makeSurvey(   mbCAT <- as.matrix(surveydata[, paste0(\"bCat_\", 1:3)]),    lSLOT <- list(     as.matrix(surveydata[, paste0(\"bSlot_1_\", 1:10)]),     as.matrix(surveydata[, paste0(\"bSlot_2_\", 1:10)]),      as.matrix(surveydata[, paste0(\"bSlot_3_\", 1:10)])   ),    lSLOT_REQUEST = list(rep(10, 10), rep(10, 10), rep(10, 10)),   sCAT_TYPE     = 'adaptive',    sCAT_FILTER   = \"open\",    sCAT_ORDER    = \"random\",    sCAT_EXCLUDE  = \"none\",   sSLOT_TYPE    = \"adaptive\",    sSLOT_FILTER  = \"all\",    sSLOT_ORDER   = \"shortnum\",    sSLOT_EXCLUDE = \"allclosed\",   mnASSIGNCAT   = as.matrix(surveydata[, c(\"nAssignedCat_1\", \"nAssignedCat_2\")]),   anPARENTCAT   = as.vector(surveydata$nAssignedCat_Slots),    mnASSIGNSLOT  = as.matrix(surveydata[, c(\"nAssignedSlot_1\", \"nAssignedSlot_2\")]) ) #> [makeSurvey] # of categories: 3  #> [makeSurvey] # of slots: 10,10,10  #> [makeSurvey] # subjects: 504  #> [makeSurvey] # of pairs of subject-category: #> [makeSurvey]   total: 1512  #> [makeSurvey]   assignable: 1337 (445.7/category)  #> [makeSurvey]   assigned: 1767 (589.0/category)  #> [makeSurvey]   assignable but assignabilities to slots are unknown: 447 (149.0/category)  #> [makeSurvey]     each of these subjects will be complemented by: #> [makeSurvey]     a subject who has the same pattern of assignable categories: 447  #> [makeSurvey]     a subject who has the same number of assignable categories: 0  #> [makeSurvey]     a subject who is randomly selected: 0  #> [makeSurvey] # of pairs of subject-slot: #> [makeSurvey]   in assignable categories: 13370 (445.7/slot)  #> [makeSurvey]   known to be assignable: 1829 (61.0/slot)  #> [makeSurvey]   assigned: 346 (11.5/slot)"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_weight.html","id":"割付のチェック","dir":"Articles","previous_headings":"2. データの準備","what":"1.2 割付のチェック","title":"4. How to compute survey weights","text":"話を進める前に、調査データにおいてカテゴリ割付・スロット割付が 期待通りに行われていたかどうかをチェックしておきましょう。 この例では、すべての対象者について、カテゴリ割付・スロット割付が期待通りに行われていました。 期待通りに行われていない対象者がいた場合、その詳細が、checkAssignが返すデータフレームに記述されます。 実際のweb調査においても、システムのトラブルや、対象者を割り付けるタイミングが複数の対象者で重なってしまうといった理由により、必ずしもすべての割付が期待通りに行われるとは限らないと思います。従って、期待に反する割付が行われた人がある程度生じるのは仕方がないと思います。 しかし、期待に反する割付が行われた人数が多すぎるときには、以下で算出するウェイトの妥当性も疑われます。実査システムをチェックする必要があるでしょう。","code":"dfCheck <- checkSurvey(lSurvey) #> [checkSurvey] 0 errors are found."},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_weight.html","id":"再割付シミュレーション","dir":"Articles","previous_headings":"","what":"3. 再割付シミュレーション","title":"4. How to compute survey weights","text":"ウェイトを算出するためにシミュレーションを行ってみましょう。 rSurveyAssignパッケージでは、割付確率を推定するために、調査データから調査対象者を復元抽出することによって仮想的な調査対象者を生成し、カテゴリ・スロットへの割付をやりなおします。これを再割付試行と呼びます。 再割付試行を十分な回数繰り返し、ある対象者があるカテゴリ・スロットへと割り付けられる割合を求め、これを割付確率の推定値とします。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_weight.html","id":"少数の試行の実行","dir":"Articles","previous_headings":"3. 再割付シミュレーション","what":"3.1 少数の試行の実行","title":"4. How to compute survey weights","text":"まずは、シミュレーションを10試行だけ実行してみます。引数nBLOCKSIZEにブロックあたり試行数10を指定し、引数nNUMBLOCKにブロック数1を指定します。 画面に表示されたメッセージをみてみましょう。上から2行目以降のメッセージは再割付試行について表示しています。最初の再割付試行では、調査対象者を690人抽出したところで、目標対象者数が満たされ、調査が終了しました。 シミュレーションの結果をみてみましょう。 simWeightの返し値は2つの要素からなるリストです。 要素dfStat_Catは、試行を通じ、ある対象者があるカテゴリに何回割り付けられたかを示しています。 最初の行は、10回のシミュレーション試行中に、対象者1が(正確には、対象者1と全く同一の割付可能性を持つ誰かが)、延べ9回にわたり調査に参加し、そのうち5回においてカテゴリ1に割り付けられた、ということを示しています。シミュレーションを繰り返せば、対象者1がカテゴリ1に割り付けられる確率を推定することができます。 要素dfStat_Slotは、試行を通じ、ある対象者があるスロットに何回割り付けられたかを示しています。 最初の行は、10回のシミュレーション試行中に、対象者1が(正確には、対象者1と全く同一の割付可能性を持つ誰かが)、延べ14回にわたり調査参加し、そのうち3回においてカテゴリ1のスロット2に割り付けられた、ということを示しています。 シミュレーション試行を繰り返せば、対象者1がカテゴリ1のスロット2に割り付けられる確率を推定することができます。","code":"set.seed(123)  # 結果を再現するために乱数のシードを設定している。通常は設定不要 lResult <- simWeight(   lSURVEY    = lSurvey,   nBLOCKSIZE = 10,   nNUMBLOCK  = 1 ) #> [makeRetrialBlock] start replication (serial) ... #> [makeRetrialBlock] retrial: 1 ; rand: 0.2875775 ; extract: 703 ; 0.02 sec. #> [makeRetrialBlock] retrial: 2 ; rand: 0.8474248 ; extract: 465 ; 0.01 sec. #> [makeRetrialBlock] retrial: 3 ; rand: 0.4102877 ; extract: 463 ; 0.02 sec. #> [makeRetrialBlock] retrial: 4 ; rand: 0.8728468 ; extract: 541 ; 0.01 sec. #> [makeRetrialBlock] retrial: 5 ; rand: 0.7231241 ; extract: 561 ; 0.02 sec. #> [makeRetrialBlock] retrial: 6 ; rand: 0.5164188 ; extract: 563 ; 0.01 sec. #> [makeRetrialBlock] retrial: 7 ; rand: 0.2947217 ; extract: 587 ; 0.02 sec. #> [makeRetrialBlock] retrial: 8 ; rand: 0.5854465 ; extract: 540 ; 0.02 sec. #> [makeRetrialBlock] retrial: 9 ; rand: 0.6935848 ; extract: 378 ; 0.01 sec. #> [makeRetrialBlock] retrial: 10 ; rand: 0.3121077 ; extract: 525 ; 0.02 sec. #> [execRetrials] block 1 :  0.24 sec. head(lResult$dfStat_Cat) #> # A tibble: 6 × 7 #>   nSubject  nCat bAssign nCount_SubjectCat nCount_Subject nBlock nBlockSize #>      <int> <int>   <dbl>             <int>          <int>  <int>      <dbl> #> 1        1     1       0                 5              9      1         10 #> 2        1     2       1                 8              9      1         10 #> 3        1     3       1                 4              9      1         10 #> 4        2     1       1                 4              6      1         10 #> 5        2     2       0                 5              6      1         10 #> 6        2     3       1                 3              6      1         10 head(lResult$dfStat_Slot) #> # A tibble: 6 × 8 #>   nSubject  nCat nSlot bAssign nCount_SubjectSlot nCount_Subject nBlock #>      <int> <int> <int>   <dbl>              <int>          <int>  <int> #> 1        4     1     2       0                  3             14      1 #> 2        4     1     3       0                  0             14      1 #> 3        4     1     4       0                  0             14      1 #> 4        4     1     6       0                  2             14      1 #> 5        4     1     9       0                  1             14      1 #> 6        4     1    10       0                  0             14      1 #> # ℹ 1 more variable: nBlockSize <dbl>"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_weight.html","id":"少数の試行の実行と保存","dir":"Articles","previous_headings":"3. 再割付シミュレーション","what":"3.2 少数の試行の実行と保存","title":"4. How to compute survey weights","text":"上の例では、シミュレーションの結果をデータフレームとして取得しました。 しかし、シミュレーションの結果はサイズが大きいので、いったんSQLiteデータベース上に 保存したほうがよいでしょう。 以下の例では、 SQLiteデータベースファイルとして、../tools/rSurveyAssign_vignette_weight_1.sqliteを 作成します。実際には、適切なフォルダとファイル名を指定してください。また、 データベースファイルは必要がなくなったら自分で消してください。","code":"### 都合によりコメントアウトしています set.seed(123)  # 結果を再現するために乱数のシードを設定している。通常は設定不要 lResult <- simWeight(   lSURVEY    = lSurvey,   nBLOCKSIZE = 10,   nNUMBLOCK  = 1,   sDBPATH    = \"../tools/rSurveyAssign_vignette_weight_1.sqlite\",   bPARALLEL  = FALSE,    bAPPEND    = FALSE  # すでにデータベースが存在する場合は上書きする ) #> [makeRetrialBlock] start replication (serial) ... #> [makeRetrialBlock] retrial: 1 ; rand: 0.2875775 ; extract: 703 ; 0.01 sec. #> [makeRetrialBlock] retrial: 2 ; rand: 0.8474248 ; extract: 465 ; 0.02 sec. #> [makeRetrialBlock] retrial: 3 ; rand: 0.4102877 ; extract: 463 ; 0.01 sec. #> [makeRetrialBlock] retrial: 4 ; rand: 0.8728468 ; extract: 541 ; 0.02 sec. #> [makeRetrialBlock] retrial: 5 ; rand: 0.7231241 ; extract: 561 ; 0.01 sec. #> [makeRetrialBlock] retrial: 6 ; rand: 0.5164188 ; extract: 563 ; 0.02 sec. #> [makeRetrialBlock] retrial: 7 ; rand: 0.2947217 ; extract: 587 ; 0.02 sec. #> [makeRetrialBlock] retrial: 8 ; rand: 0.5854465 ; extract: 540 ; 0.01 sec. #> [makeRetrialBlock] retrial: 9 ; rand: 0.6935848 ; extract: 378 ; 0.02 sec. #> [makeRetrialBlock] retrial: 10 ; rand: 0.3121077 ; extract: 525 ; 0.01 sec. #> [execRetrials] block 1 :  0.23 sec.  #> [simWeight] # Accumlated Trials: 10"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_weight.html","id":"多くの試行の実行","dir":"Articles","previous_headings":"3. 再割付シミュレーション","what":"3.3 多くの試行の実行","title":"4. How to compute survey weights","text":"ウェイトを求めるためには、再割付試行を十分な回数だけ繰り返す必要があります。 今度は1000試行繰り返してみましょう。 上の例では10試行からなる1ブロックを実行してきましたが、 デフォルトでは、100試行を1ブロックと呼んでいます。 ここでは、引数nBLOCKSIZEを指定せず、 引数nNUMBLOCKにブロック数10を指定します。 実行時間を短くするため、並列処理を行うことにします。引数bPARALLELにTRUEを指定します。 並列処理を行う場合、各試行についてのメッセージは画面に表示されません。 そこでログファイルを作成することにします。 実行に長い時間がかかる場合は、ログファイルを監視すると、 いま何試行まで進んでいるかわかり、少しだけ心が癒されるでしょう。 下の例では、ログファイルをC:/work/simWeight.logとしています。 RStudioを使っているなら、Terminalウィンドウでtail -F C:/work/simWeight.logを 実行すると、ログファイルを監視できます。 データベースに1000試行の結果が格納されました。 なお、これまでにデータベースに格納した試行数は、格納した際に表示されますが、 関数countWeightで調べることもできます。 上記の実行例では、シミュレーションの結果をデータベースに上書きしましたが、 引数bAPPENDをTRUEにすることで、データベースに追加することもできます。 この例では1ブロックに数秒しかかかりませんが、 場合によってはもっと長い時間がかかることがあります。ブロック数を大きくすると、 simWeightの実行にはとても長い時間がかかってしまうことになります。 大きなブロック数を一気に実行するのではなく、 ブロック数は手頃な大きさにしておき、気が向いたときに simWeightを繰り返し実行して、 結果を少しずつデータベースに蓄積していくのが良いでしょう。 その際は、初回実行時には引数bAPPENDをFALSEとし、 二回目以降の実行時にはTRUEとしてください。 また、引数lSURVEYに与える値を途中で変えないように注意して下さい(少しでも変えるとエラーになります)。","code":"### 都合によりコメントアウトしています # set.seed(123)  # 結果を再現するために乱数のシードを設定している。通常は設定不要 # lResult <- simWeight( #  lSURVEY    = lSurvey, #  nNUMBLOCK  = 10, #  sDBPATH    = \"../tools/rSurveyAssign_vignette_weight_2.sqlite\", #  bPARALLEL  = TRUE, #  sLOGFILE   = \"c:/work/simWeight.log\", #  bAPPEND    = FALSE  # すでにデータベースが存在する場合は上書きする # ) countWeight(sTYPE = \"retrial\", sDBPATH = \"../tools/rSurveyAssign_vignette_weight_2.sqlite\") #> [1] 1000"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_weight.html","id":"ウェイトの算出","dir":"Articles","previous_headings":"","what":"4. ウェイトの算出","title":"4. How to compute survey weights","text":"十分な回数の再割付試行を行えば、それらの結果から、ある人があるカテゴリ・スロットに割り付けられる確率を推定し、ウェイトを求めることができます。 シミュレーション試行の結果に基づきウェイトを算出するためには、関数getWeightを使います。 getWeightの返し値は2つのデータフレームを含むリストです。 データフレーム dfWeight_Catには、ある調査対象者のある割付カテゴリに対する回答に与えるウェイトが 格納されています。 対象者1の割付カテゴリ3への回答には、ウェイト1.06が付与されています。 なお、このウェイトは、すべての調査対象者のすべての割付カテゴリを通じて 平均1に規準化されています。ヒストグラムを描いてみましょう。  割付カテゴリに対するウェイトは、それほど極端な値にはなっていないようです。 データフレーム dfWeight_Slotには、ある調査対象者のある割付スロットに対する回答に与えるウェイト が格納されています。 対象者1が割り付けられたカテゴリ3のスロット7への回答には、ウェイト0.57が 付与されています。 なお、このウェイトは、すべての調査対象者のすべての割付スロットを通じて、 平均1に規準化されています。ヒストグラムを描いてみましょう。  ごくわずかですが、極端に大きいウェイトが含まれているようです。 ウェイトが極端になったときは、まずシミュレーションの試行数が不十分である ことを疑ってください。 十分な試行数の結果に基づいて算出してもなお極端なウェイトが出現する場合は、バイアスが強すぎる割付方法を選択してしまったことが疑われます。バイアスの完全な除去を断念し、ウェイトを適切な範囲に切り詰めることを検討してください。 ウェイトを切り詰めるための関数としてtrimWeightが用意されています。デフォルトでは、 ウェイトを0.2から5の範囲に切り詰めます。","code":"lWeight <- getWeight(lSurvey, \"../tools/rSurveyAssign_vignette_weight_2.sqlite\") head(lWeight$dfWeight_Cat) #> # A tibble: 6 × 7 #>   nSubject  nCat nNumRetrial nCount_SubjectCat nCount_Subject gProb gWeight #>      <int> <int>       <dbl>             <int>          <int> <dbl>   <dbl> #> 1        1     3        1000               614           1004 0.612   1.06  #> 2        1     2        1000               646           1004 0.644   1.01  #> 3        2     3        1000               591            997 0.593   1.10  #> 4        2     1        1000               583            997 0.585   1.11  #> 5        3     2        1000               679           1024 0.663   0.979 #> 6        3     1        1000               583           1024 0.570   1.14 hist(lWeight$dfWeight_Cat$gWeight, main = NULL) head(lWeight$dfWeight_Slot) #> # A tibble: 6 × 8 #>   nSubject  nCat nSlot nNumRetrial nCount_SubjectSlot nCount_Subject gProb #>      <int> <int> <int>       <dbl>              <int>          <int> <dbl> #> 1        1     3     7        1000                225           1004 0.225 #> 2        2     3     9        1000                271            997 0.273 #> 3        2     3    10        1000                271            997 0.273 #> 4        4     2     7        1000                423           1003 0.422 #> 5        4     2     5        1000                134           1003 0.134 #> 6        5     1     7        1000                533           1011 0.528 #> # ℹ 1 more variable: gWeight <dbl> hist(lWeight$dfWeight_Slot$gWeight, main = NULL) hist(trimWeight(lWeight$dfWeight_Slot$gWeight), main = NULL)"},{"path":"https://shigono.github.io/rSurveyAssign/articles/vignette_weight.html","id":"まとめ-ウェイト算出に関連する関数","dir":"Articles","previous_headings":"","what":"5. まとめ: ウェイト算出に関連する関数","title":"4. How to compute survey weights","text":"rSurveyAssignパッケージが提供する関数のうち、ウェイト算出に関連する関数は以下の通りです。 makeSurvey: 調査データを作成する checkSurvey: 調査において行われた割付が正しかったかどうかをチェックする simWeight: シミュレーションを実行し結果をデータベースに格納する getWeight: データベースに格納されたシミュレーション結果に基づき、ウェイトを算出する countWeight: データベースに格納されたシミュレーション結果の試行数を調べる trimWeight: ウェイトを切り詰める","code":""},{"path":"https://shigono.github.io/rSurveyAssign/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Shigeru ONO. Author, maintainer.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"ONO S (2024). rSurveyAssign: tools simulation assignment web surveys. R package version 0.3.1, https://shigono.github.io/rSurveyAssign/.","code":"@Manual{,   title = {rSurveyAssign: tools for simulation of assignment in web surveys},   author = {Shigeru ONO},   year = {2024},   note = {R package version 0.3.1},   url = {https://shigono.github.io/rSurveyAssign/}, }"},{"path":"https://shigono.github.io/rSurveyAssign/index.html","id":"rsurveyassign-tools-for-simulation-of-assignment-in-web-surveys","dir":"","previous_headings":"","what":"tools for simulation of assignment in web surveys","title":"tools for simulation of assignment in web surveys","text":"package contains several tools simulate different types assignment processes web surveys. package, users can estimate sample sizes future surveys, assess bias future surveys, calculate survey weights actual surveys conducted. このパッケージは、web調査における対象者割付についてのシミュレーションを行うためのパッケージです。これから行う調査について標本サイズを見積もったり、バイアスを評価したり、すでに行った調査について調査ウェイトを求めたりすることができます。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/index.html","id":"インストール","dir":"","previous_headings":"","what":"インストール","title":"tools for simulation of assignment in web surveys","text":"GitHubからインストールできます。","code":"# install.packages(\"devtools\") devtools::install_github(\"shigono/rSurveyAssign\", build_manual = TRUE, build_vignettes = TRUE)"},{"path":"https://shigono.github.io/rSurveyAssign/index.html","id":"使い方","dir":"","previous_headings":"","what":"使い方","title":"tools for simulation of assignment in web surveys","text":"vignetteをご覧ください。 vignetteは パッケージのwebサイト でも公開されています。","code":"vignette(topic = \"vignette\", package = \"rSurveyAssign\")"},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://shigono.github.io/rSurveyAssign/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":"https://shigono.github.io/rSurveyAssign/reference/checkDB.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal: check database — checkDB","title":"Internal: check database — checkDB","text":"Internal: データベースファイルのチェック","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/checkDB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal: check database — checkDB","text":"","code":"checkDB(sDBPATH, asTABLE, sDIGEST = NULL)"},{"path":"https://shigono.github.io/rSurveyAssign/reference/checkDB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal: check database — checkDB","text":"sDBPATH 文字列。データベースファイルへのパス asTABLE 文字列ベクトル。データベースのテーブル名。 sDIGEST 文字列。ダイジェスト。nullの場合はチェックしない","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/checkDB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal: check database — checkDB","text":"論理値。以下の条件を満たしたときにTRUE, そうでないときにFALSEを返す。 データベースファイルsDBPATHが実在する そこにasTABLEとテーブル\"digest\"が含まれる (sDIGESTが指定された場合のみ) その列の値はsDIGESTに一致する","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/checkSurvey.html","id":null,"dir":"Reference","previous_headings":"","what":"check assigned categories and slots in survey data — checkSurvey","title":"check assigned categories and slots in survey data — checkSurvey","text":"調査データを受け取り、 カテゴリ・スロット割付が正しく行われていたことを確認する。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/checkSurvey.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"check assigned categories and slots in survey data — checkSurvey","text":"","code":"checkSurvey(lSURVEY, sVERBOSE = c(\"simple\", \"detail\", \"none\"))"},{"path":"https://shigono.github.io/rSurveyAssign/reference/checkSurvey.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"check assigned categories and slots in survey data — checkSurvey","text":"lSURVEY object `surveydata` class.。 調査データ。makeSurveyで生成する。 sVERBOSE string. 画面表示レベル。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/checkSurvey.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"check assigned categories and slots in survey data — checkSurvey","text":"data frame.    割付結果とその検証。 以下の列を持つ。  nPerson:                   対象者番号。1からの連番 bCat_(j):                  カテゴリjへの割付可能性 bCatSlot_(j)_(k):          カテゴリjのスロットkへの割付可能性 nCount_Cat_(j):            この対象者の割付終了時点でのカテゴリjへの割付人数 nCount_CatSlot_(j)_(k):    この対象者の割付終了時点でのカテゴリj, スロットkへの割付人数 nAssignCat_(c):            この対象者のc番目の割付カテゴリ(順序に意味はない) nParentCat:                この対象者の割付スロットが属するカテゴリ nAssignSlot_(s):           この対象者のs番目の割付スロット(順序に意味はない) bValid:                    チェックを通過したか: 1:通過した, 0:通過しなかった sCheckMsg:                 チェックを通過しなかった理由。通過したときは\"\"。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/countBias.html","id":null,"dir":"Reference","previous_headings":"","what":"count trials of bias simulations which are done so far — countBias","title":"count trials of bias simulations which are done so far — countBias","text":"これまでに実行されたバイアス評価シミュレーションの割付試行数を数える","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/countBias.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"count trials of bias simulations which are done so far — countBias","text":"","code":"countBias(   sDBPATH,   sDBTABLE_SUBJECT = \"subject\",   sDBTABLE_CAT = \"weight_cat\",   sDBTABLE_SLOT = \"weight_slot\" )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/countBias.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"count trials of bias simulations which are done so far — countBias","text":"sDBPATH 文字列。シミュレーションの結果を保存するSQLite DBのフルパス。実在しなくてもよい。 sDBTABLE_SUBJECT 文字列。割付シミュレーションの結果を保存するSQLite DBのテーブル名。 sDBTABLE_CAT 文字列。再割付シミュレーションの結果(カテゴリ)を保存するSQLite DBのテーブル名。 sDBTABLE_SLOT 文字列。再割付シミュレーションの結果(スロット)を保存するSQLite DBのテーブル名。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/countBias.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"count trials of bias simulations which are done so far — countBias","text":"整数。割付試行数。指定されたsDBPATHが存在しない場合は0となる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/countBias.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"count trials of bias simulations which are done so far — countBias","text":"sDBPATHが存在するのにsDBTABLE_SUBJECT, sDBTABLE_CAT, sDBTABLE_SLOTが存在しない場合はエラーになる。 テーブルによって試行数が異なる場合はエラーになる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/countSize.html","id":null,"dir":"Reference","previous_headings":"","what":"count trials of size simulations which are done so far — countSize","title":"count trials of size simulations which are done so far — countSize","text":"これまでに実行された標本サイズ予測シミュレーションの割付試行を数える","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/countSize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"count trials of size simulations which are done so far — countSize","text":"","code":"countSize(sDBPATH, sDBTABLE = \"size\")"},{"path":"https://shigono.github.io/rSurveyAssign/reference/countSize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"count trials of size simulations which are done so far — countSize","text":"sDBPATH 文字列。 シミュレーションの結果を保存するSQLite DBのフルパス。 実在しなくてもよい。 sDBTABLE 文字列。 シミュレーションの結果を保存するSQLite DBのテーブル名。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/countSize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"count trials of size simulations which are done so far — countSize","text":"整数。    試行数。指定されたsDBPATHが存在しない場合は0。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/countSize.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"count trials of size simulations which are done so far — countSize","text":"sDBPATHが存在するのにsDBTABLEが存在しない場合はエラー。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/countWeight.html","id":null,"dir":"Reference","previous_headings":"","what":"count trials of weight simulations which are done so far — countWeight","title":"count trials of weight simulations which are done so far — countWeight","text":"これまでに実行されたウェイト算出シミュレーションの再割付試行数を数える","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/countWeight.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"count trials of weight simulations which are done so far — countWeight","text":"","code":"countWeight(   sDBPATH,   sDBTABLE_CAT = \"weight_cat\",   sDBTABLE_SLOT = \"weight_slot\",   sTYPE = c(\"retrial\", \"block\") )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/countWeight.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"count trials of weight simulations which are done so far — countWeight","text":"sDBPATH 文字列。 シミュレーションの結果を保存するSQLite DBのフルパス。 実在しなくてもよい。 sDBTABLE_CAT 文字列。 シミュレーションの結果(カテゴリ)を保存するSQLite DBのテーブル名。 実在しなくてもよい。 sDBTABLE_SLOT 文字列。 シミュレーションの結果(スロット)を保存するSQLite DBのテーブル名。 実在しなくてもよい。 sTYPE 文字列。返し値の種類。以下のいずれか: \"retrial\": 再割付試行数を返す \"block\": 再割付試行のブロック数を返す","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/countWeight.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"count trials of weight simulations which are done so far — countWeight","text":"integer.    再割付試行数ないしブロック数。    指定されたsDBPATH, sDBTABLE_CAT, sDBTABLE_SLOTが存在しない場合は0となる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/countWeight.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"count trials of weight simulations which are done so far — countWeight","text":"sDBPATHが存在し、sDBTABLE_CAT, sDBTABLE_SLOTのいずれかのみが存在する場合は    エラーとなる。 sDBPATHが存在し、sDBTABLE_CATとsDBTABLE_SLOTで試行数が異なる場合はエラーになる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/execAssign.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal: Assign participants into 'categories' and 'slots' — execAssign","title":"Internal: Assign participants into 'categories' and 'slots' — execAssign","text":"Internal: 対象者をカテゴリ・スロットに割り付ける。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/execAssign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal: Assign participants into 'categories' and 'slots' — execAssign","text":"","code":"execAssign(   anSEQ_PERSON,   mnSEQ_CAT_PERSON,   mbPERSON_CAT_USE,   lPERSON_SLOT_HIT,   lSLOT_REQUEST,   nCAT_MAX,   sCAT_TYPE,   sCAT_FILTER,   sCAT_ORDER,   sCAT_EXCLUDE,   nSLOT_MAX,   sSLOT_TYPE,   sSLOT_FILTER,   sSLOT_ORDER,   sSLOT_EXCLUDE,   bCHECKCOMPLETE = TRUE,   sVERBOSE = c(\"simple\", \"detail\", \"none\") )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/execAssign.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal: Assign participants into 'categories' and 'slots' — execAssign","text":"anSEQ_PERSON integer vector. anSEQ_PERSON[]は、i番目に調査に参加する対象者の mbPERSON_CAT_USE上の行番号。欠損不可。 mnSEQ_CAT_PERSON integer matrix. mnSEQ_CAT_PERSON[,j]は、i番目に調査に参加する 対象者の、カテゴリjのスロット割付可能性を調べる際に参照すべき、 lPERSON_SLOT_HIT[[j]]の行番号。 欠損を許すが、 mbPERSON_CAT_USE[anSEQ_PERSON[],j] == 1のとき、mnSEQ_CAT_PERSON[,j]の 欠損は不可。 mbPERSON_CAT_USE binary matrix. 対象者のカテゴリ割付可能性を表す。mbPERSON_CAT_USE[,j]は以下を表す。 1: 調査対象者iはカテゴリjについて割付可能。 0: 調査対象者iはカテゴリjについて割付不能。 欠損を許すが、mbPERSON_CAT_USE[anSEQ_PERSON, ]における欠損は不可。 lPERSON_SLOT_HIT list binary matrices. 対象者のスロット割付可能性を表す。 要素jの行列の要素(,k)は以下を表す。 1: 調査対象者iはカテゴリjのスロットkについて割付可能。 0: 調査対象者iはカテゴリjのスロットkについて割付不能。 欠損を許すが、 mbPERSON_CAT_USE[,j] == 1のとき、 lPERSON_SLOT_HIT[[j]][, ]における欠損は不可。 lSLOT_REQUEST list integer vectors. 各スロットに割り付ける対象者数の下限。 要素jのベクトルの要素kは, カテゴリjのスロットkに割り付ける対象者の下限を表す。 nCAT_MAX integer. ある対象者に割り付けるカテゴリ数の上限。 sCAT_TYPE string. カテゴリ割付タイプ。詳細はvignetteを参照。 sCAT_FILTER string. カテゴリ割付の際の絞り込み条件。詳細はvignetteを参照。 sCAT_ORDER string. カテゴリ割付の際の順序付け条件。詳細はvignetteを参照。 sCAT_EXCLUDE .string カテゴリ割付の際の除外条件。詳細はvignetteを参照。 nSLOT_MAX integer. ある対象者に割り付けるスロット数の上限。 sSLOT_TYPE string. スロット割付タイプ。指定は必須。詳細はvignetteを参照。 sSLOT_FILTER string. スロット割付の際の絞り込み条件。詳細はvignetteを参照。 sSLOT_ORDER string. スロット割付の際の順序付け条件。詳細はvignetteを参照。 sSLOT_EXCLUDE string. スロット割付の際の除外条件。指定は必須。詳細はvignetteを参照。 bCHECKCOMPLETE logical. anSEQ_PERSONを使い切っても 全スロットがクローズしなかったらエラーを発生させる sVERBOSE string. 画面表示レベル。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/execAssign.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal: Assign participants into 'categories' and 'slots' — execAssign","text":"integer matrix.    行は全スロットがクローズするまでの対象者。0行かもしれないことに注意。    行名はmbPERSON_CAT_USEの該当行の行名。    列は、左から順に以下の通り。ただし、    カテゴリ番号とはmbPERSON_CAT_USEにおける列番号を指し、    スロット番号とはlPERSON_SLOT_HITの当該カテゴリにおける列番号を指す。  SEQ: 1             調査参加順(連番) nPerson:           対象者番号 (mbPERSON_CAT_USE上の行番号) nCat_1:            割付カテゴリ1のカテゴリ番号、ないしNA ... nCat_(nCAT_MAX):   割付カテゴリnCAT_MAXのカテゴリ番号、ないしNA nCat:              割付スロットが属するカテゴリ番号、ないしNA nSlot_1:           割付スロット1のスロット番号、ないしNA ... nSlot_(nSLOT_MAX): 割付スロットnSLOT_MAXのスロット番号、ないしNA","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/execRetrials.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal: run simulations of retrials — execRetrials","title":"Internal: run simulations of retrials — execRetrials","text":"Internal: 再割付シミュレーションを行う. simWeight(), simBias()からコールされる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/execRetrials.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal: run simulations of retrials — execRetrials","text":"","code":"execRetrials(   lSURVEY,   bREDRAW,   nBLOCKSIZE,   nNUMBLOCK,   bPARALLEL,   sLOGFILE,   sVERBOSE = c(\"simple\", \"detail\", \"none\") )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/execRetrials.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal: run simulations of retrials — execRetrials","text":"lSURVEY `surveydata`-class object. 調査データ。makeSurveyで生成する。 bREDRAW boolean. 復元抽出するか。FALSEにすると、lSURVEY上での対象者順を固定する。 nBLOCKSIZE integer. ブロック内の再割付試行数。 nNUMBLOCK integer. 実行する再割付試行のブロック数。 bPARALLEL logical. 並列処理するか。 sLOGFILE string. 並列処理する場合のログファイル(フルパス)。NULLだとログを出さない。 sVERBOSE 文字列。 画面表示レベル。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/execRetrials.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal: run simulations of retrials — execRetrials","text":"データフレームのリスト。要素は次の通り:  dfStat_Cat: カテゴリ割付頻度 dfStat_Slot: スロット割付頻度 カテゴリ割付頻度: 行は調査対象者x割付可能カテゴリを表す。    列は以下のとおり(順不同):  nBlock:            ブロック番号 nBlockSize:        ブロックサイズ(ブロック内の再割付試行数) nSubject:          調査対象者番号 nCat:              カテゴリ番号 bAssign            割付試行で割付が起きていたか nCount_Subject:    ブロック内の再割付試行で調査対象者が出現した回数 nCount_SubjectCat: ブロック内の再割付試行で調査対象者が出現しカテゴリに割り付けられた回数 スロット割付頻度: 行は調査対象者x割付可能スロットを表す。    割付試行において割付可能性が判明しているスロットに    限定されることに注意(つまり、代替対象者のスロットは含まれない)    列は以下のとおり(順不同):  nBlock:             ブロック番号 nBlockSize:         ブロックサイズ(ブロック内の再割付試行数) nSubject:           調査対象者番号 nCat:               スロットが属するカテゴリ番号 nSlot:              スロット番号 bAssign             割付試行で割付が起きていたか nCount_Subject:     ブロック内の再割付試行で調査対象者が出現した回数 nCount_SubjectSlot: ブロック内の再割付試行で調査対象者が出現しスロットに割り付けられた回数","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/execTrials.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal: run simulation of assignment — execTrials","title":"Internal: run simulation of assignment — execTrials","text":"Internal: 割付シミュレーションを行う. simSize(), simBias()からコールされる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/execTrials.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal: run simulation of assignment — execTrials","text":"","code":"execTrials(   lPOP,   lSETTING,   nNUMTRIAL,   bPARALLEL,   sLOGFILE,   sVERBOSE = c(\"simple\", \"detail\", \"none\") )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/execTrials.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal: run simulation of assignment — execTrials","text":"lPOP `popdata`クラスのオブジェクト。 母集団データ。makePopで生成する。 lSETTING `assignsetting`クラスのオブジェクト。 割付のセッティング。makeSetting で生成する。 nNUMTRIAL 整数。 割付シミュレーションの試行数。 bPARALLEL logical. 並列処理するか。 sLOGFILE string. 並列処理する場合のログファイル(フルパス)。NULLだとログを出さない。 sVERBOSE 文字列。 画面表示レベル。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/execTrials.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal: run simulation of assignment — execTrials","text":"データフレーム。    行はある試行のある調査参加者を表す。    列は以下のとおり(順不同):  nSubject:         対象者番号 (調査参加順の連番) nPerson:          母集団メンバー番号 (lPOP$mbCATの行番号) sRowname:         lPOP$mbCATの行名。lPOP$mbCATに行名がない場合はas.character(SEQ)となる nCat_1:           割付カテゴリ1のカテゴリ番号(lPOP$mbCATの列番号)、ないしNA ... nCat_(nMAXCAT):   割付カテゴリnMAXCATのカテゴリ番号(lPOP$mbCATの列番号)、ないしNA nCat:             割付スロットが属するカテゴリ番号(lPOP$mbCATの列番号)、ないしNA nSlot_1:          割付スロット1のスロット番号(lPOP$mbSLOT[[nCat]]の列番号)、ないしNA ... nSlot_(nMAXSLOT): 割付スロットnMAXSLOTのスロット番号(lPOP$mbSLOT[[nCat]]の列番号)、ないしNA","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/getBias.html","id":null,"dir":"Reference","previous_headings":"","what":"get results of simulations to estimate bias — getBias","title":"get results of simulations to estimate bias — getBias","text":"バイアス評価シミュレーションの結果を取得する","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/getBias.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"get results of simulations to estimate bias — getBias","text":"","code":"getBias(   sDBPATH,   sDBTABLE_CAT = \"weight_cat\",   sDBTABLE_SLOT = \"weight_slot\",   sTYPE = c(\"cat\", \"slot\") )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/getBias.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"get results of simulations to estimate bias — getBias","text":"sDBPATH 文字列。 シミュレーションの結果を保存したSQLite DBのフルパス sDBTABLE_CAT 文字列。 シミュレーションの結果得られたカテゴリ割付頻度を保存したSQLite DBのテーブル名 sDBTABLE_SLOT 文字列。 シミュレーションの結果得られたスロット割付頻度を保存したSQLite DBのテーブル名 sTYPE 文字列。 取得する結果のタイプ。 \"cat\":  試行xカテゴリ別のバイアス \"slot\": 試行xスロット別のバイアス","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/getBias.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"get results of simulations to estimate bias — getBias","text":"データフレーム。  sTYPE == \"cat\"のとき、行はある割付試行におけるあるカテゴリを表す。    列は以下のとおり:  nTrial: 試行番号 nCat: カテゴリ番号 nNumAssignable: 割付可能な対象者数 nNumAssign:     割付された対象者数 gCVHatP: 割付確率の推定値の変動係数 gHatCVP: 割付確率の変動係数の推定値 gHatDeff: デザイン効果の推定値 gHatESS: 実質標本サイズの推定値 gCovHatQR: スケーリングした割り付け確率の推定値と割付可能レシオ(全カテゴリに占める割付可能カテゴリの割合)との共分散の推定値 gBarR_P: 割付可能対象者における割付可能レシオの平均 gBarR_S: 割り付けられた対象者における割付可能レシオの平均  sTYPE == \"slot\"のとき、行はある試行におけるあるカテゴリのあるスロットを表す。    列は以下のとおり:  nTrial: 試行番号 nCat: カテゴリ番号 nSlot: スロット番号 nNumAssignable: 割付可能な対象者数 nNumAssign:     割付された対象者数 gCVHatP: 割付確率の推定値の変動係数 gHatCVP: 割付確率の変動係数の推定値 gHatDeff: デザイン効果の推定値 gHatESS: 実質標本サイズの推定値 gCovHatQR: スケーリングした割り付け確率の推定値と割付可能レシオ(全カテゴリに占める割付可能カテゴリの割合)との共分散の推定値 gBarR_P: 割付可能対象者における割付可能レシオの平均 gBarR_S: 割り付けられた対象者における割付可能レシオの平均","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/getCandidate.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal: get nSIZE elements from anCANDIDATE in the order of anSORTKEY.\r\nReturn all possible combinations if anSORTKEY has tied values. — getCandidate","title":"Internal: get nSIZE elements from anCANDIDATE in the order of anSORTKEY.\r\nReturn all possible combinations if anSORTKEY has tied values. — getCandidate","text":"Internal: anCANDIDATEからanSORTKEYが小さい順にnSIZE個の要素を取り出す。 anSORTKEYにタイがあるときはありうる取り出し方をすべて返す。 sub_checkcat(), sub_checkslot()からコールされる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/getCandidate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal: get nSIZE elements from anCANDIDATE in the order of anSORTKEY.\r\nReturn all possible combinations if anSORTKEY has tied values. — getCandidate","text":"","code":"getCandidate(anCANDIDATE, agSORTKEY, nSIZE, bDEBUG = FALSE)"},{"path":"https://shigono.github.io/rSurveyAssign/reference/getCandidate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal: get nSIZE elements from anCANDIDATE in the order of anSORTKEY.\r\nReturn all possible combinations if anSORTKEY has tied values. — getCandidate","text":"anCANDIDATE integer vector. 候補。長さ0以上、重複なし。欠損不可。 agSORTKEY numerical vector. ソートキー。anCANDIDATEと同じ長さ。タイが許される。欠損不可。 nSIZE integer. 取り出す要素数。0以上の整数。欠損不可 DEBUG logical. デバッグモード","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/getCandidate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal: get nSIZE elements from anCANDIDATE in the order of anSORTKEY.\r\nReturn all possible combinations if anSORTKEY has tied values. — getCandidate","text":"list.     要素はある取り出し方による要素ベクトル。長さはnSIZE","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/getSize.html","id":null,"dir":"Reference","previous_headings":"","what":"get results of simulations for forecasting sample size — getSize","title":"get results of simulations for forecasting sample size — getSize","text":"標本サイズ予測シミュレーションの結果を取得する","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/getSize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"get results of simulations for forecasting sample size — getSize","text":"","code":"getSize(sDBPATH, sDBTABLE = \"size\", sTYPE = c(\"subject\", \"cat\", \"slot\"))"},{"path":"https://shigono.github.io/rSurveyAssign/reference/getSize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"get results of simulations for forecasting sample size — getSize","text":"sDBPATH 文字列。 シミュレーションの結果を保存するSQLite DBのフルパス sDBTABLE 文字列。 シミュレーションの結果を保存するSQLite DBのテーブル名 sTYPE 文字列。 取得する結果のタイプ。以下のいずれか: \"subject\": 標本サイズ(調査参加者数) \"cat\": カテゴリ票数 \"slot\": スロット票数","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/getSize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"get results of simulations for forecasting sample size — getSize","text":"データフレーム。  sTYPE == \"subject\"のとき、行は試行を表す。    列は以下のとおり:  nTrial: 試行番号 nNum_scr: 調査対象者 nNum_main: 調査対象者のうち、スロット割付を受けた人数  sTYPE == \"cat\"のとき、行はある試行におけるあるカテゴリを表す。    列は以下のとおり:  nTrial: 試行番号 nCat: カテゴリ番号 nNum: そのカテゴリを割り付けられた人数  sTYPE == \"slot\"のとき、行はある試行におけるあるカテゴリを表す。    列は以下のとおり:  nTrial: 試行番号 nCat:   カテゴリ番号 nSlot:  スロット番号 nNum:   そのスロットを割り付けられた人数 いずれも、抽出が行われなかった試行については出力されない。    すべての試行で抽出が行われていない場合は0行のデータフレームとなる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/getSize_raw.html","id":null,"dir":"Reference","previous_headings":"","what":"get rawdata of simulations for forecasting sample size — getSize_raw","title":"get rawdata of simulations for forecasting sample size — getSize_raw","text":"標本サイズ予測シミュレーションのローデータを取得する","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/getSize_raw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"get rawdata of simulations for forecasting sample size — getSize_raw","text":"","code":"getSize_raw(sDBPATH, sDBTABLE = \"size\", nTRIAL = NULL)"},{"path":"https://shigono.github.io/rSurveyAssign/reference/getSize_raw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"get rawdata of simulations for forecasting sample size — getSize_raw","text":"sDBPATH 文字列。 シミュレーションの結果を保存するSQLite DBのフルパス sDBTABLE 文字列。 シミュレーションの結果を保存するSQLite DBのテーブル名 nTRIAL 整数。 試行番号。存在しないときは0行のデータを返す。 指定しないときは全試行を返す","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/getSize_raw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"get rawdata of simulations for forecasting sample size — getSize_raw","text":"データフレーム。列はsimSizeを参照。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/getWeight.html","id":null,"dir":"Reference","previous_headings":"","what":"get results of simulations for computing weights — getWeight","title":"get results of simulations for computing weights — getWeight","text":"ウェイト算出シミュレーションの結果を取得する","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/getWeight.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"get results of simulations for computing weights — getWeight","text":"","code":"getWeight(   lSURVEY,   sDBPATH,   sDBTABLE_CAT = \"weight_cat\",   sDBTABLE_SLOT = \"weight_slot\",   bCHECKDB = TRUE )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/getWeight.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"get results of simulations for computing weights — getWeight","text":"lSURVEY `surveydata`クラスのオブジェクト。 調査データ。makeSurveyで生成する。 sDBPATH 文字列。 シミュレーションの結果を保存したSQLite DBのフルパス sDBTABLE_CAT 文字列。 シミュレーションの結果得られたカテゴリ割付頻度を保存したSQLite DBのテーブル名 sDBTABLE_SLOT 文字列。 シミュレーションの結果得られたスロット割付頻度を保存したSQLite DBのテーブル名 bCHECKDB 論理値。 指定されたSQLite DBをチェックするか。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/getWeight.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"get results of simulations for computing weights — getWeight","text":"list. 要素は次の通り。  dfWeight_Cat: data frame. 行はある対象者のある割付カテゴリ dfWeight_Slot: data frame. 行はある対象者のある割付スロット","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makePop.html","id":null,"dir":"Reference","previous_headings":"","what":"make population data — makePop","title":"make population data — makePop","text":"母集団データを作成する。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makePop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"make population data — makePop","text":"","code":"makePop(mbCAT, lSLOT, sVERBOSE = c(\"simple\", \"none\", \"detail\"))"},{"path":"https://shigono.github.io/rSurveyAssign/reference/makePop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"make population data — makePop","text":"mbCAT integer matrix.    母集団メンバーのカテゴリ割付可能性を表す。 mbCAT[,j]は以下を表す。欠損不可。 1: 母集団メンバーiはカテゴリjについて割付可能。 0: 母集団メンバーiはカテゴリjについて割付不能。 列に名前を付けるとカテゴリ名とみなされる。    名前を付けるならばすべての列に重複なく名前をつけること。 lSLOT list integer matrices.    母集団メンバーのスロット割付可能性を表す。 lSLOT[[j]][,k]は以下を表す。 1: 母集団メンバーiはカテゴリjのスロットkについて割付可能。 0: 母集団メンバーiはカテゴリjのスロットkについて割付不能。 mbCAT[,j] == 0のとき、    lSLOT[[j]][, ]はすべて欠損として扱われる    (すなわち、割付不能カテゴリに属するスロットへの割付可能性は    無視される)。 mbCAT[,j] == 1のとき、    lSLOT[[j]][, ]は欠損不可    (すなわち、割付不能カテゴリに属するスロットへの割付可能性は    すべて記述する必要がある)。 列に名前を付けた場合はスロット名とみなされる。    名前を付けるならばすべての列に重複なく名前をつけること。 sVERBOSE string. 画面表示レベル。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makePop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"make population data — makePop","text":"object `popdata` class. その実体は以下の要素を持つリスト。 mbCAT 整数行列。                    引数mbCATとして与えられた行列。                    列名がついていなかった場合は、                    列名\"Cat_(j)\"が付与される。 lSLOT 整数行列のリスト。                    引数lSLOTとして与えられたリスト。                    ただし、割付不能カテゴリに属するスロットへの                    割付可能性はすべて欠損に置き換えられている。                    引数lSLOTの要素に列名が付いていなかった場合は、                    列名\"Slot_(j)_(k)\"が付与される。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeRetrial.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal: run execAssign() once — makeRetrial","title":"Internal: run execAssign() once — makeRetrial","text":"Internal: 再割付試行を1試行実行する。 makeRetrialBlock()からコールされる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeRetrial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal: run execAssign() once — makeRetrial","text":"","code":"makeRetrial(   lSURVEY,   bREDRAW,   nMAXSIZE,   sVERBOSE = c(\"simple\", \"detail\", \"none\") )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeRetrial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal: run execAssign() once — makeRetrial","text":"lSURVEY `surveydata`-class object. survey data. See document `makeSurvey` details. bREDRAW boolean. 復元抽出するか。FALSEにすると、lSURVEY上での対象者順を固定する。 nMAXSIZE integer. 復元抽出する対象者の最大数。bREDRAW=FALSEの場合は無視される sVERBOSE 文字列。画面表示レベル。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeRetrial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal: run execAssign() once — makeRetrial","text":"data frame.    列は以下のとおり(順不同):  SEQ:              調査参加順(連番) nPerson:          対象者番号 (lSURVEY$mbCAT上の行番号)                                   母集団メンバーの番号ではないことに注意 nCat_1:           割付カテゴリ1のカテゴリ番号、ないしNA ... nCat_(nMAXCAT):   割付カテゴリlSURVEY$nMAXCATのカテゴリ番号、ないしNA nCat:             割付スロットが属するカテゴリ番号、ないしNA nSlot_1:          割付スロット1のスロット番号、ないしNA ... nSlot_(nMAXSLOT): 割付スロットlSURVEY$nMAXSLOTのスロット番号、ないしNA","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeRetrialBlock.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal: run execAssign() repeatedly to compute weight — makeRetrialBlock","title":"Internal: run execAssign() repeatedly to compute weight — makeRetrialBlock","text":"Internal: 再割付試行を1ブロック実行する。execRetrials()からコールされる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeRetrialBlock.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal: run execAssign() repeatedly to compute weight — makeRetrialBlock","text":"","code":"makeRetrialBlock(   lSURVEY,   nBLOCKSIZE,   bREDRAW,   nMAXSIZE,   bPARALLEL,   sLOGFILE,   sVERBOSE = c(\"simple\", \"detail\", \"none\") )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeRetrialBlock.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal: run execAssign() repeatedly to compute weight — makeRetrialBlock","text":"lSURVEY `surveydata`-class object. survey data. See document `makeSurvey` details. nBLOCKSIZE 整数。 試行ブロック内の試行数 bREDRAW boolean. 復元抽出するか。FALSEにすると、lSURVEY上での対象者順を固定する。 nMAXSIZE integer. 復元抽出する対象者の最大数。bREDRAW=FALSEの場合は無視される bPARALLEL logical 並列処理するか sLOGFILE string. 並列処理する場合のログファイルの名前. NULLだとログを出さない sVERBOSE 文字列。画面表示レベル。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeRetrialBlock.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal: run execAssign() repeatedly to compute weight — makeRetrialBlock","text":"data frame.    列は以下のとおり(順不同):  nRetrial:         再割付試行番号 nSubject:         対象者番号 (lSURVEY$mbCAT上の行番号) SEQ:              再割付試行における調査参加順(連番) nCat_1:           割付カテゴリ1のカテゴリ番号、ないしNA ... nCat_(nMAXCAT):   割付カテゴリlSURVEY$nMAXCATのカテゴリ番号、ないしNA nCat:             割付スロットが属するカテゴリ番号、ないしNA nSlot_1:          割付スロット1のスロット番号、ないしNA ... nSlot_(nMAXSLOT): 割付スロットlSURVEY$nMAXSLOTのスロット番号、ないしNA","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeSetting.html","id":null,"dir":"Reference","previous_headings":"","what":"make setting — makeSetting","title":"make setting — makeSetting","text":"割付のセッティングを作成する。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeSetting.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"make setting — makeSetting","text":"","code":"makeSetting(   lSLOT_REQUEST,   nCAT_MAX,   nSLOT_MAX,   sCAT_TYPE = c(\"adaptive\", \"nonadaptive\"),   sCAT_FILTER = c(\"all\", \"open\"),   sCAT_ORDER = c(\"random\", \"openclosed\", \"shortnum\", \"shortratio\"),   sCAT_EXCLUDE = c(\"none\", \"allclosed\"),   sSLOT_TYPE = c(\"adaptive\", \"nonadaptive\"),   sSLOT_FILTER = c(\"all\", \"open\"),   sSLOT_ORDER = c(\"random\", \"openclosed\", \"shortnum\", \"shortratio\"),   sSLOT_EXCLUDE = c(\"none\", \"allclosed\"),   nSUBJECT_MAX = 0,   sVERBOSE = c(\"simple\", \"none\", \"detail\") )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeSetting.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"make setting — makeSetting","text":"lSLOT_REQUEST list (named) integer vectors. 各スロットに割り付ける対象者数の目標。 要素jのベクトルの要素kは, カテゴリjのスロットkに割り付ける対象者の下限を表す。 欠損不可。 要素に名前がついている場合、スロット名とみなされるので、 名前を付けるならばすべての要素に重複なく名前をつけること。 nCAT_MAX integer. ある対象者に割り付けるカテゴリ数の上限。 nSLOT_MAX integer. ある対象者に割り付けるスロット数の上限。 sCAT_TYPE string. カテゴリ割付タイプ。詳細はvignetteを参照。 sCAT_FILTER string. カテゴリ割付の際の絞り込み条件。詳細はvignetteを参照。 sCAT_ORDER string. カテゴリ割付の際の順序付け条件。詳細はvignetteを参照。 sCAT_EXCLUDE string. カテゴリ割付の際の除外条件。詳細はvignetteを参照。 sSLOT_TYPE string. スロット割付タイプ。詳細はvignetteを参照。 sSLOT_FILTER string. スロット割付の際の絞り込み条件。詳細はvignetteを参照。 sSLOT_ORDER string. スロット割付の際の順序付け条件。詳細はvignetteを参照。 sSLOT_EXCLUDE string. スロット割付の際の除外条件。指定は必須。詳細はvignetteを参照。 nSUBJECT_MAX integer.    抽出する対象者数の上限。0以上の整数。 0より大きい値が指定された場合、    対象者抽出は、    対象者数がnSUBJECT_MAXに達するか、すべてのスロットの割付対象者数が    lSLOT_REQUESTに設定された目標に達したときに終了する。 0が指定された場合、    対象者抽出は、すべてのスロットの割付対象者数が目標に達したときにのみ正常終了する。    対象者数が母集団サイズの10倍を超えても    割付対象者数が目標に到達しなかったときはエラーとなる。 sVERBOSE string. 画面表示レベル。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeSetting.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"make setting — makeSetting","text":"object `assignsetting` class.         その実体は、この関数の引数を要素として持つリスト。         ただし、引数lSLOT_REQUESTの要素に名前がついていない場合は、         名前\"Slot_(j)_(k)\"が付与される。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeStat_Cat.html","id":null,"dir":"Reference","previous_headings":"","what":"Interal: make statistics for categories — makeStat_Cat","title":"Interal: make statistics for categories — makeStat_Cat","text":"Internal: カテゴリ割付頻度を集計する。execRetrials()からコールされる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeStat_Cat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interal: make statistics for categories — makeStat_Cat","text":"","code":"makeStat_Cat(   dfReplicateBlock,   lSURVEY,   sVERBOSE = c(\"simple\", \"detail\", \"none\") )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeStat_Cat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interal: make statistics for categories — makeStat_Cat","text":"dfReplicateBlock data frame 対象者のカテゴリ・ウェイトへの割付を反復実行した結果。 以下の列を持つと期待される nSubject:         対象者番号 nCat_1:           割付カテゴリ1のカテゴリ番号、ないしNA ... nCat_(nMAXCAT):   割付カテゴリnMAXCATのカテゴリ番号、ないしNA nCat:             割付スロットが属するカテゴリ番号、ないしNA nSlot_1:          割付スロット1のスロット番号、ないしNA ... nSlot_(nMAXSLOT): 割付スロットnMAXSLOTのスロット番号、ないしNA lSURVEY `surveydata`-class object. survey data. See document `makeSurvey` details. sVERBOSE 文字列。 画面表示レベル。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeStat_Cat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interal: make statistics for categories — makeStat_Cat","text":"data frame    行は対象者x割付可能カテゴリ  nSubject          対象者番号 nCat              カテゴリ番号 bAssign           lSURVEY上で割付が起きていたか nCount_SubjectCat 再試行においてその人にそのカテゴリが割り付けられた回数 nCount_Subject    再試行におけるその人の出現回数","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeStat_Slot.html","id":null,"dir":"Reference","previous_headings":"","what":"Interal: make statistics for slots — makeStat_Slot","title":"Interal: make statistics for slots — makeStat_Slot","text":"Internal: スロット割付頻度を集計する。execRetrials()からコールされる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeStat_Slot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interal: make statistics for slots — makeStat_Slot","text":"","code":"makeStat_Slot(   dfReplicateBlock,   lSURVEY,   sVERBOSE = c(\"simple\", \"detail\", \"none\") )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeStat_Slot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interal: make statistics for slots — makeStat_Slot","text":"dfReplicateBlock data frame 対象者のカテゴリ・ウェイトへの割付を反復実行した結果。 以下の列を持つと期待される nSubject:         対象者番号 nCat_1:           割付カテゴリ1のカテゴリ番号、ないしNA ... nCat_(nMAXCAT):   割付カテゴリnMAXCATのカテゴリ番号、ないしNA nCat:             割付スロットが属するカテゴリ番号、ないしNA nSlot_1:          割付スロット1のスロット番号、ないしNA ... nSlot_(nMAXSLOT): 割付スロットnMAXSLOTのスロット番号、ないしNA lSURVEY `surveydata`-class object. survey data. See document `makeSurvey` details. sVERBOSE 文字列。 画面表示レベル。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeStat_Slot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interal: make statistics for slots — makeStat_Slot","text":"data frame    行は対象者x割付可能スロット。lSURVEY上で割付可能性が判明しているスロットに    限定されることに注意(つまり、代替対象者のスロットは含まれない)    列は以下の通り  nSubject           対象者番号 nCat               親カテゴリ番号 nSlot              スロット番号 bAssign            lSURVEY上でそのスロットが割り付けられていたか nCount_SubjectSlot その人にそのスロットが割り付けられた回数 nCount_Subject     その人の出現回数","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeSurvey.html","id":null,"dir":"Reference","previous_headings":"","what":"make survey data — makeSurvey","title":"make survey data — makeSurvey","text":"調査データを作成する.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeSurvey.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"make survey data — makeSurvey","text":"","code":"makeSurvey(   mbCAT,   lSLOT,   lSLOT_REQUEST,   mnASSIGNCAT,   anPARENTCAT,   mnASSIGNSLOT,   sCAT_TYPE = c(\"adaptive\", \"nonadaptive\"),   sCAT_FILTER = c(\"all\", \"open\"),   sCAT_ORDER = c(\"random\", \"openclosed\", \"shortnum\", \"shortratio\"),   sCAT_EXCLUDE = c(\"none\", \"allclosed\"),   sSLOT_TYPE = c(\"adaptive\", \"nonadaptive\"),   sSLOT_FILTER = c(\"all\", \"open\"),   sSLOT_ORDER = c(\"random\", \"openclosed\", \"shortnum\", \"shortratio\"),   sSLOT_EXCLUDE = c(\"none\", \"allclosed\"),   nSUBJECT_MAX = NULL,   sVERBOSE = c(\"simple\", \"none\", \"detail\") )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeSurvey.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"make survey data — makeSurvey","text":"mbCAT 整数行列。 調査対象者のカテゴリ割付可能性。 mbCAT[,j]は以下を表す。欠損不可。 1: 調査対象者iはカテゴリjについて割付可能。 0: 調査対象者iはカテゴリjについて割付不能。 列に名前を付けるとカテゴリ名とみなされる。 名前を付けるならばすべての列に重複なく名前をつけること。 lSLOT 整数行列のリスト。 調査対象者のスロット割付可能性。 lSLOT[[j]][,k]は以下を表す。 1: 調査対象者iはカテゴリjのスロットkについて割付可能。 0: 調査対象者iはカテゴリjのスロットkについて割付不能。 欠損についてはDetailsを参照。 列に名前を付けるとスロット名とみなされる。 名前を付けるならばすべての列に重複なく名前をつけること。 lSLOT_REQUEST 整数ベクトルのリスト。 各スロットに割り付ける対象者数の下限。 要素jのベクトルの要素kは, カテゴリjのスロットkに割り付ける対象者の下限を表す。 欠損なし。 要素の列名はlSLOTの要素の列名と一致していること。 mnASSIGNCAT 整数行列。 調査対象者の割付カテゴリ。列数は、割付カテゴリ数の上限。 mnASSIGNCAT[,j]は、調査対象者iのj番目の割付カテゴリ番号(mbCATの列番号)を表す。 調査対象者iの割付カテゴリ数が列数より小さい場合はNAを埋める。 列順には意味がない。 anPARENTCAT 整数ベクトル。 調査対象者の割付スロットが属するカテゴリ。 anPARENTCAT[]は、調査対象者iの割付スロットが属するカテゴリ番号(mbCATの列番号)を表す。 調査対象者iがスロットに割り付けられなかった場合はNAを埋める。 mnASSIGNSLOT 整数行列。 調査対象者の割付スロット。列数は、割付スロット数の上限。 mnASSIGNSLOT[,j]は、調査対象者iの割付スロット番号(lSLOT[[anPARENTCAT[]]]の列番号)を 表す。調査対象者iの割付スロット数が列数より小さい場合はNAを埋める。 列順には意味がない。 sCAT_TYPE 文字列。 カテゴリ割付タイプ。指定は必須。詳細はvignetteを参照。 sCAT_FILTER 文字列。 カテゴリ割付の際の絞り込み条件。指定は必須。詳細はvignetteを参照。 sCAT_ORDER 文字列。 カテゴリ割付の際の順序付け条件。指定は必須。詳細はvignetteを参照。 sCAT_EXCLUDE 文字列。 カテゴリ割付の際の除外条件。指定は必須。詳細はvignetteを参照。 sSLOT_TYPE 文字列。 スロット割付タイプ。指定は必須。詳細はvignetteを参照。 sSLOT_FILTER 文字列。 スロット割付の際の絞り込み条件。指定は必須。詳細はvignetteを参照。 sSLOT_ORDER 文字列。 スロット割付の際の順序付け条件。指定は必須。詳細はvignetteを参照。 sSLOT_EXCLUDE 文字列。 スロット割付の際の除外条件。指定は必須。詳細はvignetteを参照。 nSUBJECT_MAX 整数。    抽出する対象者数の上限。 nSUBJECT_MAXが指定された場合、    対象者抽出は、    対象者数がnSUBJECT_MAXに達するか、すべてのスロットの割付対象者数が    lSLOT_REQUESTに設定された目標に達したときに終了する。 nSUBJECT_MAXがNULLの場合、    対象者抽出は、すべてのスロットの割付対象者数が目標に達したときにのみ正常終了する。    対象者数が母集団サイズの10倍を超えても    割付対象者数が目標に到達しなかったときはエラーとなる。 sVERBOSE 文字列。 画面表示レベル。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeSurvey.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"make survey data — makeSurvey","text":"`surveydata`クラスのオブジェクト。その実体は以下の要素を持つリスト。 mbCAT         整数行列。引数mbCATの値。                            列名がついていなかった場合は、                            列名\"Cat_(j)\"が付与される。 lSLOT         整数行列のリスト。引数lSLOTの値。ただし、割付不能カテゴリの                            スロット割付可能性はすべてNAに変更される。また、要素の行にひとつでもNAがあったら                            その行はみなNAに変更される。                            列名がついていなかった場合は、                            列名\"Slot_(j)_(k)\"が付与される。 lSLOT_REQUEST 整数ベクトルのリスト。引数lSLOT_REQUESTの値。                            名前がついていなかった場合は、                            名前\"Slot_(j)_(k)\"が付与される。 sCAT_TYPE     文字列。引数sCAT_TYPEの値。 sCAT_FILTER   文字列。引数sCAT_FILTERの値。 sCAT_ORDER    文字列。引数sCAT_ORDERの値。 sCAT_EXCLUDE  文字列。引数sCAT_EXCLUDEの値。 sSLOT_TYPE    文字列。引数sSLOT_TYPEの値。 sSLOT_FILTER  文字列。引数sSLOT_FILTERの値。 sSLOT_ORDER   文字列。引数sSLOT_ORDERの値。 sSLOT_EXCLUDE 文字列。引数sSLOT_EXCLUDEの値。 mnASSIGNCAT   整数行列。引数mnASSIGNCATの値。 anPARENTCAT   整数ベクトル。引数anPARENTCATの値。 mnASSIGNSLOT  整数行列。引数mnASSIGNSLOTの値。 nSUBJECT_MAX  整数。引数nSUBJECT_MAXの値。 manSubjectCat_AltSubject 整数ベクトルを要素とする行列。行は対象者(mbCATの行),                                       列はカテゴリ(mbCATの列),                                       要素はその対象者のスロット割付可能性を調べるときに                                       参照すべき対象者番号のベクトル。 mnSubjectCat_AltStatus   整数ベクトルの行列。行は対象者(mbCATの行),                                       列はカテゴリ(mbCATの列), 要素は以下のいずれか: NA: 割付不能カテゴリ 0: スロット割付可能性が既知 1: スロット割付可能性が未知であるためカテゴリ割付可能性が同じ対象者で代替 2: スロット割付可能性が未知であるため割付カテゴリ数が同じ対象者で代替 3: スロット割付可能性が未知であるためランダムに選んだ対象者で代替","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/makeSurvey.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"make survey data — makeSurvey","text":"lSLOTの欠損は以下のように扱われる。 Case 1. mbCAT[,j] == 0のとき、   lSLOT[[j]][, ]は無視される。すなわち、   ある対象者があるカテゴリに対して割付不能な時、   その対象者のそのカテゴリに属するスロットへの割付可能性は未知として扱われ、   指定しても無視される。 Case 2. mbCAT[,j] == 1でありj がmnASSIGNCAT[,]に含まれているとき、   lSLOT[[j]][, ]の欠損は許されない。すなわち、   ある対象者があるカテゴリに割り付けられた場合、   その対象者のそのカテゴリに属するスロットへの割付可能性は既知であるはずなので、   指定しなければならない。 Case 3. mbCAT[,j] == 1でありj がmnASSIGNCAT[,]に含まれていないとき、   lSLOT[[j]][, ]の欠損はある程度まで許容される。すなわち、   ある対象者があるカテゴリに割付可能であったが割り付けられなかった場合、   その対象者のそのカテゴリに属するスロットへの割付可能性は、分かっている限りにおいて   指定すればよい。ある行に欠損がある場合、その行はすべて欠損とみなされる。 Case 3.に相当する調査対象者も、   再割付シミュレーションにおいてカテゴリ j に割り付けられる可能性がある。   そのため、jに属するスロットへの割付可能性が欠損である調査対象者については、   それらの欠損を補完する必要が生じる。このとき、   SurveyAssignパッケージによるシミュレーションでは、   調査対象者 の割付可能性を   他の調査対象者 ' の割付可能性によって置き換える。   ' はシミュレーション試行ごとに、次の手順で選ばれる。 Step 1. jに属するスロットへの割付可能性が既知であり、   かつJ個のカテゴリへの割付可能性が と同一である人の中からランダムに選ぶ。 Step 2. みつからなかった場合は、jに属するスロットへの割付可能性が既知であり、   かつ割付可能なカテゴリの数が同一である人の中からランダムに選ぶ。 Step 3. みつからなかった場合は、jに属するスロットへの割付可能性が既知である   人の中からランダムに選ぶ。 makeSurveyは、今後のシミュレーションの際に   上記の手順での補完が可能かどうかをチェックし、Step 1で補完できない人が   出現した場合には警告を表示する。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/popdata.html","id":null,"dir":"Reference","previous_headings":"","what":"population data — popdata","title":"population data — popdata","text":"vignetteでの説明に用いる母集団データ。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/popdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"population data — popdata","text":"","code":"data(popdata)"},{"path":"https://shigono.github.io/rSurveyAssign/reference/popdata.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"population data — popdata","text":"object class data.frame 10000 rows 34 columns.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/popdata.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"population data — popdata","text":"母集団をサイズ10000の有限集団として近似的に表現している。 カテゴリ数3, 各カテゴリは10スロットを持つ。 以下の列を持つ。 nID 母集団メンバーID nCat_1 カテゴリ1の割付可能性(0:割付不能, 1:割付可能) nCat_2 カテゴリ2の割付可能性(0:割付不能, 1:割付可能) nCat_3 カテゴリ3の割付可能性(0:割付不能, 1:割付可能) bSlot_1_1 カテゴリ1, スロット1の割付可能性(0:割付不能, 1:割付可能, NA:カテゴリ1は割付不能) bSlot_1_2 カテゴリ1, スロット2の割付可能性(0:割付不能, 1:割付可能, NA:カテゴリ1は割付不能) ... bSlot_3_10 カテゴリ3, スロット10の割付可能性(0:割付不能, 1:割付可能, NA:カテゴリ3は割付不能)","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/rSurveyAssign-package.html","id":null,"dir":"Reference","previous_headings":"","what":"rSurveyAssign: tools for simulation of assignment in web surveys — rSurveyAssign-package","title":"rSurveyAssign: tools for simulation of assignment in web surveys — rSurveyAssign-package","text":"tools simulation assignment web surveys","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/rSurveyAssign-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"rSurveyAssign: tools for simulation of assignment in web surveys — rSurveyAssign-package","text":"package contains several tools simulate different types assignment processes web surveys. package, users can estimate sample sizes future surveys, assess bias future surveys, calculate survey weights actual surveys conducted. このパッケージは、web調査における対象者割付についてのシミュレーションを 行うためのパッケージです。これから行う調査について標本サイズを見積もったり、 バイアスを評価したり、すでに行った調査について調査ウェイトを求めたりすることができます。","code":""},{"path":[]},{"path":"https://shigono.github.io/rSurveyAssign/reference/rSurveyAssign-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"rSurveyAssign: tools for simulation of assignment in web surveys — rSurveyAssign-package","text":"Maintainer: Shigeru ONO elsur_2001@yahoo.co.jp","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/simBias.html","id":null,"dir":"Reference","previous_headings":"","what":"run simulations to evaluate bias — simBias","title":"run simulations to evaluate bias — simBias","text":"バイアス評価のためのシミュレーションを実行する","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/simBias.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"run simulations to evaluate bias — simBias","text":"","code":"simBias(   lPOP,   lSETTING,   nNUMTRIAL = 1,   nNUMRETRIAL = 1000,   bUSE_INFO_UNASSIGNED_CAT = TRUE,   bPARALLEL = FALSE,   sLOGFILE = NULL,   sDBPATH = NULL,   sDBTABLE_SUBJECT = \"subject\",   sDBTABLE_CAT = \"weight_cat\",   sDBTABLE_SLOT = \"weight_slot\",   bAPPEND = TRUE,   sVERBOSE = c(\"simple\", \"detail\", \"none\") )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/simBias.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"run simulations to evaluate bias — simBias","text":"lPOP `popdata`クラスのオブジェクト。 母集団データ。makePopで生成する。 lSETTING `assignsetting'クラスのオブジェクト。 割付のセッティング。makeSettingで生成する。 nNUMTRIAL 整数。 割付試行数。 nNUMRETRIAL 整数。 各割付試行における再割付試行数。 bUSE_INFO_UNASSIGNED_CAT 論理値。 再割付試行において、非割付カテゴリに属するスロットへの割付可能性を利用するか。 TRUEの場合、すべての割付可能カテゴリに属するスロット割付可能性を用いて 再割付試行を行う。 FALSEの場合、割付カテゴリに属するスロット割付可能性のみを用いて 再割付試行を行う。 bPARALLEL 論理値。 並列処理するか。 sLOGFILE 文字列。 並列処理する場合のログファイル(フルパス)。NULLだとログを出さない。 sDBPATH 文字列。 シミュレーションの結果を保存するSQLite DBのフルパス。 sDBTABLE_SUBJECT 文字列。 割付シミュレーションの結果を保存するSQLite DBのテーブル名。 sDBTABLE_CAT 文字列。 再割付シミュレーションの結果得られたカテゴリ割付頻度を保存するSQLite DBのテーブル名。 sDBTABLE_SLOT 文字列。 再割付シミュレーションの結果得られたスロット割付頻度を保存するSQLite DBのテーブル名。 bAPPEND 論理値。 TRUE: 結果をテーブルに追加する。FALSE: 上書きする。 sVERBOSE 文字列。 画面表示レベル。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/simBias.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"run simulations to evaluate bias — simBias","text":"sDBPATHを指定しない場合は、シミュレーションの結果をデータフレームのリストとして返す。 sDBPATHを指定した場合はNULLを返す。シミュレーションの結果は、            SQLiteデータベースにテーブルとして保存される。sDBPATH が存在する場合は、            bAPPEND==FALSEであればSDBPATHに上書きし、bAPPEND==TRUEであれば追加する。            sDBPATHが存在しない場合は新規作成する。 シミュレーションの結果は次の3つのデータフレームからなる。  dfSubject: 割付シミュレーションの結果。    行はある割付試行のある調査参加者を表す。    列は以下のとおり(順不同):  nTrial:           試行番号 nSubject:         対象者番号 (調査参加順の連番) nPerson:          母集団メンバー番号 (lPOP$mbCATの行番号) sRowname:         lPOP$mbCATの行名。lPOP$mbCATに行名がない場合はas.character(SEQ)となる nCat_1:           割付カテゴリ1のカテゴリ番号(lPOP$mbCATの列番号)、ないしNA ... nCat_(nMAXCAT):   割付カテゴリnMAXCATのカテゴリ番号(lPOP$mbCATの列番号)、ないしNA nCat:             割付スロットが属するカテゴリ番号(lPOP$mbCATの列番号)、ないしNA nSlot_1:          割付スロット1のスロット番号(lPOP$mbSLOT[[nCat]]の列番号)、ないしNA ... nSlot_(nMAXSLOT): 割付スロットnMAXSLOTのスロット番号(lPOP$mbSLOT[[nCat]]の列番号)、ないしNA  dfStat_Cat: 再割付シミュレーションにおけるカテゴリ割付頻度。    行は調査対象者x割付可能カテゴリを表す。    列は以下のとおり(順不同):  nTrial:            試行番号 nBlock:            ブロック番号 nBlockSize:        ブロックサイズ(ブロック内の再割付試行数) nSubject:          調査対象者番号 nCat:              カテゴリ番号 sRowname:           lPOP$mbCATの行名。lPOP$mbCATに行名がない場合はas.character(SEQ)となる nPerson:            母集団メンバー番号 (lPOP$mbCATの行番号) bAssign            割付試行で割付が起きていたか nCount_Subject:    ブロック内の再割付試行で調査対象者が出現した回数 nCount_SubjectCat: ブロック内の再割付試行で調査対象者が出現しカテゴリに割り付けられた回数 gAssignablity_Cat: カテゴリ割付可能度(全カテゴリに占める割付可能カテゴリの割合)  dfStat_Slot: 再割付シミュレーションにおけるスロット割付頻度。    行は調査対象者x割付可能スロットを表す。    割付試行において割付可能性が判明しているスロットに    限定される(代替対象者のスロットは含まれない)。    列は以下のとおり(順不同):  nTrial:             試行番号 nBlock:             ブロック番号 nBlockSize:         ブロックサイズ(ブロック内の再割付試行数) nSubject:           調査対象者番号 sRowname:           lPOP$mbCATの行名。lPOP$mbCATに行名がない場合はas.character(SEQ)となる nPerson:            母集団メンバー番号 (lPOP$mbCATの行番号) nCat:               スロットが属するカテゴリ番号 nSlot:              スロット番号 bAssign             割付試行で割付が起きていたか nCount_Subject:     ブロック内の再割付試行で調査対象者が出現した回数 nCount_SubjectSlot: ブロック内の再割付試行で調査対象者が出現しスロットに割り付けられた回数 gAssignablity_Slot: スロット割付可能度(全スロットに占める割付可能スロットの割合)","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/simBias.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"run simulations to evaluate bias — simBias","text":"bAPPEND==TRUEで、sDBPATHが存在し、かつ    テーブルsDBTABLE_SUBJECT, sDBTABLE_CAT, sDBTABLE_SLOTが存在しない場合はエラーとなる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/simSize.html","id":null,"dir":"Reference","previous_headings":"","what":"run simulations for forecasting sample size — simSize","title":"run simulations for forecasting sample size — simSize","text":"標本サイズ推定のためのシミュレーションを行う","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/simSize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"run simulations for forecasting sample size — simSize","text":"","code":"simSize(   lPOP,   lSETTING,   nNUMTRIAL = 1,   bPARALLEL = FALSE,   sLOGFILE = NULL,   sDBPATH = NULL,   sDBTABLE = \"size\",   bAPPEND = TRUE,   sVERBOSE = c(\"simple\", \"detail\", \"none\") )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/simSize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"run simulations for forecasting sample size — simSize","text":"lPOP `popdata`クラスのオブジェクト。 母集団データ。makePopで生成する。 lSETTING `assignsetting`クラスのオブジェクト。 割付のセッティング。makeSetting で生成する。 nNUMTRIAL 整数。 割付シミュレーションの試行数。 bPARALLEL 論理値。 並列処理するか。 sLOGFILE 文字列。 並列処理する場合のログファイル(フルパス)。NULLだとログを出さない。 sDBPATH 文字列。 シミュレーションの結果を保存するSQLite DBのフルパス。 sDBTABLE 文字列。 シミュレーションの結果を保存するSQLite DBのテーブル名。 bAPPEND 論理値。 TRUE: 結果をテーブルに追加する。FALSE: 上書きする。 sVERBOSE 文字列。 画面表示レベル。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/simSize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"run simulations for forecasting sample size — simSize","text":"sDBPATHを指定しない場合は、シミュレーションの結果をデータフレームとして返す。 sDBPATHを指定した場合はNULLを返す。シミュレーションの結果は、            SQLiteデータベースにテーブルとして保存される。sDBPATH が存在する場合は、            bAPPEND==FALSEであればSDBPATHに上書きし、bAPPEND==TRUEであれば追加する。            sDBPATHが存在しない場合は新規作成する。 シミュレーションの結果は以下の形式を持つ。    行はある試行のある調査参加者を表す。0行かもしれないことに注意。    列は以下のとおり(順不同):  nSubject:         対象者番号 (調査参加順の連番) nPerson:          母集団メンバー番号 (lPOP$mbCATの行番号) sRowname:         lPOP$mbCATの行名。lPOP$mbCATに行名がない場合はas.character(SEQ)となる nCat_1:           割付カテゴリ1のカテゴリ番号(lPOP$mbCATの列番号)、ないしNA ... nCat_(nMAXCAT):   割付カテゴリnMAXCATのカテゴリ番号(lPOP$mbCATの列番号)、ないしNA nCat:             割付スロットが属するカテゴリ番号(lPOP$mbCATの列番号)、ないしNA nSlot_1:          割付スロット1のスロット番号(lPOP$mbSLOT[[nCat]]の列番号)、ないしNA ... nSlot_(nMAXSLOT): 割付スロットnMAXSLOTのスロット番号(lPOP$mbSLOT[[nCat]]の列番号)、ないしNA","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/simSize.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"run simulations for forecasting sample size — simSize","text":"bAPPEND==TRUEで、sDBPATHが存在するがテーブルsDBTABLEが存在しない場合は エラーとなる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/simWeight.html","id":null,"dir":"Reference","previous_headings":"","what":"run simulations for computing weights — simWeight","title":"run simulations for computing weights — simWeight","text":"ウェイト算出のためのシミュレーションを実行する","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/simWeight.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"run simulations for computing weights — simWeight","text":"","code":"simWeight(   lSURVEY,   bREDRAW = TRUE,   nBLOCKSIZE = 100,   nNUMBLOCK = 1,   bPARALLEL = FALSE,   sLOGFILE = NULL,   sDBPATH = NULL,   sDBTABLE_CAT = \"weight_cat\",   sDBTABLE_SLOT = \"weight_slot\",   bAPPEND = FALSE,   sVERBOSE = c(\"simple\", \"detail\", \"none\") )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/simWeight.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"run simulations for computing weights — simWeight","text":"lSURVEY `surveydata`クラスのオブジェクト。 調査データ。makeSurveyで生成する。 bREDRAW 論理値。 FALSEにすると、再割付試行においてlSURVEYの対象者順を固定する。 nBLOCKSIZE 整数。 ブロック内の再割付試行数。 nNUMBLOCK 整数。 実行する再割付試行のブロック数。 bPARALLEL 論理値。 並列処理するか。 sLOGFILE 文字列。 並列処理する場合のログファイル(フルパス)。NULLだとログを出さない。 sDBPATH 文字列。 シミュレーションの結果を保存するSQLite DBのフルパス。 存在しない場合は作成する。 sDBTABLE_CAT 文字列。 再割付シミュレーションの結果得られたカテゴリ割付頻度を保存するSQLite DBのテーブル名。 sDBTABLE_SLOT 文字列。 再割付シミュレーションの結果得られたスロット割付頻度を保存するSQLite DBのテーブル名。 bAPPEND 論理値。 結果をテーブルにTRUE: 追加する, FALSE: 上書きする。 sVERBOSE 文字列。 画面表示レベル。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/simWeight.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"run simulations for computing weights — simWeight","text":"sDBPATHを指定しない場合は、シミュレーションの結果をデータフレームのリストとして返す。 sDBPATHを指定した場合はNULLを返す。シミュレーションの結果は、            SQLiteデータベースにテーブルとして保存される。sDBPATH が存在する場合は、            bAPPEND==FALSEであればSDBPATHに上書きし、bAPPEND==TRUEであれば追加する。            sDBPATHが存在しない場合は新規作成する。 シミュレーションの結果は次の2つのデータフレームからなる。  dfStat_Cat: カテゴリ割付頻度。行は調査対象者x割付カテゴリを表す。    列は以下のとおり(順不同):  nBlock:           ブロック番号 nBlockSize:       ブロックサイズ(ブロック内の再割付試行数) nSubject:         調査対象者番号 nCat:             カテゴリ番号 nCount_Subject:    ブロック内の再割付試行で調査対象者が出現した回数 nCount_SubjectCat: ブロック内の再割付試行で調査対象者が出現しカテゴリに割り付けられた回数  dfStat_Slot: スロット割付頻度。行は調査対象者x割付スロットを表す。    列は以下のとおり(順不同):  nBlock:           ブロック番号 nBlockSize:       ブロックサイズ(ブロック内の再割付試行数) nSubject:         調査対象者番号 nCat:             スロットが属するカテゴリ番号 nSlot:            スロット番号 nCount_Subject:   ブロック内の再割付試行で調査対象者が出現した回数 nCount_SubjectSlot: ブロック内の再割付試行で調査対象者が出現しスロットに割り付けられた回数","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/simWeight.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"run simulations for computing weights — simWeight","text":"bAPPEND==TRUEで、sDBPATHが存在するがテーブルsDBTABLE_CAT,    sDBTABLE_SLOTが存在しない場合はエラーとなる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_checkcat.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal: Check assigned categories — sub_checkcat","title":"Internal: Check assigned categories — sub_checkcat","text":"Internal. ある対象者について、ありうる割付カテゴリの組み合わせを           すべて返す。           checkSurvey()からコールされる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_checkcat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal: Check assigned categories — sub_checkcat","text":"","code":"sub_checkcat(   abCatNo_Use,   abCatNo_Open,   anCatNo_OpenCount,   anCatNo_AllCount,   nCAT_MAX,   sCAT_TYPE,   sCAT_FILTER,   sCAT_ORDER,   sCAT_EXCLUDE,   bDEBUG )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_checkcat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal: Check assigned categories — sub_checkcat","text":"abCatNo_Use binary vector. カテゴリの番号から割付可能かどうかを引くベクトル。 abCatNo_Open binary vector. カテゴリの番号からオープンかどうかを引くベクトル。 anCatNo_OpenCount integer vector. カテゴリの番号からオープンスロット数を引くベクトル。 anCatNo_AllCount integer vector. カテゴリの番号からスロット数を引くベクトル。 nCAT_MAX 整数。 ある対象者に割り付けるカテゴリ数の上限。 sCAT_TYPE 文字列。 カテゴリ割付タイプ。 sCAT_FILTER 文字列。 カテゴリ割付の際の絞り込み条件。 sCAT_ORDER 文字列。 カテゴリ割付の際の順序付け条件。 sCAT_EXCLUDE 文字列。 カテゴリ割付の際の除外条件。 bDEBUG logical. デバッグモード","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_checkcat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal: Check assigned categories — sub_checkcat","text":"list integer vectors.    要素は割付カテゴリのある組み合わせ。ソート済み。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_checkslot.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal: Check assigned slots — sub_checkslot","title":"Internal: Check assigned slots — sub_checkslot","text":"Internal. ある対象者のあるカテゴリについて、           ありうる割付スロットの組み合わせをすべて返す。           checkSurvey()からコールされる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_checkslot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal: Check assigned slots — sub_checkslot","text":"","code":"sub_checkslot(   abSlotNo_Hit,   abSlotNo_Open,   anSlotNo_Count,   anSlotNo_Request,   nSLOT_MAX,   sSLOT_TYPE,   sSLOT_FILTER,   sSLOT_ORDER,   sSLOT_EXCLUDE,   bDEBUG )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_checkslot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal: Check assigned slots — sub_checkslot","text":"abSlotNo_Hit binary vector. スロット番号から割付可能かどうかを引くベクトル abSlotNo_Open binary vector. スロット番号からオープンかどうかを引くベクトル anSlotNo_Count integer vector. スロット番号から獲得票数を引くベクトル anSlotNo_Request integer vector. スロット番号から目標票数を引くベクトル nSLOT_MAX 整数。 ある対象者に割り付けるスロット数の上限。 sSLOT_TYPE 文字列。 スロット割付タイプ。指定は必須。詳細はvignetteを参照。 sSLOT_FILTER 文字列。 スロット割付の際の絞り込み条件。指定は必須。詳細はvignetteを参照。 sSLOT_ORDER 文字列。 スロット割付の際の順序付け条件。指定は必須。詳細はvignetteを参照。 sSLOT_EXCLUDE 文字列。 スロット割付の際の除外条件。指定は必須。詳細はvignetteを参照。 bDEBUG logical. デバッグモード","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_checkslot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal: Check assigned slots — sub_checkslot","text":"list integer vectors.    要素は割付スロットの組み合わせ。ソート済み。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_getcat.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal: Assign a participant into categories — sub_getcat","title":"Internal: Assign a participant into categories — sub_getcat","text":"Internal. ある対象者について、割付カテゴリを決定する。          execAssign()からコールされる","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_getcat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal: Assign a participant into categories — sub_getcat","text":"","code":"sub_getcat(   abCatNo_Use,   abCatNo_Open,   anCatNo_OpenCount,   anCatNo_AllCount,   nCAT_MAX,   sCAT_TYPE,   sCAT_FILTER,   sCAT_ORDER,   sCAT_EXCLUDE,   bDEBUG )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_getcat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal: Assign a participant into categories — sub_getcat","text":"abCatNo_Use binary vector. カテゴリの番号から割付可能かどうかを引くベクトル。 abCatNo_Open binary vector. カテゴリの番号からオープンかどうかを引くベクトル。 anCatNo_OpenCount integer vector. カテゴリの番号からオープンスロット数を引くベクトル。 anCatNo_AllCount integer vector. カテゴリの番号からスロット数を引くベクトル。 nCAT_MAX 整数。 ある対象者に割り付けるカテゴリ数の上限。 sCAT_TYPE 文字列。 カテゴリ割付タイプ。 sCAT_FILTER 文字列。 カテゴリ割付の際の絞り込み条件。 sCAT_ORDER 文字列。 カテゴリ割付の際の順序付け条件。 sCAT_EXCLUDE 文字列。 カテゴリ割付の際の除外条件。 bDEBUG logical. デバッグモード","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_getcat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal: Assign a participant into categories — sub_getcat","text":"integer vector.    割付カテゴリの番号。長さはnCAT_MAX, 足りない分はNAを詰める","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_getslot.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal: Assign a participant into slots — sub_getslot","title":"Internal: Assign a participant into slots — sub_getslot","text":"Internal. ある対象者について、あるカテゴリの割付スロットを決定する。           execAssign()からコールされる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_getslot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal: Assign a participant into slots — sub_getslot","text":"","code":"sub_getslot(   abSlotNo_Hit,   abSlotNo_Open,   anSlotNo_Count,   anSlotNo_Request,   nSLOT_MAX,   sSLOT_TYPE,   sSLOT_FILTER,   sSLOT_ORDER,   sSLOT_EXCLUDE,   bDEBUG )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_getslot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal: Assign a participant into slots — sub_getslot","text":"abSlotNo_Hit binary vector. スロット番号から割付可能かどうかを引くベクトル abSlotNo_Open binary vector. スロット番号からオープンかどうかを引くベクトル anSlotNo_Count integer vector. スロット番号から獲得票数を引くベクトル anSlotNo_Request integer vector. スロット番号から目標票数を引くベクトル nSLOT_MAX 整数。 ある対象者に割り付けるスロット数の上限。 sSLOT_TYPE 文字列。 スロット割付タイプ。指定は必須。詳細はvignetteを参照。 sSLOT_FILTER 文字列。 スロット割付の際の絞り込み条件。指定は必須。詳細はvignetteを参照。 sSLOT_ORDER 文字列。 スロット割付の際の順序付け条件。指定は必須。詳細はvignetteを参照。 sSLOT_EXCLUDE 文字列。 スロット割付の際の除外条件。指定は必須。詳細はvignetteを参照。 bDEBUG logical. デバッグモード","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_getslot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal: Assign a participant into slots — sub_getslot","text":"integer vector.    割付スロットの番号。長さはnSLOT_MAX, 足りない分はNAを詰める","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_makeSubjectCat_Alt.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal: make a table to extract a set of alternative persons from person and category — sub_makeSubjectCat_Alt","title":"Internal: make a table to extract a set of alternative persons from person and category — sub_makeSubjectCat_Alt","text":"Internal: 対象者番号とカテゴリから, 代替する対象者番号群を引く表を作る           makeSurvey()からコールされる","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_makeSubjectCat_Alt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal: make a table to extract a set of alternative persons from person and category — sub_makeSubjectCat_Alt","text":"","code":"sub_makeSubjectCat_Alt(mbCAT, lSLOT, sVERBOSE = c(\"simple\", \"none\", \"detail\"))"},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_makeSubjectCat_Alt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal: make a table to extract a set of alternative persons from person and category — sub_makeSubjectCat_Alt","text":"mbCAT 整数行列。 調査対象者のカテゴリ割付可能性。 mbCAT[,j]は以下を表す。欠損不可。 1: 調査対象者iはカテゴリjについて割付可能。 0: 調査対象者iはカテゴリjについて割付不能。 lSLOT 整数行列のリスト。 調査対象者のスロット割付可能性。 lSLOT[[j]][,k]は以下を表す。 1: 調査対象者iはカテゴリjのスロットkについて割付可能。 0: 調査対象者iはカテゴリjのスロットkについて割付不能。 欠損についてはDetailsを参照。 sVERBOSE string. 画面表示レベル。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_makeSubjectCat_Alt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal: make a table to extract a set of alternative persons from person and category — sub_makeSubjectCat_Alt","text":"リスト。以下の要素を持つ。 manSubjectCat_AltSet       整数ベクトルの行列。行は対象者(mbCATの行),       列はカテゴリ(mbCATの列), 要素はその対象者のスロット割付可能性を調べるときに       参照すべき対象者番号のベクトル。mbCAT[,j] == 1のときは長さ1以上のベクトル、       mbCAT[,j] == 0のときはNULL. mnSubjectCat_AltStatus       整数ベクトルの行列。行は対象者(mbCATの行),       列はカテゴリ(mbCATの列), 要素は以下のいずれか: NA: 割付不能カテゴリ 0: スロット割付可能性が既知 1: スロット割付可能性が未知であるためカテゴリ割付可能性が同じ対象者で代替 2: スロット割付可能性が未知であるため割付カテゴリ数が同じ対象者で代替 3: スロット割付可能性が未知であるためランダムに選んだ対象者で代替","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_makeSurvey_from_trial.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal: make virtual survey data based on the returned value from execTrials() — sub_makeSurvey_from_trial","title":"Internal: make virtual survey data based on the returned value from execTrials() — sub_makeSurvey_from_trial","text":"Internal: 割付シミュレーションの結果に基づいて仮想的な調査データをつくる。           simBias()からコールされる。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_makeSurvey_from_trial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal: make virtual survey data based on the returned value from execTrials() — sub_makeSurvey_from_trial","text":"","code":"sub_makeSurvey_from_trial(   lPOP,   lSETTING,   dfSubject,   bUSE_INFO_UNASSIGNED_CAT,   sVERBOSE = c(\"simple\", \"detail\", \"none\") )"},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_makeSurvey_from_trial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal: make virtual survey data based on the returned value from execTrials() — sub_makeSurvey_from_trial","text":"lPOP `popdata`クラスのオブジェクト。 母集団データ。makePopで生成する。 lSETTING `assignsetting`クラスのオブジェクト。 割付のセッティング。makeSetting で生成する。 dfSubject データフレーム。 execTrials()の返し値。 bUSE_INFO_UNASSIGNED_CAT 論理値。 非割付カテゴリに属するスロットへの割付可能性を利用するか。 TRUEの場合、すべての割付可能カテゴリに属するスロット割付可能性を格納。 FALSEの場合、割付カテゴリに属するスロット割付可能性のみを格納。 sVERBOSE 文字列。 画面表示レベル。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/sub_makeSurvey_from_trial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal: make virtual survey data based on the returned value from execTrials() — sub_makeSurvey_from_trial","text":"makeSurvey()の返し値。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/surveydata.html","id":null,"dir":"Reference","previous_headings":"","what":"survey data — surveydata","title":"survey data — surveydata","text":"vignetteでの説明に用いる調査データ。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/surveydata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"survey data — surveydata","text":"","code":"data(surveydata)"},{"path":"https://shigono.github.io/rSurveyAssign/reference/surveydata.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"survey data — surveydata","text":"object class data.frame 504 rows 39 columns.","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/surveydata.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"survey data — surveydata","text":"架空の調査データ。カテゴリ数3, 各カテゴリのスロット数は10。 割付カテゴリ数の上限は2, 割付カテゴリ数の上限は2, 目標対象者数はすべてのスロットについて10。カテゴリ割付の方法は、 (adaptive、open, random, none), スロット割付の方法は(adaptive, , shortnum, allclosed)であった。 調査の結果、調査対象者数は504となった。 以下の列を持つ。 SEQ 調査参加順序 nCat_1 カテゴリ1の割付可能性(0:割付不能, 1:割付可能) nCat_2 カテゴリ2の割付可能性(0:割付不能, 1:割付可能) nCat_3 カテゴリ3の割付可能性(0:割付不能, 1:割付可能) bSlot_1_1 カテゴリ1, スロット1の割付可能性(0:割付不能, 1:割付可能, NA:不明) bSlot_1_2 カテゴリ1, スロット2の割付可能性(0:割付不能, 1:割付可能, NA:不明) ... bSlot_3_10 カテゴリ3, スロット10の割付可能性(0:割付不能, 1:割付可能, NA:不明) nAssignedCat_1, nAssignCat_2: この対象者に割り付けられたカテゴリの番号。 割り付けられたカテゴリが0～1個の場合はNAが格納される。 ある対象者におけるnAssignedCat_1の値とnAssignedCat_2の値の順序に意味はない。 nAssignedCat_Slots: 割り付けられたスロットが属するカテゴリ番号。 スロット割付が行われなかった場合はNA。 nAssignedCat_1, nAssignedCat_2: 割り付けられたスロット番号。 割り付けられたスロットが0～1個の場合はNAが格納される。 ある対象者におけるnAssignedSlot_1の値とnAssignedSlot_2の値の順序に意味はない。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/trimWeight.html","id":null,"dir":"Reference","previous_headings":"","what":"trim Weight — trimWeight","title":"trim Weight — trimWeight","text":"ウェイトを切り詰める","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/trimWeight.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"trim Weight — trimWeight","text":"","code":"trimWeight(agWEIGHT, gLIMIT = 5)"},{"path":"https://shigono.github.io/rSurveyAssign/reference/trimWeight.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"trim Weight — trimWeight","text":"agWEIGHT 数値ベクトル。ウェイト。 gLIMIT 切り詰める限界。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/reference/trimWeight.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"trim Weight — trimWeight","text":"数値ベクトル。agWEIGHTが上限gLIMIT, 下限1/gLIMITの範囲に 収まっていたらそのまま返す。そうでないときは、 この範囲に切り詰め、かつ平均を1としたベクトルを返す。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/news/index.html","id":"rsurveyassign-031","dir":"Changelog","previous_headings":"","what":"rSurveyAssign 0.3.1","title":"rSurveyAssign 0.3.1","text":"vignetteを修正。読みやすくなっているとよいのですが。","code":""},{"path":"https://shigono.github.io/rSurveyAssign/news/index.html","id":"rsurveyassign-030","dir":"Changelog","previous_headings":"","what":"rSurveyAssign 0.3.0","title":"rSurveyAssign 0.3.0","text":"first public release.","code":""}]
